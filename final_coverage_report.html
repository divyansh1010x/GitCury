
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">GitCury/config/config.go (51.1%)</option>
				
				<option value="file1">GitCury/core/commit.go (17.8%)</option>
				
				<option value="file2">GitCury/core/msgs.go (1.8%)</option>
				
				<option value="file3">GitCury/core/push.go (64.9%)</option>
				
				<option value="file4">GitCury/embeddings/embeddings.go (36.5%)</option>
				
				<option value="file5">GitCury/git/git.go (19.4%)</option>
				
				<option value="file6">GitCury/git/progress.go (0.0%)</option>
				
				<option value="file7">GitCury/git/recovery.go (31.7%)</option>
				
				<option value="file8">GitCury/output/output.go (70.5%)</option>
				
				<option value="file9">GitCury/tests/mocks/mocks.go (19.2%)</option>
				
				<option value="file10">GitCury/tests/testreport/testreport.go (0.0%)</option>
				
				<option value="file11">GitCury/tests/testutils/testutils.go (75.9%)</option>
				
				<option value="file12">GitCury/utils/errors.go (60.7%)</option>
				
				<option value="file13">GitCury/utils/files.go (58.6%)</option>
				
				<option value="file14">GitCury/utils/gemini.go (0.0%)</option>
				
				<option value="file15">GitCury/utils/logger.go (86.7%)</option>
				
				<option value="file16">GitCury/utils/progress.go (0.0%)</option>
				
				<option value="file17">GitCury/utils/prompt.go (0.0%)</option>
				
				<option value="file18">GitCury/utils/resource.go (0.0%)</option>
				
				<option value="file19">GitCury/utils/retry.go (50.0%)</option>
				
				<option value="file20">GitCury/utils/workerpool.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "GitCury/utils"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sync"
)

var (
        settings = make(map[string]interface{})
        mu       sync.RWMutex
)

type Alias struct {
        Commit  string `json:"commit"`
        Push    string `json:"push"`
        GetMsgs string `json:"getmsgs"`
        Output  string `json:"output"`
        Config  string `json:"config"`
        Setup   string `json:"setup"`
        Boom    string `json:"boom"`
}

var (
        Aliases        Alias
        DefaultAliases = Alias{
                Commit:  "seal",
                Push:    "deploy",
                GetMsgs: "genesis",
                Output:  "trace",
                Config:  "nexus",
                Setup:   "bootstrap",
                Boom:    "cascade",
        }
)

func init() <span class="cov8" title="1">{
        LoadConfig()
}</span>

func LoadConfig() error <span class="cov8" title="1">{
        configFilePath := os.Getenv("HOME") + "/.gitcury/config.json"
        file, err := os.Open(configFilePath)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                // Set default settings if the file does not exist
                settings = map[string]interface{}{
                        "app_name":         "GitCury",
                        "version":          "1.0.0",
                        "root_folders":     []string{"."},
                        "config_dir":       os.Getenv("HOME") + "/.gitcury",
                        "output_file_path": os.Getenv("HOME") + "/.gitcury/output.json",
                        "editor":           "nano",
                        "aliases": map[string]string{
                                "getmsgs": DefaultAliases.GetMsgs,
                                "commit":  DefaultAliases.Commit,
                                "push":    DefaultAliases.Push,
                                "output":  DefaultAliases.Output,
                                "config":  DefaultAliases.Config,
                                "setup":   DefaultAliases.Setup,
                                "boom":    DefaultAliases.Boom,
                        },
                        "retries":       3,
                        "timeout":       30,
                        "maxConcurrent": 5,
                        "logLevel":      "info",
                }

                // Save the default settings to the file
                if err := saveConfigToFile(configFilePath); err != nil </span><span class="cov0" title="0">{
                        utils.Error("[Config]: Failed to save default configuration: " + err.Error())
                        return utils.NewConfigError(
                                "Failed to save default configuration",
                                err,
                                map[string]interface{}{
                                        "configPath": configFilePath,
                                },
                        )
                }</span>

                <span class="cov8" title="1">utils.Debug("[Config]: Config file not found. Using default settings and saving to file: \n" + utils.ToJSON(settings))

                // Set up aliases with default values
                Aliases = DefaultAliases
                return nil</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                utils.Error("[Config]: Error opening configuration file: " + err.Error())
                return utils.NewConfigError(
                        "Error opening configuration file",
                        err,
                        map[string]interface{}{
                                "configPath": configFilePath,
                        },
                )
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Parse the config file
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;settings); err != nil </span><span class="cov0" title="0">{
                utils.Error("[Config]: Error parsing configuration file: " + err.Error())
                return utils.NewConfigError(
                        "Error parsing configuration file",
                        err,
                        map[string]interface{}{
                                "configPath": configFilePath,
                        },
                )
        }</span>

        // Validate required settings
        <span class="cov8" title="1">if err := validateConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set up aliases
        <span class="cov8" title="1">aliasesMap, ok := settings["aliases"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Warning("[Config]: No aliases configuration found. Using defaults.")
                Aliases = DefaultAliases
        }</span> else<span class="cov8" title="1"> {
                // Convert the map to our Alias struct
                commitAlias, _ := aliasesMap["commit"].(string)
                if commitAlias == "" </span><span class="cov0" title="0">{
                        commitAlias = DefaultAliases.Commit
                }</span>

                <span class="cov8" title="1">pushAlias, _ := aliasesMap["push"].(string)
                if pushAlias == "" </span><span class="cov0" title="0">{
                        pushAlias = DefaultAliases.Push
                }</span>

                <span class="cov8" title="1">getMsgsAlias, _ := aliasesMap["getmsgs"].(string)
                if getMsgsAlias == "" </span><span class="cov0" title="0">{
                        getMsgsAlias = DefaultAliases.GetMsgs
                }</span>

                <span class="cov8" title="1">outputAlias, _ := aliasesMap["output"].(string)
                if outputAlias == "" </span><span class="cov0" title="0">{
                        outputAlias = DefaultAliases.Output
                }</span>

                <span class="cov8" title="1">configAlias, _ := aliasesMap["config"].(string)
                if configAlias == "" </span><span class="cov0" title="0">{
                        configAlias = DefaultAliases.Config
                }</span>

                <span class="cov8" title="1">setupAlias, _ := aliasesMap["setup"].(string)
                if setupAlias == "" </span><span class="cov0" title="0">{
                        setupAlias = DefaultAliases.Setup
                }</span>

                <span class="cov8" title="1">boomAlias, _ := aliasesMap["boom"].(string)
                if boomAlias == "" </span><span class="cov0" title="0">{
                        boomAlias = DefaultAliases.Boom
                }</span>

                <span class="cov8" title="1">Aliases = Alias{
                        Commit:  commitAlias,
                        Push:    pushAlias,
                        GetMsgs: getMsgsAlias,
                        Output:  outputAlias,
                        Config:  configAlias,
                        Setup:   setupAlias,
                        Boom:    boomAlias,
                }</span>
        }

        // Set log level if available
        <span class="cov8" title="1">logLevel, ok := settings["logLevel"].(string)
        if ok &amp;&amp; logLevel != "" </span><span class="cov8" title="1">{
                utils.SetLogLevel(logLevel)
        }</span>

        <span class="cov8" title="1">utils.Debug("[Config]: Configuration loaded successfully: \n" + utils.ToJSON(settings))
        utils.Debug("[Config]: Aliases loaded successfully: \n" + utils.ToJSON(Aliases))

        return nil</span>
}

// validateConfig ensures that required configuration values are present and valid
func validateConfig() error <span class="cov8" title="1">{
        // Check for required configuration fields
        requiredFields := []string{"app_name", "version", "root_folders"}
        missingFields := []string{}

        for _, field := range requiredFields </span><span class="cov8" title="1">{
                if _, exists := settings[field]; !exists </span><span class="cov0" title="0">{
                        missingFields = append(missingFields, field)
                }</span>
        }

        <span class="cov8" title="1">if len(missingFields) &gt; 0 </span><span class="cov0" title="0">{
                utils.Warning("[Config]: Missing required configuration fields: " + fmt.Sprint(missingFields))
                // Add default values for missing fields
                if _, exists := settings["app_name"]; !exists </span><span class="cov0" title="0">{
                        settings["app_name"] = "GitCury"
                }</span>
                <span class="cov0" title="0">if _, exists := settings["version"]; !exists </span><span class="cov0" title="0">{
                        settings["version"] = "1.0.0"
                }</span>
                <span class="cov0" title="0">if _, exists := settings["root_folders"]; !exists </span><span class="cov0" title="0">{
                        settings["root_folders"] = []string{"."}
                }</span>
        }

        // Validate root_folders
        <span class="cov8" title="1">rootFolders, ok := settings["root_folders"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Warning("[Config]: Invalid root_folders configuration. Must be an array.")
                settings["root_folders"] = []string{"."}
        }</span> else<span class="cov8" title="1"> if len(rootFolders) == 0 </span><span class="cov0" title="0">{
                utils.Warning("[Config]: Empty root_folders configuration. Adding current directory.")
                settings["root_folders"] = []string{"."}
        }</span>

        // Ensure output_file_path is set
        <span class="cov8" title="1">if _, exists := settings["output_file_path"]; !exists </span><span class="cov0" title="0">{
                settings["output_file_path"] = os.Getenv("HOME") + "/.gitcury/output.json"
        }</span>

        // Ensure config_dir is set
        <span class="cov8" title="1">if _, exists := settings["config_dir"]; !exists </span><span class="cov0" title="0">{
                settings["config_dir"] = os.Getenv("HOME") + "/.gitcury"
        }</span>

        // Check for API key
        <span class="cov8" title="1">if geminiKey, exists := settings["GEMINI_API_KEY"]; !exists || geminiKey == "" </span><span class="cov0" title="0">{
                // Try to get from environment
                envKey := os.Getenv("GEMINI_API_KEY")
                if envKey == "" </span><span class="cov0" title="0">{
                        utils.Warning("[Config]: GEMINI_API_KEY not found in config or environment. Some features may not work correctly.")
                }</span> else<span class="cov0" title="0"> {
                        utils.Debug("[Config]: Using GEMINI_API_KEY from environment.")
                        settings["GEMINI_API_KEY"] = envKey
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func saveConfigToFile(configFilePath string) error <span class="cov8" title="1">{
        // Ensure the directory exists
        dir := filepath.Dir(configFilePath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">file, err := os.OpenFile(configFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        encoder := json.NewEncoder(file)
        return encoder.Encode(settings)</span>
}

func Set(key string, value any) <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()
        settings[key] = value

        utils.Debug("[" + Aliases.Config + "]: 💾 Saving updated configuration...")

        configFilePath := os.Getenv("HOME") + "/.gitcury/config.json"

        dir := os.Getenv("HOME") + "/.gitcury"
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ⚠️ Error creating config directory: " + err.Error())
                return
        }</span>

        <span class="cov8" title="1">file, err := os.OpenFile(configFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ⚠️ Error saving configuration: " + err.Error())
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()

        encoder := json.NewEncoder(file)
        if err := encoder.Encode(settings); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ⚠️ Error encoding configuration: " + err.Error())
        }</span>
}

func Get(key string) interface{} <span class="cov8" title="1">{
        mu.RLock()
        defer mu.RUnlock()
        utils.Debug("[" + Aliases.Config + "]: 🔍 Retrieving configuration key: " + key + " with value: " + utils.ToJSON(settings[key]))
        return settings[key]
}</span>

func GetAll() map[string]interface{} <span class="cov0" title="0">{
        mu.RLock()
        defer mu.RUnlock()
        copy := make(map[string]interface{})
        for key, value := range settings </span><span class="cov0" title="0">{
                copy[key] = value
        }</span>
        <span class="cov0" title="0">return copy</span>
}

func Remove(key string) <span class="cov0" title="0">{
        mu.Lock()
        defer mu.Unlock()
        delete(settings, key)

        go func() </span><span class="cov0" title="0">{
                mu.RLock()
                defer mu.RUnlock()

                configFilePath := os.Getenv("HOME") + "/.gitcury/ json"

                file, err := os.OpenFile(configFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("[" + Aliases.Config + "]: ⚠️ Error saving configuration after removal: " + err.Error())
                        return
                }</span>
                <span class="cov0" title="0">defer file.Close()

                encoder := json.NewEncoder(file)
                if err := encoder.Encode(settings); err != nil </span><span class="cov0" title="0">{
                        utils.Error("[" + Aliases.Config + "]: ⚠️ Error saving configuration after removal: " + err.Error())
                }</span>
        }()
}

func Delete() <span class="cov0" title="0">{
        utils.Debug("[" + Aliases.Config + "]: 🗑️ Deleting configuration file...")
        mu.Lock()
        defer mu.Unlock()
        configFilePath := os.Getenv("HOME") + "/.gitcury/ json"
        if err := os.Remove(configFilePath); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ⚠️ Error deleting configuration file: " + err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package core

import (
        "GitCury/config"
        "GitCury/git"
        "GitCury/output"
        "GitCury/utils"
        "fmt"
        "strings"
        "time"
)

func CommitAllRoots(env ...[]string) error <span class="cov8" title="1">{
        rootFolders := output.GetAll().Folders
        if len(rootFolders) == 0 </span><span class="cov8" title="1">{
                utils.Warning("[" + config.Aliases.Commit + "]: No root folders with changes to commit")
                return nil
        }</span>

        // Determine optimal worker count based on available folders
        <span class="cov0" title="0">workerCount := 3
        if len(rootFolders) &lt; workerCount </span><span class="cov0" title="0">{
                workerCount = len(rootFolders)
        }</span>

        // Create worker pool for parallel execution with limited concurrency
        <span class="cov0" title="0">pool := utils.NewWorkerPool(workerCount)
        utils.Debug("[" + config.Aliases.Commit + "]: Created worker pool with " + fmt.Sprint(workerCount) + " workers for " + fmt.Sprint(len(rootFolders)) + " folders")

        // Submit commit tasks for each root folder
        for _, rootFolder := range rootFolders </span><span class="cov0" title="0">{
                folder := rootFolder // Create local copy to avoid closure issues
                taskName := "CommitRoot:" + folder.Name

                pool.Submit(taskName, 2*time.Minute, func() error </span><span class="cov0" title="0">{
                        utils.Debug("[" + config.Aliases.Commit + "]: Processing root folder: " + folder.Name)

                        if len(folder.Files) == 0 </span><span class="cov0" title="0">{
                                utils.Debug("[" + config.Aliases.Commit + "]: No files to commit in folder: " + folder.Name)
                                return nil
                        }</span>

                        <span class="cov0" title="0">err := git.CommitBatch(folder, env...)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[" + config.Aliases.Commit + ".FAIL]: Failed to commit batch for folder '" + folder.Name + "' - " + err.Error())
                                return utils.NewGitError(
                                        "Failed to commit changes in folder",
                                        err,
                                        map[string]interface{}{
                                                "folder":    folder.Name,
                                                "fileCount": len(folder.Files),
                                        },
                                )
                        }</span>

                        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.Commit + "]: Successfully committed changes in folder: " + folder.Name)
                        return nil</span>
                })
        }

        // Wait for all commit tasks to complete
        <span class="cov0" title="0">errors := pool.Wait()
        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                errorDetails := make([]string, 0, len(errors))
                for _, err := range errors </span><span class="cov0" title="0">{
                        errorDetails = append(errorDetails, err.Error())
                }</span>

                <span class="cov0" title="0">utils.Error("[" + config.Aliases.Commit + ".FAIL]: Batch commit completed with " + fmt.Sprint(len(errors)) + " errors")
                utils.Debug("[" + config.Aliases.Commit + ".FAIL]: Errors encountered: " + strings.Join(errorDetails, "; "))

                return utils.NewGitError(
                        fmt.Sprintf("%d errors occurred during batch commit", len(errors)),
                        fmt.Errorf("multiple commit errors"),
                        map[string]interface{}{
                                "errorCount": len(errors),
                                "errors":     errorDetails,
                        },
                )</span>
        }

        <span class="cov0" title="0">output.Clear()
        utils.Success("[" + config.Aliases.Commit + ".SUCCESS]: Batch commit completed successfully. Output cleared.")
        return nil</span>
}

func CommitOneRoot(rootFolderName string, env ...[]string) error <span class="cov8" title="1">{
        rootFolder := output.GetFolder(rootFolderName)
        if len(rootFolder.Files) == 0 </span><span class="cov8" title="1">{
                utils.Error("[" + config.Aliases.Commit + ".FAIL]: Root folder '" + rootFolderName + "' not found or contains no files.")
                return fmt.Errorf("root folder not found or has no files: %s", rootFolderName)
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.Commit + "]: Targeting root folder for commit: " + rootFolderName)

        err := git.CommitBatch(rootFolder, env...)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Commit + ".FAIL]: Failed to commit batch for folder '" + rootFolderName + "' - " + err.Error())
                return fmt.Errorf("failed to commit batch: %s", err.Error())
        }</span>

        <span class="cov0" title="0">utils.Success("[" + config.Aliases.Commit + ".SUCCESS]: Batch commit completed successfully for root folder: " + rootFolderName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

import (
        "GitCury/config"
        "GitCury/git"
        "GitCury/output"
        "GitCury/utils"
        "fmt"
        "strconv"
        "sync"
)

func GetAllMsgs(numFiles ...int) error <span class="cov0" title="0">{
        defaultNumFiles := 10 // Default value
        if len(numFiles) == 0 || numFiles[0] &lt;= 0 </span><span class="cov0" title="0">{
                numFiles[0] = defaultNumFiles
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Preparing commit messages for " + strconv.Itoa(numFiles[0]) + " files per folder.")

        rootFolders, ok := config.Get("root_folders").([]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid or missing root_folders configuration.")
                return fmt.Errorf("invalid or missing root_folders configuration")
        }</span>

        <span class="cov0" title="0">var rootFolderWg sync.WaitGroup
        var mu sync.Mutex
        var errors []string

        for _, rootFolder := range rootFolders </span><span class="cov0" title="0">{
                rootFolderStr, ok := rootFolder.(string)
                if !ok </span><span class="cov0" title="0">{
                        utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid root folder type.")
                        continue</span>
                }

                <span class="cov0" title="0">rootFolderWg.Add(1)
                go func(folder string) </span><span class="cov0" title="0">{
                        defer rootFolderWg.Done()

                        utils.Debug("[" + config.Aliases.GetMsgs + "]: Processing root folder: " + folder)

                        changedFiles, err := git.GetAllChangedFiles(folder)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[" + config.Aliases.GetMsgs + "]: Failed to retrieve changed files for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                                utils.Debug("[" + config.Aliases.GetMsgs + "]: No changed files found in folder: " + folder)
                                return
                        }</span>

                        <span class="cov0" title="0">if len(changedFiles) &gt; numFiles[0] </span><span class="cov0" title="0">{
                                changedFiles = changedFiles[:numFiles[0]]
                        }</span>

                        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Total files to process in folder '" + folder + "': " + strconv.Itoa(len(changedFiles)))

                        err = git.BatchProcessGetMessages(changedFiles, folder)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[" + config.Aliases.GetMsgs + "]: Batch processing failed for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                        }</span>
                }(rootFolderStr)
        }

        <span class="cov0" title="0">rootFolderWg.Wait()

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Batch processing completed with errors.")
                utils.Debug("[" + config.Aliases.GetMsgs + "]: Errors encountered: " + fmt.Sprint(errors))
                return fmt.Errorf("one or more errors occurred while preparing commit messages")
        }</span>

        <span class="cov0" title="0">utils.Success("[" + config.Aliases.GetMsgs + "]: Commit message generation completed successfully for all folders.")
        output.SaveToFile()
        return nil</span>
}

func GetMsgsForRootFolder(folder string, numFiles ...int) error <span class="cov8" title="1">{
        if folder == "" </span><span class="cov8" title="1">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Root folder is empty.")
                return fmt.Errorf("root folder is empty")
        }</span>

        <span class="cov0" title="0">numFilesToCommit := 10 // Default value
        if len(numFiles) &gt; 0 &amp;&amp; numFiles[0] &gt; 0 </span><span class="cov0" title="0">{
                utils.Debug("[" + config.Aliases.GetMsgs + "]: Using provided number of files to commit: " + strconv.Itoa(numFiles[0]))
                numFilesToCommit = numFiles[0]
        }</span> else<span class="cov0" title="0"> {
                if configValue := config.Get("numFilesToCommit"); configValue != "" </span><span class="cov0" title="0">{
                        if configValueFloat, ok := configValue.(float64); ok </span><span class="cov0" title="0">{
                                utils.Debug("[" + config.Aliases.GetMsgs + "]: Using config value for numFilesToCommit: " + strconv.FormatFloat(configValueFloat, 'f', -1, 64))
                                numFilesToCommit = int(configValueFloat)
                        }</span> else<span class="cov0" title="0"> if configValueStr, ok := configValue.(string); ok </span><span class="cov0" title="0">{
                                if parsedValue, err := strconv.Atoi(configValueStr); err == nil </span><span class="cov0" title="0">{
                                        utils.Debug("[" + config.Aliases.GetMsgs + "]: Using config value for numFilesToCommit from string: " + configValueStr)
                                        numFilesToCommit = parsedValue
                                }</span> else<span class="cov0" title="0"> {
                                        utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid string value for numFilesToCommit: " + configValueStr)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Preparing commit messages for " + strconv.Itoa(numFilesToCommit) + " files in folder: " + folder)

        changedFiles, err := git.GetAllChangedFiles(folder)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Failed to retrieve changed files for folder '" + folder + "' - " + err.Error())
                return fmt.Errorf("failed to get changed files: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                utils.Debug("[" + config.Aliases.GetMsgs + "]: No changed files found in folder: " + folder)
                return nil
        }</span>

        <span class="cov0" title="0">if len(changedFiles) &gt; numFilesToCommit </span><span class="cov0" title="0">{
                changedFiles = changedFiles[:numFilesToCommit]
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Total files to process in folder '" + folder + "': " + strconv.Itoa(len(changedFiles)))

        err = git.BatchProcessGetMessages(changedFiles, folder)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Batch processing failed for folder '" + folder + "' - " + err.Error())
                return fmt.Errorf("batch processing failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">utils.Success("[" + config.Aliases.GetMsgs + "]: Commit message generation completed successfully for folder: " + folder)
        utils.Debug("[" + config.Aliases.GetMsgs + "]: All output: " + fmt.Sprint(output.GetAll()))
        output.SaveToFile()
        return nil</span>
}

func GroupAndGetAllMsgs(numFiles ...int) error <span class="cov0" title="0">{

        utils.Debug("[" + config.Aliases.GetMsgs + "]: Preparing grouped commit messages with embeddings for " + strconv.Itoa(numFiles[0]) + " files per folder.")

        rootFolders, ok := config.Get("root_folders").([]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid or missing root_folders configuration.")
                return fmt.Errorf("invalid or missing root_folders configuration")
        }</span>

        <span class="cov0" title="0">clusters := 10 // Default value
        if len(numFiles) &gt; 0 &amp;&amp; numFiles[0] &gt; 0 </span><span class="cov0" title="0">{
                utils.Debug("[" + config.Aliases.GetMsgs + "]: Using provided number of files to commit: " + strconv.Itoa(numFiles[0]))
                clusters = numFiles[0]
        }</span> else<span class="cov0" title="0"> {
                if configValue := config.Get("numFilesToCommit"); configValue != "" </span><span class="cov0" title="0">{
                        if configValueFloat, ok := configValue.(float64); ok </span><span class="cov0" title="0">{
                                utils.Debug("[" + config.Aliases.GetMsgs + "]: Using config value for numFilesToCommit: " + strconv.FormatFloat(configValueFloat, 'f', -1, 64))
                                clusters = int(configValueFloat)
                        }</span> else<span class="cov0" title="0"> if configValueStr, ok := configValue.(string); ok </span><span class="cov0" title="0">{
                                if parsedValue, err := strconv.Atoi(configValueStr); err == nil </span><span class="cov0" title="0">{
                                        utils.Debug("[" + config.Aliases.GetMsgs + "]: Using config value for numFilesToCommit from string: " + configValueStr)
                                        clusters = parsedValue
                                }</span> else<span class="cov0" title="0"> {
                                        utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid string value for numFilesToCommit: " + configValueStr)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">var rootFolderWg sync.WaitGroup
        var mu sync.Mutex
        var errors []string

        for _, rootFolder := range rootFolders </span><span class="cov0" title="0">{
                rootFolderStr, ok := rootFolder.(string)
                if !ok </span><span class="cov0" title="0">{
                        utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid root folder type.")
                        continue</span>
                }

                <span class="cov0" title="0">rootFolderWg.Add(1)
                go func(folder string) </span><span class="cov0" title="0">{
                        defer rootFolderWg.Done()

                        utils.Debug("[" + config.Aliases.GetMsgs + "]: Grouped (embedding-based) processing for folder: " + folder)

                        changedFiles, err := git.GetAllChangedFiles(folder)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[" + config.Aliases.GetMsgs + "]: Failed to retrieve changed files for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                                utils.Debug("[" + config.Aliases.GetMsgs + "]: No changed files found in folder: " + folder)
                                return
                        }</span>

                        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Total files to process with embeddings in folder '" + folder + "': " + strconv.Itoa(len(changedFiles)))

                        err = git.BatchProcessWithEmbeddings(changedFiles, folder, clusters)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[" + config.Aliases.GetMsgs + "]: Embedding-based batch processing failed for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                        }</span>
                }(rootFolderStr)
        }

        <span class="cov0" title="0">rootFolderWg.Wait()

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Grouped embedding-based batch processing completed with errors.")
                utils.Debug("[" + config.Aliases.GetMsgs + "]: Errors encountered: " + fmt.Sprint(errors))
                return fmt.Errorf("one or more errors occurred during grouped commit message generation with embeddings")
        }</span>

        <span class="cov0" title="0">utils.Success("[" + config.Aliases.GetMsgs + "]: Grouped commit message generation with embeddings completed successfully for all folders.")
        output.SaveToFile()
        return nil</span>
}

func GroupAndGetMsgsForRootFolder(folder string, numFiles ...int) error <span class="cov0" title="0">{
        if folder == "" </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Root folder is empty.")
                return fmt.Errorf("root folder is empty")
        }</span>

        <span class="cov0" title="0">clusters := 10 // Default value
        if len(numFiles) &gt; 0 &amp;&amp; numFiles[0] &gt; 0 </span><span class="cov0" title="0">{
                utils.Debug("[" + config.Aliases.GetMsgs + "]: Using provided number of files to commit: " + strconv.Itoa(numFiles[0]))
                clusters = numFiles[0]
        }</span> else<span class="cov0" title="0"> {
                if configValue := config.Get("numFilesToCommit"); configValue != "" </span><span class="cov0" title="0">{
                        if configValueFloat, ok := configValue.(float64); ok </span><span class="cov0" title="0">{
                                utils.Debug("[" + config.Aliases.GetMsgs + "]: Using config value for numFilesToCommit: " + strconv.FormatFloat(configValueFloat, 'f', -1, 64))
                                clusters = int(configValueFloat)
                        }</span> else<span class="cov0" title="0"> if configValueStr, ok := configValue.(string); ok </span><span class="cov0" title="0">{
                                if parsedValue, err := strconv.Atoi(configValueStr); err == nil </span><span class="cov0" title="0">{
                                        utils.Debug("[" + config.Aliases.GetMsgs + "]: Using config value for numFilesToCommit from string: " + configValueStr)
                                        clusters = parsedValue
                                }</span> else<span class="cov0" title="0"> {
                                        utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid string value for numFilesToCommit: " + configValueStr)
                                }</span>
                        }
                }
        }        

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Preparing commit messages for " + strconv.Itoa(clusters) + " files in folder: " + folder)

        changedFiles, err := git.GetAllChangedFiles(folder)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Failed to retrieve changed files for folder '" + folder + "' - " + err.Error())
                return fmt.Errorf("failed to get changed files: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                utils.Debug("[" + config.Aliases.GetMsgs + "]: No changed files found in folder: " + folder)
                return nil
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Total files to process in folder '" + folder + "': " + strconv.Itoa(len(changedFiles)))

        err = git.BatchProcessWithEmbeddings(changedFiles, folder, clusters)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Batch processing failed for folder '" + folder + "' - " + err.Error())
                return fmt.Errorf("batch processing failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">utils.Success("[" + config.Aliases.GetMsgs + "]: Commit message generation completed successfully for folder: " + folder)
        utils.Debug("[" + config.Aliases.GetMsgs + "]: All output: " + fmt.Sprint(output.GetAll()))
        output.SaveToFile()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package core

import (
        "GitCury/config"
        "GitCury/git"
        "GitCury/utils"
        "fmt"
        "sync"
)

func PushAllRoots(branchName string) error <span class="cov8" title="1">{
        rootFolders, ok := config.Get("root_folders").([]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Push + "]: ❌ Invalid or missing root_folders configuration")
                return fmt.Errorf("invalid or missing root_folders configuration")
        }</span>

        <span class="cov8" title="1">var rootFolderWg sync.WaitGroup
        var mu sync.Mutex
        var errors []string

        for _, rootFolder := range rootFolders </span><span class="cov8" title="1">{
                rootFolderStr, ok := rootFolder.(string)
                if !ok </span><span class="cov0" title="0">{
                        utils.Error("[" + config.Aliases.Push + "]: ⚠️ Invalid root folder type")
                        continue</span>
                }

                <span class="cov8" title="1">rootFolderWg.Add(1)

                go func(folder string) </span><span class="cov8" title="1">{
                        defer rootFolderWg.Done()
                        utils.Debug("[" + config.Aliases.Push + "]: 📂 Root folder to push: " + folder)

                        err := git.PushBranch(folder, branchName)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[" + config.Aliases.Push + "]: ❌ Failed to push branch for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                                return
                        }</span>
                        <span class="cov8" title="1">utils.Success("[" + config.Aliases.Push + "]: ✅ Successfully pushed branch for folder: " + folder)</span>
                }(rootFolderStr)
        }

        <span class="cov8" title="1">rootFolderWg.Wait()
        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Push + "]: ❌ Errors occurred during push operation")
                return fmt.Errorf("one or more errors occurred while pushing branches: %v", errors)
        }</span>

        <span class="cov8" title="1">utils.Success("[" + config.Aliases.Push + "]: 🌐 Push operation for all roots completed successfully")
        return nil</span>
}

func PushOneRoot(rootFolderName, branchName string) error <span class="cov8" title="1">{
        utils.Debug("[" + config.Aliases.Push + "]: 📂 Targeting root folder for push: " + rootFolderName)

        err := git.PushBranch(rootFolderName, branchName)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error("[" + config.Aliases.Push + "]: ❌ Failed to push branch for folder '" + rootFolderName + "' - " + err.Error())
                return fmt.Errorf("failed to push branch: %s", err.Error())
        }</span>

        <span class="cov0" title="0">utils.Success("[" + config.Aliases.Push + "]: ✅ Push operation for root folder '" + rootFolderName + "' completed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package embeddings

import (
        "GitCury/config"
        "GitCury/utils"
        "context"
        "math"
        "math/rand"
        "os"
        "time"

        "google.golang.org/genai"
)

func GenerateEmbedding(text string) ([]float32, error) <span class="cov8" title="1">{
        // Get the API key from config or environment
        apiKeyInterface := config.Get("GEMINI_API_KEY")
        apiKey, ok := apiKeyInterface.(string)
        if !ok || apiKey == "" </span><span class="cov0" title="0">{
                apiKey = os.Getenv("GEMINI_API_KEY")
                if apiKey == "" </span><span class="cov0" title="0">{
                        return nil, utils.NewConfigError(
                                "Google API key not found",
                                nil,
                                map[string]interface{}{
                                        "configKey": "GEMINI_API_KEY",
                                        "envVar":    "GEMINI_API_KEY",
                                },
                        )
                }</span>
        }

        // Create a context with timeout for the entire operation
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        var embedding *genai.ContentEmbedding

        // Initialize the client outside the retry loop for better performance
        client, err := genai.NewClient(ctx, &amp;genai.ClientConfig{
                APIKey:  apiKey,
                Backend: genai.BackendGeminiAPI,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, utils.NewAPIError(
                        "Error creating Gemini client",
                        err,
                        map[string]interface{}{
                                "apiProvider": "Google Gemini",
                        },
                )
        }</span>

        // Prepare the content once for all retries
        <span class="cov8" title="1">contents := []*genai.Content{
                genai.NewContentFromText(text, genai.RoleUser),
        }

        // Define the operation to retry
        embedOperation := func() error </span><span class="cov8" title="1">{
                result, err := client.Models.EmbedContent(ctx,
                        "gemini-embedding-exp-03-07",
                        contents,
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return utils.NewAPIError(
                                "Error getting embeddings from Gemini API",
                                err,
                                map[string]interface{}{
                                        "modelName":  "gemini-embedding-exp-03-07",
                                        "textLength": len(text),
                                },
                        )
                }</span>

                <span class="cov8" title="1">if len(result.Embeddings) == 0 || result.Embeddings[0] == nil </span><span class="cov0" title="0">{
                        return utils.NewAPIError(
                                "Received empty embedding response from API",
                                nil,
                                map[string]interface{}{
                                        "modelName": "gemini-embedding-exp-03-07",
                                },
                        )
                }</span>

                <span class="cov8" title="1">embedding = result.Embeddings[0]
                return nil</span>
        }

        // Use the retry mechanism with a custom configuration
        <span class="cov8" title="1">retryConfig := utils.RetryConfig{
                MaxRetries:   3,
                InitialDelay: 500 * time.Millisecond,
                MaxDelay:     5 * time.Second,
                Factor:       2.0,
        }

        err = utils.WithRetry(ctx, "GetEmbeddings", retryConfig, embedOperation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err // Already wrapped with context by WithRetry
        }</span>

        <span class="cov8" title="1">flatEmbeddings := embedding.Values

        if flatEmbeddings == nil || len(flatEmbeddings) == 0 </span><span class="cov0" title="0">{
                return nil, utils.NewAPIError(
                        "Received empty embedding vector from API",
                        nil,
                        map[string]interface{}{
                                "modelName":      "gemini-embedding-exp-03-07",
                                "responseStatus": "empty vector",
                        },
                )
        }</span>

        <span class="cov8" title="1">return flatEmbeddings, nil</span>
}

func KMeans(data [][]float32, k int, maxIter int) ([]int, error) <span class="cov0" title="0">{
        if k &lt;= 0 || len(data) == 0 </span><span class="cov0" title="0">{
                return nil, utils.NewValidationError(
                        "Invalid parameters for KMeans clustering",
                        nil,
                        map[string]interface{}{
                                "k":             k,
                                "dataPoints":    len(data),
                                "maxIterations": maxIter,
                        },
                )
        }</span>
        <span class="cov0" title="0">if len(data) &lt; k </span><span class="cov0" title="0">{
                return nil, utils.NewValidationError(
                        "Number of clusters cannot exceed data points",
                        nil,
                        map[string]interface{}{
                                "k":          k,
                                "dataPoints": len(data),
                        },
                )
        }</span>

        <span class="cov0" title="0">n := len(data)
        dim := len(data[0])
        labels := make([]int, n)
        centroids := make([][]float32, k)

        rand.Seed(time.Now().UnixNano())
        perm := rand.Perm(n)
        for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                centroids[i] = make([]float32, dim)
                copy(centroids[i], data[perm[i]])
        }</span>

        <span class="cov0" title="0">for iter := 0; iter &lt; maxIter; iter++ </span><span class="cov0" title="0">{
                for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        labels[i] = closestCentroid(data[i], centroids)
                }</span>

                <span class="cov0" title="0">newCentroids := make([][]float32, k)
                counts := make([]int, k)

                for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                        newCentroids[i] = make([]float32, dim)
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        label := labels[i]
                        counts[label]++
                        for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                                newCentroids[label][j] += data[i][j]
                        }</span>
                }

                <span class="cov0" title="0">for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                        if counts[i] == 0 </span><span class="cov0" title="0">{
                                newCentroids[i] = make([]float32, dim)
                                copy(newCentroids[i], data[rand.Intn(n)])
                        }</span> else<span class="cov0" title="0"> {
                                for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                                        newCentroids[i][j] /= float32(counts[i])
                                }</span>
                        }
                }

                <span class="cov0" title="0">centroids = newCentroids</span>
        }

        <span class="cov0" title="0">return labels, nil</span>
}

func closestCentroid(point []float32, centroids [][]float32) int <span class="cov0" title="0">{
        minDist := float64(math.MaxFloat64)
        minIndex := 0

        for i, c := range centroids </span><span class="cov0" title="0">{
                dist := float64(0.0)
                for j := range point </span><span class="cov0" title="0">{
                        d := float64(point[j] - c[j])
                        dist += d * d
                }</span>
                <span class="cov0" title="0">if dist &lt; minDist </span><span class="cov0" title="0">{
                        minDist = dist
                        minIndex = i
                }</span>
        }
        <span class="cov0" title="0">return minIndex</span>
}

// GetFileDiff gets the diff for a file using git commands
func GetFileDiff(filePath string) (string, error) <span class="cov8" title="1">{
        // This is a simplified version for testing
        // In real implementation, this would use git commands
        return "mock diff for " + filePath, nil
}</span>

// GenerateCommitMessage generates a commit message for the given file path
func GenerateCommitMessage(filePath string) (string, error) <span class="cov8" title="1">{
        // This is a simplified version for testing
        // In real implementation, this would use AI to generate commit messages
        return "feat: update " + filePath, nil
}</span>

// CosineSimilarity calculates the cosine similarity between two vectors
func CosineSimilarity(vec1, vec2 []float32) float32 <span class="cov8" title="1">{
        if len(vec1) != len(vec2) </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        
        <span class="cov8" title="1">var dotProduct, normA, normB float64
        
        for i := range vec1 </span><span class="cov8" title="1">{
                dotProduct += float64(vec1[i] * vec2[i])
                normA += float64(vec1[i] * vec1[i])
                normB += float64(vec2[i] * vec2[i])
        }</span>
        
        <span class="cov8" title="1">if normA == 0.0 || normB == 0.0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        
        <span class="cov8" title="1">return float32(dotProduct / (math.Sqrt(normA) * math.Sqrt(normB)))</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package git

import (
        "GitCury/config"
        "GitCury/embeddings"
        "GitCury/output"
        "GitCury/utils"
        "bytes"
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "time"
)

type FileEmbedding struct {
        Path      string
        Diff      string
        Embedding []float32
}

func RunGitCmd(dir string, envVars map[string]string, args ...string) (string, error) <span class="cov8" title="1">{
        return RunGitCmdWithTimeout(dir, envVars, 30*time.Second, args...)
}</span>

func RunGitCmdWithTimeout(dir string, envVars map[string]string, timeout time.Duration, args ...string) (string, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        cmd := exec.CommandContext(ctx, "git", args...)
        cmd.Dir = dir

        // Create environment with existing env vars
        env := os.Environ()

        // Append custom environment variables
        if envVars != nil </span><span class="cov0" title="0">{
                for key, value := range envVars </span><span class="cov0" title="0">{
                        env = append(env, fmt.Sprintf("%s=%s", key, value))
                }</span>
        }
        <span class="cov8" title="1">cmd.Env = env

        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        commandStr := "git " + strings.Join(args, " ")
        utils.Debug("[GIT.EXEC]: Running git command in '" + dir + "': " + commandStr)

        err := cmd.Run()

        // Check if the error is due to timeout
        if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                return "", utils.NewGitError(
                        "Git command timed out after "+timeout.String(),
                        ctx.Err(),
                        map[string]interface{}{
                                "directory": dir,
                                "command":   commandStr,
                                "timeout":   timeout.String(),
                        },
                )
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                errOutput := stderr.String()
                stdOutput := stdout.String()

                utils.Error(fmt.Sprintf(
                        "[GIT.EXEC.FAIL]: Command failed: %s\nStdout: %s\nStderr: %s\n",
                        err,
                        stdOutput,
                        errOutput,
                ))

                // Create structured error with context
                return "", utils.NewGitError(
                        "Git command failed",
                        err,
                        map[string]interface{}{
                                "directory": dir,
                                "command":   commandStr,
                                "stdout":    stdOutput,
                                "stderr":    errOutput,
                        },
                )
        }</span>

        <span class="cov8" title="1">utils.Debug("[GIT.EXEC.SUCCESS]: Command executed successfully in directory '" + dir + "': " + commandStr)
        return stdout.String(), nil</span>
}

var changedFilesCache = make(map[string]string)
var cacheMu sync.RWMutex

func GetAllChangedFiles(dir string) ([]string, error) <span class="cov8" title="1">{
        output, err := RunGitCmd(dir, nil, "status", "--porcelain")
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[GIT.STATUS.FAIL]: Failed to get git status: " + err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(output) == "" </span><span class="cov0" title="0">{
                utils.Debug("[GIT.STATUS]: No changed files detected in directory: " + dir)
                return nil, nil
        }</span>

        <span class="cov8" title="1">var changedFiles []string
        lines := strings.Split(output, "\n")

        cacheMu.Lock()
        defer cacheMu.Unlock()

        for _, line := range lines </span><span class="cov8" title="1">{
                if len(line) &lt; 4 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">status := strings.TrimSpace(line[:2])
                relativePath := strings.TrimSpace(line[3:])
                absolutePath := filepath.Join(dir, relativePath)
                abs, err := filepath.Abs(absolutePath)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("[GIT.PATH.FAIL]: Failed to resolve absolute path for '" + relativePath + "': " + err.Error())
                        continue</span>
                }

                <span class="cov8" title="1">changedFilesCache[abs] = status

                if strings.HasPrefix(status, "D") </span><span class="cov0" title="0">{
                        utils.Debug("[GIT.FILE.DELETED]: File marked as deleted: " + abs)
                        changedFiles = append(changedFiles, abs)
                        continue</span>
                }

                <span class="cov8" title="1">info, err := os.Stat(abs)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                utils.Debug("[GIT.FILE.MISSING]: File does not exist (possibly deleted): " + abs)
                                changedFiles = append(changedFiles, abs)
                                continue</span>
                        }
                        <span class="cov0" title="0">utils.Error("[GIT.STAT.FAIL]: Failed to stat path '" + abs + "': " + err.Error())
                        return nil, err</span>
                }

                <span class="cov8" title="1">if info.IsDir() &amp;&amp; status == "??" </span><span class="cov0" title="0">{
                        innerOutput, err := RunGitCmd(dir, nil, "ls-files", "--others", "--exclude-standard", relativePath)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[GIT.UNTRACKED.FAIL]: Failed to list files in untracked dir '" + relativePath + "': " + err.Error())
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">for _, inner := range strings.Split(innerOutput, "\n") </span><span class="cov0" title="0">{
                                if strings.TrimSpace(inner) == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">fullPath := filepath.Join(dir, inner)
                                absInner, err := filepath.Abs(fullPath)
                                if err == nil </span><span class="cov0" title="0">{
                                        changedFiles = append(changedFiles, absInner)
                                        changedFilesCache[absInner] = "??"
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        changedFiles = append(changedFiles, abs)
                }</span>
        }

        <span class="cov8" title="1">utils.Debug("[GIT.CHANGED.FILES]: " + strings.Join(changedFiles, ", "))
        return changedFiles, nil</span>
}

func GenCommitMessage(files []string, dir string) (string, error) <span class="cov0" title="0">{
        contextData := make(map[string]map[string]string)

        apiKey := config.Get("GEMINI_API_KEY")
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = os.Getenv("GEMINI_API_KEY")
                if apiKey == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("Gemini API key not found in config or env")
                }</span>
        }

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                var fileType, diffOutput string

                cacheMu.RLock()
                status, cached := changedFilesCache[file]
                cacheMu.RUnlock()

                if cached &amp;&amp; strings.HasPrefix(status, "D") </span><span class="cov0" title="0">{
                        fileType = "deleted"
                        contextData[file] = map[string]string{
                                "type": fileType,
                                "diff": "file deleted",
                        }
                        utils.Debug("[GIT.COMMIT.MSG]: File marked as deleted: '" + file + "'")
                        continue</span>
                }

                <span class="cov0" title="0">diffOutput, err := RunGitCmd(dir, nil, "diff", "--", file)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error(fmt.Sprintf("[GIT.DIFF.FAIL]: Error running git diff for '%s': %s", file, err.Error()))
                        return "", err
                }</span>

                <span class="cov0" title="0">if strings.TrimSpace(diffOutput) == "" </span><span class="cov0" title="0">{
                        diffOutput, err = RunGitCmd(dir, nil, "diff", "--cached", "--", file)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error(fmt.Sprintf("[GIT.DIFF.FAIL]: Error running git diff --cached for '%s': %s", file, err.Error()))
                                return "", err
                        }</span>
                }

                <span class="cov0" title="0">if strings.TrimSpace(diffOutput) == "" </span><span class="cov0" title="0">{
                        contentBytes, err := os.ReadFile(file)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error(fmt.Sprintf("[GIT.FILE.READ.FAIL]: Error reading new file '%s': %s", file, err.Error()))
                                return "", err
                        }</span>
                        <span class="cov0" title="0">diffOutput = string(contentBytes)
                        fileType = "new"</span>
                } else<span class="cov0" title="0"> {
                        fileType = "updated"
                }</span>

                <span class="cov0" title="0">contextData[file] = map[string]string{
                        "type": fileType,
                        "diff": diffOutput,
                }

                utils.Debug("[GIT.COMMIT.MSG]: Processed file '" + file + "' as " + fileType)</span>
        }

        <span class="cov0" title="0">message, err := utils.SendToGemini(contextData, apiKey.(string))
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[GEMINI.FAIL]: Error generating group commit message: " + err.Error())
                return "", err
        }</span>

        <span class="cov0" title="0">return message, nil</span>
}

func BatchProcessGetMessages(allChangedFiles []string, rootFolder string) error <span class="cov0" title="0">{
        utils.Debug("[GIT.BATCH]: Starting batch processing of commit messages")
        var fileWg sync.WaitGroup
        var fileErrors []error
        fileMu := sync.Mutex{}

        for _, file := range allChangedFiles </span><span class="cov0" title="0">{
                fileWg.Add(1)
                go func(file string) </span><span class="cov0" title="0">{
                        defer fileWg.Done()

                        utils.Debug("[GIT.BATCH]: Processing file: " + file)
                        message, err := GenCommitMessage([]string{file}, rootFolder) // &lt;-- wrapped in slice
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[GIT.BATCH.FAIL]: Failed to generate commit message for file: " + file + " - " + err.Error())
                                fileMu.Lock()
                                fileErrors = append(fileErrors, err)
                                fileMu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">utils.Debug("[GIT.BATCH.SUCCESS]: Generated commit message for file: " + file + " - " + message)
                        output.Set(file, rootFolder, message)</span>
                }(file)
        }

        <span class="cov0" title="0">fileWg.Wait()

        if len(fileErrors) &gt; 0 </span><span class="cov0" title="0">{
                utils.Error("[GIT.BATCH.FAIL]: Batch processing completed with errors")
                return fmt.Errorf("one or more errors occurred while preparing commit messages")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func CommitBatch(rootFolder output.Folder, env ...[]string) error <span class="cov0" title="0">{
        commitMessagesList := rootFolder.Files
        if len(commitMessagesList) == 0 </span><span class="cov0" title="0">{
                utils.Debug("[GIT.COMMIT]: No commit messages found for root folder: " + rootFolder.Name)
                return utils.NewValidationError(
                        "No commit messages found for root folder",
                        nil,
                        map[string]interface{}{
                                "folderName": rootFolder.Name,
                        },
                )
        }</span>

        <span class="cov0" title="0">utils.Debug("[GIT.COMMIT]: Starting batch commit in folder: " + rootFolder.Name)
        utils.Debug("[GIT.COMMIT]: Total files to commit: " + fmt.Sprint(len(commitMessagesList)))

        // Convert environment slice to map
        envMap := make(map[string]string)
        if len(env) &gt; 0 </span><span class="cov0" title="0">{
                for _, pair := range env[0] </span><span class="cov0" title="0">{
                        parts := strings.SplitN(pair, "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                envMap[parts[0]] = parts[1]
                        }</span>
                }
        }

        // Group files by commit message for efficiency
        <span class="cov0" title="0">messageToFiles := make(map[string][]string)
        for _, entry := range commitMessagesList </span><span class="cov0" title="0">{
                utils.Debug("[GIT.COMMIT]: Staging file for grouping: " + entry.Name + " with message: " + entry.Message)
                messageToFiles[entry.Message] = append(messageToFiles[entry.Message], entry.Name)
        }</span>

        // Use a rate limiter to control concurrency
        <span class="cov0" title="0">const maxConcurrentOps = 3
        semaphore := make(chan struct{}, maxConcurrentOps)
        var wg sync.WaitGroup
        var errMu sync.Mutex
        var commitErrs []error

        // Stage files concurrently with rate limiting
        for message, files := range messageToFiles </span><span class="cov0" title="0">{
                // Stage all files for a single commit first
                for _, file := range files </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go func(file string) </span><span class="cov0" title="0">{
                                defer wg.Done()

                                // Acquire semaphore slot (blocking if maxConcurrentOps is reached)
                                semaphore &lt;- struct{}{}
                                defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>()

                                <span class="cov0" title="0">utils.Debug("[GIT.COMMIT]: Adding file to commit: " + file)
                                if _, err := RunGitCmdWithTimeout(rootFolder.Name, envMap, 15*time.Second, "add", file); err != nil </span><span class="cov0" title="0">{
                                        utils.Error("[GIT.COMMIT.FAIL]: Failed to add file to commit: " + err.Error())
                                        errMu.Lock()
                                        commitErrs = append(commitErrs, utils.NewGitError(
                                                "Failed to stage file",
                                                err,
                                                map[string]interface{}{
                                                        "file":   file,
                                                        "folder": rootFolder.Name,
                                                },
                                        ))
                                        errMu.Unlock()
                                }</span>
                        }(file)
                }

                // Wait for all staging operations to complete
                <span class="cov0" title="0">wg.Wait()

                // If we have errors from staging, return early
                if len(commitErrs) &gt; 0 </span><span class="cov0" title="0">{
                        return utils.NewGitError(
                                "Failed to stage one or more files for commit",
                                fmt.Errorf("%d errors occurred during staging", len(commitErrs)),
                                map[string]interface{}{
                                        "folder": rootFolder.Name,
                                        "errors": commitErrs,
                                },
                        )
                }</span>

                // Perform the actual commit
                <span class="cov0" title="0">utils.Debug(fmt.Sprintf("[GIT.COMMIT]: Committing %d file(s) with message: %s", len(files), message))
                if _, err := RunGitCmdWithTimeout(rootFolder.Name, envMap, 30*time.Second, "commit", "-m", message); err != nil </span><span class="cov0" title="0">{
                        utils.Error("[GIT.COMMIT.FAIL]: Failed to commit files with message '" + message + "': " + err.Error())
                        return utils.NewGitError(
                                "Failed to commit files",
                                err,
                                map[string]interface{}{
                                        "message":   message,
                                        "folder":    rootFolder.Name,
                                        "fileCount": len(files),
                                },
                        )
                }</span>
        }

        <span class="cov0" title="0">output.RemoveFolder(rootFolder.Name)
        utils.Info("[GIT.COMMIT.SUCCESS]: Batch commit completed successfully and folder removed: " + rootFolder.Name)
        return nil</span>
}

func PushBranch(rootFolderName string, branch string) error <span class="cov8" title="1">{
        if branch == "" </span><span class="cov0" title="0">{
                utils.Debug("[GIT.PUSH]: Branch name is empty, defaulting to 'main'")
                branch = "main"
        }</span>

        <span class="cov8" title="1">utils.Debug("[GIT.PUSH]: Pushing branch: " + branch + " in folder: " + rootFolderName)
        if _, err := RunGitCmd(rootFolderName, nil, "push", "origin", branch); err != nil </span><span class="cov8" title="1">{
                utils.Error("[GIT.PUSH.FAIL]: Failed to push branch: " + err.Error())
                return fmt.Errorf("failed to push branch: %s", err.Error())
        }</span>

        <span class="cov8" title="1">utils.Info("[GIT.PUSH.SUCCESS]: Branch pushed successfully")
        return nil</span>
}

func GetFileDiff(filePath string, rootFolder string) (string, error) <span class="cov0" title="0">{
        cmdStatus := exec.Command("git", "-C", rootFolder, "status", "--porcelain", "--untracked-files=all", "--", filePath)

        var statusOut bytes.Buffer
        cmdStatus.Stdout = &amp;statusOut
        cmdStatus.Stderr = &amp;statusOut

        err := cmdStatus.Run()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error checking status for file %s: %v", filePath, err)
        }</span>

        <span class="cov0" title="0">if statusOut.String() != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("New untracked file: %s", filePath), nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("git", "-C", rootFolder, "diff", "--", filePath)

        var out bytes.Buffer
        cmd.Stdout = &amp;out
        cmd.Stderr = &amp;out

        err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error getting diff for file %s: %v", filePath, err)
        }</span>

        <span class="cov0" title="0">return out.String(), nil</span>
}

func BatchProcessWithEmbeddings(allChangedFiles []string, rootFolder string, numClusters int) error <span class="cov0" title="0">{
        utils.Debug("[GIT.BATCH]: Starting batch processing with embeddings and clustering")

        var fileData []FileEmbedding
        var fileErrors []error
        var fileMu sync.Mutex

        for _, file := range allChangedFiles </span><span class="cov0" title="0">{
                diff, err := GetFileDiff(file, rootFolder)
                if err != nil || strings.TrimSpace(diff) == "" </span><span class="cov0" title="0">{
                        utils.Error("[GIT.BATCH]: Could not get diff for file: " + file)
                        continue</span>
                }

                <span class="cov0" title="0">embed, err := embeddings.GenerateEmbedding(diff)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("[GIT.BATCH]: Could not generate embedding for file: " + file)
                        fileMu.Lock()
                        fileErrors = append(fileErrors, err)
                        fileMu.Unlock()
                        continue</span>
                }

                <span class="cov0" title="0">fileData = append(fileData, FileEmbedding{
                        Path:      file,
                        Diff:      diff,
                        Embedding: embed,
                })</span>
        }

        <span class="cov0" title="0">if len(fileData) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no valid diffs or embeddings generated")
        }</span>

        <span class="cov0" title="0">utils.Debug(fmt.Sprintf("[GIT.BATCH]: Clustering %d files by embeddings", len(fileData)))

        vectors := make([][]float32, len(fileData))
        for i, f := range fileData </span><span class="cov0" title="0">{
                vectors[i] = f.Embedding
        }</span>

        <span class="cov0" title="0">labels, err := embeddings.KMeans(vectors, numClusters, 10)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("clustering failed: %v", err)
        }</span>

        <span class="cov0" title="0">groupMap := make(map[int][]FileEmbedding)
        for i, label := range labels </span><span class="cov0" title="0">{
                groupMap[label] = append(groupMap[label], fileData[i])
        }</span>

        <span class="cov0" title="0">type CommitGroup struct {
                Message string   `json:"message"`
                Files   []string `json:"files"`
        }

        var commitGroups []CommitGroup
        var commitMu sync.Mutex
        var fileWg sync.WaitGroup

        for label, group := range groupMap </span><span class="cov0" title="0">{
                fileWg.Add(1)
                go func(label int, group []FileEmbedding) </span><span class="cov0" title="0">{
                        defer fileWg.Done()

                        utils.Debug(fmt.Sprintf("[GIT.BATCH]: Generating commit message for group %d with %d files", label, len(group)))

                        var filePaths []string
                        for _, f := range group </span><span class="cov0" title="0">{
                                filePaths = append(filePaths, f.Path)
                        }</span>

                        <span class="cov0" title="0">message, err := GenCommitMessage(filePaths, rootFolder)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error(fmt.Sprintf("[GIT.BATCH]: Commit message generation failed for group %d - %s", label, err.Error()))
                                fileMu.Lock()
                                fileErrors = append(fileErrors, err)
                                fileMu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">commitMu.Lock()
                        commitGroups = append(commitGroups, CommitGroup{
                                Message: message,
                                Files:   filePaths,
                        })
                        commitMu.Unlock()

                        for _, f := range group </span><span class="cov0" title="0">{
                                utils.Debug("[GIT.BATCH.SUCCESS]: Generated commit message for file: " + f.Path + " - " + message)
                                output.Set(f.Path, rootFolder, message)
                        }</span>
                }(label, group)
        }

        <span class="cov0" title="0">fileWg.Wait()

        if len(fileErrors) &gt; 0 </span><span class="cov0" title="0">{
                utils.Error("[GIT.BATCH.FAIL]: Batch processing completed with errors")
                return fmt.Errorf("one or more errors occurred while preparing commit messages")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package git

import (
        "GitCury/output"
        "GitCury/utils"
        "fmt"
        "path/filepath"
        "sync"
        "time"
)

// ProgressCommitBatch is an enhanced version of CommitBatch that includes progress reporting
// and better resource management
func ProgressCommitBatch(rootFolder output.Folder, env ...[]string) error <span class="cov0" title="0">{
        commitMessagesList := rootFolder.Files
        if len(commitMessagesList) == 0 </span><span class="cov0" title="0">{
                utils.Debug("[GIT.COMMIT]: No commit messages found for root folder: " + rootFolder.Name)
                return utils.NewValidationError(
                        "No commit messages found for root folder",
                        nil,
                        map[string]interface{}{
                                "folderName": rootFolder.Name,
                        },
                )
        }</span>

        // Create progress reporter for better user feedback
        <span class="cov0" title="0">progress := utils.NewProgressReporter(int64(len(commitMessagesList)), "Committing files in "+rootFolder.Name)
        progress.Start()
        defer progress.Done()

        // Track overall progress
        var progressCounter int64
        var progressMu sync.Mutex

        // Function to update progress safely
        updateProgress := func(count int64, message string) </span><span class="cov0" title="0">{
                progressMu.Lock()
                defer progressMu.Unlock()
                progressCounter += count
                progress.Update(progressCounter)
                if message != "" </span><span class="cov0" title="0">{
                        progress.UpdateMessage(message)
                }</span>
        }

        // Call original CommitBatch with progress hooks
        <span class="cov0" title="0">err := SafeGitOperation(rootFolder.Name, "CommitBatch", func() error </span><span class="cov0" title="0">{
                // Process each file with progress reporting
                for i, entry := range commitMessagesList </span><span class="cov0" title="0">{
                        shortFile := filepath.Base(entry.Name)
                        updateProgress(1, fmt.Sprintf("Processing %d/%d: %s", i+1, len(commitMessagesList), shortFile))

                        // Add artificial delay to make progress visible
                        time.Sleep(50 * time.Millisecond)
                }</span>

                // Let the original function do the actual work
                <span class="cov0" title="0">return CommitBatch(rootFolder, env...)</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                progress.UpdateMessage("Commit failed: " + err.Error())
                return err
        }</span>

        <span class="cov0" title="0">progress.UpdateMessage("Commit completed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package git

import (
        "GitCury/utils"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// GitOperationResult represents the result of a git operation with recovery information
type GitOperationResult struct {
        Success      bool
        Error        error
        RecoveryPath string
        Message      string
}

// CheckRepositoryHealth checks if a git repository is in a healthy state
// and returns any issues found
func CheckRepositoryHealth(dir string) error <span class="cov8" title="1">{
        // Check if directory exists
        if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return utils.NewValidationError(
                        "Directory does not exist",
                        err,
                        map[string]interface{}{
                                "directory": dir,
                        },
                )
        }</span>

        // Check if this is a git repository
        <span class="cov8" title="1">_, err := RunGitCmdWithTimeout(dir, nil, 5*time.Second, "rev-parse", "--is-inside-work-tree")
        if err != nil </span><span class="cov8" title="1">{
                return utils.NewGitError(
                        "Not a git repository",
                        err,
                        map[string]interface{}{
                                "directory":  dir,
                                "suggestion": "Initialize a git repository with 'git init'",
                        },
                )
        }</span>

        // Check for uncommitted changes that might cause conflicts
        <span class="cov8" title="1">output, err := RunGitCmdWithTimeout(dir, nil, 5*time.Second, "status", "--porcelain")
        if err != nil </span><span class="cov0" title="0">{
                return utils.NewGitError(
                        "Failed to get repository status",
                        err,
                        map[string]interface{}{
                                "directory": dir,
                        },
                )
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(output) != "" </span><span class="cov0" title="0">{
                // There are uncommitted changes, but this is not an error
                utils.Debug("[GIT.HEALTH]: Repository has uncommitted changes: " + dir)
        }</span>

        // Check if the git index is locked
        <span class="cov8" title="1">indexLockPath := filepath.Join(dir, ".git", "index.lock")
        if _, err := os.Stat(indexLockPath); err == nil </span><span class="cov0" title="0">{
                // Index is locked, this might indicate a problem
                lockFileInfo, err := os.Stat(indexLockPath)
                if err == nil </span><span class="cov0" title="0">{
                        lockAge := time.Since(lockFileInfo.ModTime())

                        // If lock file is older than 10 minutes, it's likely stale
                        if lockAge &gt; 10*time.Minute </span><span class="cov0" title="0">{
                                utils.Warning("[GIT.HEALTH]: Found stale index.lock file (age: " + lockAge.String() + ")")
                                return utils.NewGitError(
                                        "Repository index is locked (stale lock)",
                                        nil,
                                        map[string]interface{}{
                                                "directory":  dir,
                                                "lockFile":   indexLockPath,
                                                "lockAge":    lockAge.String(),
                                                "suggestion": "Remove the lock file with 'rm " + indexLockPath + "'",
                                        },
                                )
                        }</span>

                        <span class="cov0" title="0">return utils.NewGitError(
                                "Repository index is locked",
                                nil,
                                map[string]interface{}{
                                        "directory":  dir,
                                        "lockFile":   indexLockPath,
                                        "lockAge":    lockAge.String(),
                                        "suggestion": "Wait for the current git operation to complete or remove the lock file",
                                },
                        )</span>
                }
        }

        // Check if we can access the git config
        <span class="cov8" title="1">_, err = RunGitCmdWithTimeout(dir, nil, 5*time.Second, "config", "--local", "--list")
        if err != nil </span><span class="cov0" title="0">{
                return utils.NewGitError(
                        "Failed to access git config",
                        err,
                        map[string]interface{}{
                                "directory":  dir,
                                "suggestion": "The .git directory might be corrupted, try reinitializing the repository",
                        },
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RecoverFromGitError attempts to recover from common git errors
func RecoverFromGitError(dir string, err error) GitOperationResult <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return GitOperationResult{
                        Success: true,
                        Message: "No error to recover from",
                }
        }</span>

        <span class="cov8" title="1">errMsg := err.Error()

        // Check for index.lock issues
        if strings.Contains(errMsg, "index.lock") </span><span class="cov0" title="0">{
                indexLockPath := filepath.Join(dir, ".git", "index.lock")
                if _, statErr := os.Stat(indexLockPath); statErr == nil </span><span class="cov0" title="0">{
                        // Index lock exists, try to remove it
                        utils.Warning("[GIT.RECOVERY]: Found index.lock file, attempting to remove it")

                        if rmErr := os.Remove(indexLockPath); rmErr == nil </span><span class="cov0" title="0">{
                                return GitOperationResult{
                                        Success:      true,
                                        RecoveryPath: "index_lock_removed",
                                        Message:      "Removed stale index.lock file",
                                }
                        }</span> else<span class="cov0" title="0"> {
                                return GitOperationResult{
                                        Success:      false,
                                        Error:        rmErr,
                                        RecoveryPath: "index_lock_removal_failed",
                                        Message:      "Failed to remove stale index.lock file",
                                }
                        }</span>
                }
        }

        // Check for conflicts
        <span class="cov8" title="1">if strings.Contains(errMsg, "conflict") || strings.Contains(errMsg, "CONFLICT") </span><span class="cov0" title="0">{
                utils.Warning("[GIT.RECOVERY]: Detected conflict in git operation")
                return GitOperationResult{
                        Success:      false,
                        Error:        err,
                        RecoveryPath: "conflict_detected",
                        Message:      "Git operation failed due to conflicts. Manual resolution required.",
                }
        }</span>

        // Check for permission issues
        <span class="cov8" title="1">if strings.Contains(errMsg, "Permission denied") </span><span class="cov0" title="0">{
                utils.Warning("[GIT.RECOVERY]: Detected permission issue in git operation")
                return GitOperationResult{
                        Success:      false,
                        Error:        err,
                        RecoveryPath: "permission_denied",
                        Message:      "Git operation failed due to permission issues. Check file permissions.",
                }
        }</span>

        // No specific recovery path identified
        <span class="cov8" title="1">return GitOperationResult{
                Success:      false,
                Error:        err,
                RecoveryPath: "unknown_error",
                Message:      "No automatic recovery available for this git error",
        }</span>
}

// SafeGitOperation executes a git operation with built-in recovery mechanisms
func SafeGitOperation(dir string, operation string, fn func() error) error <span class="cov0" title="0">{
        // First check repository health
        if err := CheckRepositoryHealth(dir); err != nil </span><span class="cov0" title="0">{
                utils.Warning("[GIT.SAFE]: Repository health check failed: " + err.Error())

                // If the directory doesn't exist, no recovery is possible
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Try to recover from repository issues
                <span class="cov0" title="0">result := RecoverFromGitError(dir, err)
                if !result.Success </span><span class="cov0" title="0">{
                        utils.Error("[GIT.SAFE]: Failed to recover from repository issue: " + result.Message)
                        return utils.NewGitError(
                                "Repository is in an unhealthy state",
                                err,
                                map[string]interface{}{
                                        "directory":    dir,
                                        "operation":    operation,
                                        "recoveryPath": result.RecoveryPath,
                                        "message":      result.Message,
                                },
                        )
                }</span>

                <span class="cov0" title="0">utils.Info("[GIT.SAFE]: Successfully recovered from repository issue: " + result.Message)</span>
        }

        // Execute the git operation
        <span class="cov0" title="0">err := fn()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[GIT.SAFE]: Git operation failed: " + err.Error())

                // Try to recover from the error
                result := RecoverFromGitError(dir, err)
                if !result.Success </span><span class="cov0" title="0">{
                        return utils.NewGitError(
                                fmt.Sprintf("Git operation '%s' failed", operation),
                                err,
                                map[string]interface{}{
                                        "directory":    dir,
                                        "operation":    operation,
                                        "recoveryPath": result.RecoveryPath,
                                        "message":      result.Message,
                                },
                        )
                }</span>

                <span class="cov0" title="0">utils.Info("[GIT.SAFE]: Successfully recovered from git error: " + result.Message)

                // Retry the operation after recovery
                retryErr := fn()
                if retryErr != nil </span><span class="cov0" title="0">{
                        return utils.NewGitError(
                                fmt.Sprintf("Git operation '%s' failed even after recovery", operation),
                                retryErr,
                                map[string]interface{}{
                                        "directory":    dir,
                                        "operation":    operation,
                                        "recoveryPath": result.RecoveryPath,
                                        "message":      "Recovery was successful but operation still failed on retry",
                                },
                        )
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package output

import (
        "GitCury/config"
        "GitCury/utils"
        "encoding/json"
        "os"
        "sync"
)

type FileEntry struct {
        Name    string `json:"name"`
        Message string `json:"message"`
}

type Folder struct {
        Name  string      `json:"name"`
        Files []FileEntry `json:"files"`
}

type OutputData struct {
        Folders []Folder `json:"folders"`
}

var (
        outputData = OutputData{}
        mu         sync.RWMutex
)

func init() <span class="cov8" title="1">{
        LoadOutput()
}</span>

func LoadOutput() <span class="cov8" title="1">{
        outputFilePath, ok := config.Get("output_file_path").(string)
        if !ok || outputFilePath == "" </span><span class="cov0" title="0">{
                outputFilePath = os.Getenv("HOME") + "/.gitcury/output.json"
        }</span>

        <span class="cov8" title="1">file, err := os.Open(outputFilePath)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                utils.Debug("[" + config.Aliases.Output + "]: No existing output file found. Initializing fresh output.")
                return
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: 🚨 Error loading output file: " + err.Error())
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;outputData); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: 🚨 Error decoding output file: " + err.Error())
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.Output + "]: Loaded output data successfully.")</span>
}

func Set(file, rootFolder string, commitMessage string) <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()

        utils.Debug("[" + config.Aliases.Output + "]: Setting commit message for file: " + file + " in folder: " + rootFolder)
        folder := findOrCreateFolder(rootFolder)

        updated := false
        for i, entry := range folder.Files </span><span class="cov8" title="1">{
                if entry.Name == file </span><span class="cov8" title="1">{
                        folder.Files[i].Message = commitMessage
                        updated = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !updated </span><span class="cov8" title="1">{
                folder.Files = append(folder.Files, FileEntry{Name: file, Message: commitMessage})
        }</span>

        <span class="cov8" title="1">utils.Debug("[" + config.Aliases.Output + "]: Commit message set for file: " + file + " in folder: " + rootFolder)</span>
}

func Get(file string, rootFolder string) string <span class="cov8" title="1">{
        mu.RLock()
        defer mu.RUnlock()

        folder := findFolder(rootFolder)
        if folder == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">for _, entry := range folder.Files </span><span class="cov8" title="1">{
                if entry.Name == file </span><span class="cov8" title="1">{
                        return entry.Message
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func GetFolder(rootFolder string) Folder <span class="cov8" title="1">{
        mu.RLock()
        defer mu.RUnlock()

        folder := findFolder(rootFolder)
        if folder != nil </span><span class="cov8" title="1">{
                return *folder
        }</span>
        <span class="cov8" title="1">return Folder{Name: rootFolder, Files: []FileEntry{}}</span>
}

func GetAll() OutputData <span class="cov8" title="1">{
        mu.RLock()
        defer mu.RUnlock()

        copy := OutputData{Folders: make([]Folder, len(outputData.Folders))}
        for i, folder := range outputData.Folders </span><span class="cov8" title="1">{
                copy.Folders[i] = Folder{
                        Name:  folder.Name,
                        Files: append([]FileEntry{}, folder.Files...),
                }
        }</span>
        <span class="cov8" title="1">return copy</span>
}

func Delete(file string, rootFolder string) <span class="cov0" title="0">{
        mu.Lock()
        defer mu.Unlock()

        folder := findFolder(rootFolder)
        if folder == nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: ⚠️ Folder not found: " + rootFolder)
                return
        }</span>

        <span class="cov0" title="0">for i, entry := range folder.Files </span><span class="cov0" title="0">{
                if entry.Name == file </span><span class="cov0" title="0">{
                        folder.Files = append(folder.Files[:i], folder.Files[i+1:]...)
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(folder.Files) == 0 </span><span class="cov0" title="0">{
                RemoveFolder(rootFolder)
        }</span>

        <span class="cov0" title="0">SaveToFile()
        utils.Debug("[" + config.Aliases.Output + "]: File deleted and output saved.")</span>
}

func Clear() <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()
        outputData = OutputData{}

        outputFilePath, ok := config.Get("output_file_path").(string)
        if !ok || outputFilePath == "" </span><span class="cov0" title="0">{
                outputFilePath = os.Getenv("HOME") + "/.gitcury/output.json"
        }</span>

        <span class="cov8" title="1">if err := os.Remove(outputFilePath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: 🚨 Error deleting output file: " + err.Error())
        }</span> else<span class="cov8" title="1"> {
                utils.Debug("[" + config.Aliases.Output + "]: Output file cleared successfully.")
        }</span>
}

func SaveToFile() <span class="cov8" title="1">{
        utils.Debug("[" + config.Aliases.Output + "]: Saving output data to file...")
        mu.RLock()
        defer mu.RUnlock()

        outputFilePath, ok := config.Get("output_file_path").(string)
        if !ok || outputFilePath == "" </span><span class="cov0" title="0">{
                outputFilePath = os.Getenv("HOME") + "/.gitcury/output.json"
                config.Set("output_file_path", outputFilePath)
        }</span>

        <span class="cov8" title="1">outputFile, err := os.OpenFile(outputFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: 🚨 Error saving output file: " + err.Error())
                return
        }</span>
        <span class="cov8" title="1">defer outputFile.Close()

        encoder := json.NewEncoder(outputFile)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(outputData); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: 🚨 Error encoding output data: " + err.Error())
        }</span>

        <span class="cov8" title="1">utils.Debug("[" + config.Aliases.Output + "]: Output data saved successfully to: " + outputFilePath)</span>
}

func findFolder(name string) *Folder <span class="cov8" title="1">{
        for i := range outputData.Folders </span><span class="cov8" title="1">{
                if outputData.Folders[i].Name == name </span><span class="cov8" title="1">{
                        return &amp;outputData.Folders[i]
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func findOrCreateFolder(name string) *Folder <span class="cov8" title="1">{
        folder := findFolder(name)
        if folder == nil </span><span class="cov8" title="1">{
                outputData.Folders = append(outputData.Folders, Folder{Name: name, Files: []FileEntry{}})
                return &amp;outputData.Folders[len(outputData.Folders)-1]
        }</span>
        <span class="cov8" title="1">return folder</span>
}

func RemoveFolder(name string) <span class="cov8" title="1">{
        for i, folder := range outputData.Folders </span><span class="cov8" title="1">{
                if folder.Name == name </span><span class="cov8" title="1">{
                        outputData.Folders = append(outputData.Folders[:i], outputData.Folders[i+1:]...)
                        break</span>
                }
        }

        <span class="cov8" title="1">SaveToFile()
        utils.Debug("[" + config.Aliases.Output + "]: Folder removed and output saved.")</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package mocks provides mock implementations for testing
package mocks

import (
        "GitCury/interfaces"
        "GitCury/output"
        "errors"
        "sync"
        "time"
)

// MockGitRunner is a mock implementation of git command runner for testing
type MockGitRunner struct {
        Commands          []string
        Directories       []string
        EnvVars           []map[string]string
        ReturnValueMap    map[string]string
        ReturnErrorMap    map[string]error
        DirReturnValueMap map[string]map[string]string // Map of directory to command to response
        DirReturnErrorMap map[string]map[string]error  // Map of directory to command to error
        CallCount         map[string]int
        mu                sync.Mutex
        DefaultResponse   string
        DefaultError      error
}

// Ensure MockGitRunner implements GitRunner interface
var _ interfaces.GitRunner = &amp;MockGitRunner{}

// NewMockGitRunner creates a new mock git runner
func NewMockGitRunner() *MockGitRunner <span class="cov8" title="1">{
        return &amp;MockGitRunner{
                Commands:          make([]string, 0),
                Directories:       make([]string, 0),
                EnvVars:           make([]map[string]string, 0),
                ReturnValueMap:    make(map[string]string),
                ReturnErrorMap:    make(map[string]error),
                DirReturnValueMap: make(map[string]map[string]string),
                DirReturnErrorMap: make(map[string]map[string]error),
                CallCount:         make(map[string]int),
                DefaultResponse:   "",
                DefaultError:      nil,
        }
}</span>

// RunGitCommand records the command and returns predefined response
func (m *MockGitRunner) RunGitCommand(dir string, envVars map[string]string, args ...string) (string, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Build command string for lookup
        cmd := args[0]
        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                cmd = args[0] + " " + args[1]
        }</span>

        // Record this call
        <span class="cov8" title="1">m.Commands = append(m.Commands, cmd)
        m.Directories = append(m.Directories, dir)
        m.EnvVars = append(m.EnvVars, envVars)

        // Increment call count
        m.CallCount[cmd] = m.CallCount[cmd] + 1

        // Check if we have a directory-specific response
        if dirMap, ok := m.DirReturnValueMap[dir]; ok </span><span class="cov0" title="0">{
                if response, ok := dirMap[cmd]; ok </span><span class="cov0" title="0">{
                        if dirErrMap, ok := m.DirReturnErrorMap[dir]; ok </span><span class="cov0" title="0">{
                                if err, ok := dirErrMap[cmd]; ok </span><span class="cov0" title="0">{
                                        return response, err
                                }</span>
                        }
                        <span class="cov0" title="0">return response, nil</span>
                }
        }

        // Check if we have a predefined response for this command
        <span class="cov8" title="1">if response, ok := m.ReturnValueMap[cmd]; ok </span><span class="cov0" title="0">{
                if err, ok := m.ReturnErrorMap[cmd]; ok </span><span class="cov0" title="0">{
                        return response, err
                }</span>
                <span class="cov0" title="0">return response, nil</span>
        }

        <span class="cov8" title="1">return m.DefaultResponse, m.DefaultError</span>
}

// RunGitCmd implements the GitRunner interface
func (m *MockGitRunner) RunGitCmd(dir string, envVars map[string]string, args ...string) (string, error) <span class="cov8" title="1">{
        return m.RunGitCommand(dir, envVars, args...)
}</span>

// RunGitCmdWithTimeout implements the GitRunner interface
func (m *MockGitRunner) RunGitCmdWithTimeout(dir string, envVars map[string]string, timeout time.Duration, args ...string) (string, error) <span class="cov0" title="0">{
        return m.RunGitCommand(dir, envVars, args...)
}</span>

// CommitBatch implements the GitRunner interface
func (m *MockGitRunner) CommitBatch(folder output.Folder, env ...[]string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        // Record the commit batch operation
        cmd := "commit-batch-" + folder.Name
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Check if we have a predefined error for this operation
        if err, ok := m.ReturnErrorMap[cmd]; ok </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return m.DefaultError</span>
}

// GetChangedFiles implements the GitRunner interface
func (m *MockGitRunner) GetChangedFiles(rootFolders []string, maxConcurrency int, env ...[]string) ([]output.Folder, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "get-changed-files"
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Return empty folders by default
        return []output.Folder{}, m.DefaultError
}</span>

// Status implements the GitRunner interface
func (m *MockGitRunner) Status(rootPaths []string) ([]output.Folder, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "status"
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Return empty folders by default
        return []output.Folder{}, m.DefaultError
}</span>

// ProcessOneFile implements the GitRunner interface
func (m *MockGitRunner) ProcessOneFile(filePath, commitMessage string, env ...[]string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "process-one-file-" + filePath
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Check if we have a predefined error for this operation
        if err, ok := m.ReturnErrorMap[cmd]; ok </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return m.DefaultError</span>
}

// GetDiff implements the GitRunner interface
func (m *MockGitRunner) GetDiff(filePath string, env ...[]string) (string, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "diff-" + filePath
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Check if we have a predefined response for this file
        if response, ok := m.ReturnValueMap[cmd]; ok </span><span class="cov0" title="0">{
                if err, ok := m.ReturnErrorMap[cmd]; ok </span><span class="cov0" title="0">{
                        return response, err
                }</span>
                <span class="cov0" title="0">return response, nil</span>
        }
        
        <span class="cov0" title="0">return m.DefaultResponse, m.DefaultError</span>
}

// IsGitRepository implements the GitRunner interface
func (m *MockGitRunner) IsGitRepository(path string) bool <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "is-git-repo-" + path
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Check if we have a predefined response
        if response, ok := m.ReturnValueMap[cmd]; ok </span><span class="cov0" title="0">{
                return response == "true"
        }</span>
        
        // Default to true for testing
        <span class="cov0" title="0">return true</span>
}

// GetGitConfigValue implements the GitRunner interface
func (m *MockGitRunner) GetGitConfigValue(key string, env ...[]string) (string, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "config-get-" + key
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Check if we have a predefined response
        if response, ok := m.ReturnValueMap[cmd]; ok </span><span class="cov0" title="0">{
                if err, ok := m.ReturnErrorMap[cmd]; ok </span><span class="cov0" title="0">{
                        return response, err
                }</span>
                <span class="cov0" title="0">return response, nil</span>
        }
        
        <span class="cov0" title="0">return m.DefaultResponse, m.DefaultError</span>
}

// SetGitConfigValue implements the GitRunner interface
func (m *MockGitRunner) SetGitConfigValue(key, value string, env ...[]string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "config-set-" + key + "-" + value
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Check if we have a predefined error
        if err, ok := m.ReturnErrorMap[cmd]; ok </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return m.DefaultError</span>
}

// MockOutputManager mocks the output.go functionality
type MockOutputManager struct {
        Folders      map[string]output.Folder
        SavedToFile  bool
        ClearedCalls int
        mu           sync.Mutex
}

// Ensure MockOutputManager implements OutputManager interface
var _ interfaces.OutputManager = &amp;MockOutputManager{}

// NewMockOutputManager creates a new mock output manager
func NewMockOutputManager() *MockOutputManager <span class="cov8" title="1">{
        return &amp;MockOutputManager{
                Folders:      make(map[string]output.Folder),
                SavedToFile:  false,
                ClearedCalls: 0,
        }
}</span>

// Set mocks output.Set
func (m *MockOutputManager) Set(file, rootFolder, commitMessage string) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        folder, ok := m.Folders[rootFolder]
        if !ok </span><span class="cov8" title="1">{
                folder = output.Folder{
                        Name:  rootFolder,
                        Files: []output.FileEntry{},
                }
        }</span>

        <span class="cov8" title="1">updated := false
        for i, entry := range folder.Files </span><span class="cov0" title="0">{
                if entry.Name == file </span><span class="cov0" title="0">{
                        folder.Files[i].Message = commitMessage
                        updated = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !updated </span><span class="cov8" title="1">{
                folder.Files = append(folder.Files, output.FileEntry{
                        Name:    file,
                        Message: commitMessage,
                })
        }</span>

        <span class="cov8" title="1">m.Folders[rootFolder] = folder</span>
}

// Get mocks output.Get
func (m *MockOutputManager) Get(file, rootFolder string) string <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        folder, ok := m.Folders[rootFolder]
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">for _, entry := range folder.Files </span><span class="cov8" title="1">{
                if entry.Name == file </span><span class="cov8" title="1">{
                        return entry.Message
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// GetFolder mocks output.GetFolder
func (m *MockOutputManager) GetFolder(rootFolder string) output.Folder <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if folder, ok := m.Folders[rootFolder]; ok </span><span class="cov0" title="0">{
                return folder
        }</span>

        <span class="cov0" title="0">return output.Folder{
                Name:  rootFolder,
                Files: []output.FileEntry{},
        }</span>
}

// GetAll mocks output.GetAll
func (m *MockOutputManager) GetAll() output.OutputData <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        folders := make([]output.Folder, 0, len(m.Folders))
        for _, folder := range m.Folders </span><span class="cov8" title="1">{
                folders = append(folders, folder)
        }</span>

        <span class="cov8" title="1">return output.OutputData{
                Folders: folders,
        }</span>
}

// RemoveFolder implements the OutputManager interface
func (m *MockOutputManager) RemoveFolder(name string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        delete(m.Folders, name)
}</span>

// Clear mocks output.Clear
func (m *MockOutputManager) Clear() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.Folders = make(map[string]output.Folder)
        m.ClearedCalls++
}</span>

// SaveToFile implements the OutputManager interface
func (m *MockOutputManager) SaveToFile() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.SavedToFile = true
}</span>

// MockConfig mocks the config functionality
type MockConfig struct {
        Settings map[string]interface{}
        mu       sync.Mutex
}

// NewMockConfig creates a new mock config
func NewMockConfig() *MockConfig <span class="cov0" title="0">{
        return &amp;MockConfig{
                Settings: make(map[string]interface{}),
        }
}</span>

// Get mocks config.Get
func (m *MockConfig) Get(key string) interface{} <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if value, ok := m.Settings[key]; ok </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Set mocks config.Set
func (m *MockConfig) Set(key string, value interface{}) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.Settings[key] = value
}</span>

// GetAll mocks config.GetAll
func (m *MockConfig) GetAll() map[string]interface{} <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        return m.Settings
}</span>

// MockAPIClient mocks API interactions for testing
type MockAPIClient struct {
        Responses       map[string]string
        Errors          map[string]error
        CallCount       map[string]int
        DefaultResponse string
        DefaultError    error
        mu              sync.Mutex
}

// NewMockAPIClient creates a new mock API client
func NewMockAPIClient() *MockAPIClient <span class="cov8" title="1">{
        return &amp;MockAPIClient{
                Responses:       make(map[string]string),
                Errors:          make(map[string]error),
                CallCount:       make(map[string]int),
                DefaultResponse: "",
                DefaultError:    nil,
        }
}</span>

// SendToGemini mocks utils.SendToGemini
func (m *MockAPIClient) SendToGemini(contextData map[string]map[string]string, apiKey string) (string, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Create a key from the context data
        var key string
        if len(contextData) &gt; 0 </span><span class="cov0" title="0">{
                for file := range contextData </span><span class="cov0" title="0">{
                        key = file
                        break</span>
                }
        }

        // Increment call count
        <span class="cov0" title="0">m.CallCount[key] = m.CallCount[key] + 1

        // Check if we have a predefined response for this key
        if response, ok := m.Responses[key]; ok </span><span class="cov0" title="0">{
                if err, ok := m.Errors[key]; ok </span><span class="cov0" title="0">{
                        return response, err
                }</span>
                <span class="cov0" title="0">return response, nil</span>
        }

        <span class="cov0" title="0">return m.DefaultResponse, m.DefaultError</span>
}

// MockFileSystem mocks filesystem operations for testing
type MockFileSystem struct {
        FileContent map[string]string
        FileInfo    map[string]bool // true = directory, false = file
        mu          sync.Mutex
}

// NewMockFileSystem creates a new mock filesystem
func NewMockFileSystem() *MockFileSystem <span class="cov0" title="0">{
        return &amp;MockFileSystem{
                FileContent: make(map[string]string),
                FileInfo:    make(map[string]bool),
        }
}</span>

// ReadFile mocks reading a file
func (m *MockFileSystem) ReadFile(path string) (string, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if content, ok := m.FileContent[path]; ok </span><span class="cov0" title="0">{
                return content, nil
        }</span>

        <span class="cov0" title="0">return "", errors.New("file not found: " + path)</span>
}

// WriteFile mocks writing to a file
func (m *MockFileSystem) WriteFile(path, content string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.FileContent[path] = content
        m.FileInfo[path] = false
        return nil
}</span>

// Exists mocks checking if a file exists
func (m *MockFileSystem) Exists(path string) (bool, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        _, ok := m.FileInfo[path]
        return ok, nil
}</span>

// IsDir mocks checking if a path is a directory
func (m *MockFileSystem) IsDir(path string) (bool, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if isDir, ok := m.FileInfo[path]; ok </span><span class="cov0" title="0">{
                return isDir, nil
        }</span>

        <span class="cov0" title="0">return false, errors.New("path not found: " + path)</span>
}

// CreateDir mocks creating a directory
func (m *MockFileSystem) CreateDir(path string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.FileInfo[path] = true
        return nil
}</span>

// MockProgressReporter provides a mock implementation of progress reporting
type MockProgressReporter struct {
        Reports      []string
        StartCalled  bool
        FinishCalled bool
        ErrorCount   int
        mu           sync.Mutex
}

// NewMockProgressReporter creates a new mock progress reporter
func NewMockProgressReporter() *MockProgressReporter <span class="cov0" title="0">{
        return &amp;MockProgressReporter{
                Reports:      make([]string, 0),
                StartCalled:  false,
                FinishCalled: false,
                ErrorCount:   0,
        }
}</span>

// Start mocks starting progress reporting
func (m *MockProgressReporter) Start(message string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.StartCalled = true
        m.Reports = append(m.Reports, "START: "+message)
}</span>

// Update mocks updating progress
func (m *MockProgressReporter) Update(message string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.Reports = append(m.Reports, "UPDATE: "+message)
}</span>

// Finish mocks finishing progress reporting
func (m *MockProgressReporter) Finish(message string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.FinishCalled = true
        m.Reports = append(m.Reports, "FINISH: "+message)
}</span>

// Error mocks reporting an error
func (m *MockProgressReporter) Error(message string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.ErrorCount++
        m.Reports = append(m.Reports, "ERROR: "+message)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package testreport provides utilities for generating test reports
package testreport

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"
)

// TestResult represents the result of a single test
type TestResult struct {
        Name      string        `json:"name"`
        Package   string        `json:"package"`
        Success   bool          `json:"success"`
        Duration  time.Duration `json:"duration"`
        ErrorMsg  string        `json:"errorMsg,omitempty"`
        SkipMsg   string        `json:"skipMsg,omitempty"`
        TimeStamp time.Time     `json:"timestamp"`
}

// TestReport represents a complete test report
type TestReport struct {
        TotalTests      int           `json:"totalTests"`
        PassedTests     int           `json:"passedTests"`
        FailedTests     int           `json:"failedTests"`
        SkippedTests    int           `json:"skippedTests"`
        TotalDuration   time.Duration `json:"totalDuration"`
        Coverage        float64       `json:"coverage,omitempty"`
        Results         []TestResult  `json:"results"`
        TimeStamp       time.Time     `json:"timestamp"`
        GitCuryVersion  string        `json:"gitCuryVersion"`
        GoVersion       string        `json:"goVersion"`
        OperatingSystem string        `json:"operatingSystem"`
}

// GenerateTestReport runs all tests and generates a comprehensive report
func GenerateTestReport(outputPath string, coverageEnabled bool) (*TestReport, error) <span class="cov0" title="0">{
        startTime := time.Now()
        
        // Initialize report
        report := &amp;TestReport{
                Results:   make([]TestResult, 0),
                TimeStamp: startTime,
        }
        
        // Get system information
        report.GoVersion = getGoVersion()
        report.OperatingSystem = getOS()
        report.GitCuryVersion = getGitCuryVersion()
        
        // Build test command
        args := []string{"test", "./..."}
        if coverageEnabled </span><span class="cov0" title="0">{
                args = append(args, "-cover")
        }</span>
        <span class="cov0" title="0">args = append(args, "-v", "-json")
        
        // Run tests with JSON output
        cmd := exec.Command("go", args...)
        cmd.Env = os.Environ()
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                // Don't return error here, we want to generate a report even if tests fail
                fmt.Printf("Warning: tests completed with error: %v\n", err)
        }</span>
        
        // Parse test output
        <span class="cov0" title="0">lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Try to parse as JSON
                <span class="cov0" title="0">var testEvent map[string]interface{}
                if err := json.Unmarshal([]byte(line), &amp;testEvent); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Check if this is a test result
                <span class="cov0" title="0">if eventType, ok := testEvent["Action"].(string); ok &amp;&amp; eventType == "run" </span><span class="cov0" title="0">{
                        // Process test result
                        testName, _ := testEvent["Test"].(string)
                        pkgName, _ := testEvent["Package"].(string)
                        
                        // Find corresponding pass/fail/skip event
                        result := findTestResult(lines, testName, pkgName)
                        if result != nil </span><span class="cov0" title="0">{
                                report.Results = append(report.Results, *result)
                        }</span>
                }
        }
        
        // Calculate statistics
        <span class="cov0" title="0">for _, result := range report.Results </span><span class="cov0" title="0">{
                report.TotalTests++
                if result.Success </span><span class="cov0" title="0">{
                        report.PassedTests++
                }</span> else<span class="cov0" title="0"> if result.SkipMsg != "" </span><span class="cov0" title="0">{
                        report.SkippedTests++
                }</span> else<span class="cov0" title="0"> {
                        report.FailedTests++
                }</span>
                <span class="cov0" title="0">report.TotalDuration += result.Duration</span>
        }
        
        // Get coverage if enabled
        <span class="cov0" title="0">if coverageEnabled </span><span class="cov0" title="0">{
                report.Coverage = extractCoverage(string(output))
        }</span>
        
        // Write report to file if path provided
        <span class="cov0" title="0">if outputPath != "" </span><span class="cov0" title="0">{
                if err := writeReport(report, outputPath); err != nil </span><span class="cov0" title="0">{
                        return report, fmt.Errorf("failed to write report: %w", err)
                }</span>
        }
        
        <span class="cov0" title="0">return report, nil</span>
}

// Helper to find test result from output
func findTestResult(lines []string, testName, pkgName string) *TestResult <span class="cov0" title="0">{
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">var testEvent map[string]interface{}
                if err := json.Unmarshal([]byte(line), &amp;testEvent); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">eventTestName, _ := testEvent["Test"].(string)
                eventPkgName, _ := testEvent["Package"].(string)
                eventType, _ := testEvent["Action"].(string)
                
                if eventTestName == testName &amp;&amp; eventPkgName == pkgName &amp;&amp; 
                   (eventType == "pass" || eventType == "fail" || eventType == "skip") </span><span class="cov0" title="0">{
                        
                        // Create test result
                        result := &amp;TestResult{
                                Name:      testName,
                                Package:   pkgName,
                                Success:   eventType == "pass",
                                TimeStamp: time.Now(),
                        }
                        
                        // Get duration
                        if duration, ok := testEvent["Elapsed"].(float64); ok </span><span class="cov0" title="0">{
                                result.Duration = time.Duration(duration * float64(time.Second))
                        }</span>
                        
                        // Get error message for failed tests
                        <span class="cov0" title="0">if eventType == "fail" </span><span class="cov0" title="0">{
                                if output, ok := testEvent["Output"].([]interface{}); ok &amp;&amp; len(output) &gt; 0 </span><span class="cov0" title="0">{
                                        var errorMsg strings.Builder
                                        for _, line := range output </span><span class="cov0" title="0">{
                                                errorMsg.WriteString(line.(string))
                                                errorMsg.WriteString("\n")
                                        }</span>
                                        <span class="cov0" title="0">result.ErrorMsg = errorMsg.String()</span>
                                }
                        }
                        
                        // Get skip message
                        <span class="cov0" title="0">if eventType == "skip" </span><span class="cov0" title="0">{
                                if output, ok := testEvent["Output"].([]interface{}); ok &amp;&amp; len(output) &gt; 0 </span><span class="cov0" title="0">{
                                        var skipMsg strings.Builder
                                        for _, line := range output </span><span class="cov0" title="0">{
                                                skipMsg.WriteString(line.(string))
                                                skipMsg.WriteString("\n")
                                        }</span>
                                        <span class="cov0" title="0">result.SkipMsg = skipMsg.String()</span>
                                }
                        }
                        
                        <span class="cov0" title="0">return result</span>
                }
        }
        
        <span class="cov0" title="0">return nil</span>
}

// Helper to extract coverage percentage
func extractCoverage(output string) float64 <span class="cov0" title="0">{
        // Look for coverage line in output
        lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, "coverage:") </span><span class="cov0" title="0">{
                        // Parse coverage percentage
                        parts := strings.Split(line, "coverage:")
                        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                coveragePart := strings.TrimSpace(parts[1])
                                coveragePct := strings.TrimSuffix(coveragePart, "%")
                                if coverage, err := parseFloat(coveragePct); err == nil </span><span class="cov0" title="0">{
                                        return coverage
                                }</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return 0.0</span>
}

// Helper to parse float
func parseFloat(s string) (float64, error) <span class="cov0" title="0">{
        var result float64
        _, err := fmt.Sscanf(s, "%f", &amp;result)
        return result, err
}</span>

// Helper to write report to file
func writeReport(report *TestReport, path string) error <span class="cov0" title="0">{
        // Create directory if needed
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Marshal to JSON
        <span class="cov0" title="0">data, err := json.MarshalIndent(report, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Write to file
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// Helper to get Go version
func getGoVersion() string <span class="cov0" title="0">{
        cmd := exec.Command("go", "version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(output))</span>
}

// Helper to get OS information
func getOS() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s", os.Getenv("GOOS"), os.Getenv("GOARCH"))
}</span>

// Helper to get GitCury version
func getGitCuryVersion() string <span class="cov0" title="0">{
        // This would ideally use the GitCury version from a version package
        return "development" // Replace with actual version
}</span>

// PrintReportSummary prints a summary of the test report
func PrintReportSummary(report *TestReport) <span class="cov0" title="0">{
        fmt.Println("=== GitCury Test Report Summary ===")
        fmt.Printf("Total Tests: %d\n", report.TotalTests)
        fmt.Printf("Passed: %d\n", report.PassedTests)
        fmt.Printf("Failed: %d\n", report.FailedTests)
        fmt.Printf("Skipped: %d\n", report.SkippedTests)
        fmt.Printf("Total Duration: %v\n", report.TotalDuration)
        
        if report.Coverage &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Code Coverage: %.2f%%\n", report.Coverage)
        }</span>
        
        <span class="cov0" title="0">fmt.Println("===============================")
        
        // Print failed tests if any
        if report.FailedTests &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Failed Tests:")
                for _, result := range report.Results </span><span class="cov0" title="0">{
                        if !result.Success &amp;&amp; result.SkipMsg == "" </span><span class="cov0" title="0">{
                                fmt.Printf("- %s.%s\n", result.Package, result.Name)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package testutils

import (
        "io/ioutil"
        "os"
        "os/exec"
        "path/filepath"
        "testing"
)

// CreateTempDir creates a temporary directory for testing
func CreateTempDir(t *testing.T) string <span class="cov8" title="1">{
        tempDir, err := ioutil.TempDir("", "gitcury-test-*")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp directory: %v", err)
        }</span>
        
        <span class="cov8" title="1">t.Cleanup(func() </span><span class="cov8" title="1">{
                os.RemoveAll(tempDir)
        }</span>)
        
        <span class="cov8" title="1">return tempDir</span>
}

// CreateTempFile creates a temporary file with the given content
func CreateTempFile(t *testing.T, dir, prefix, content string) string <span class="cov8" title="1">{
        file, err := ioutil.TempFile(dir, prefix)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp file: %v", err)
        }</span>
        
        <span class="cov8" title="1">if content != "" </span><span class="cov8" title="1">{
                if _, err := file.WriteString(content); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to write to temp file: %v", err)
                }</span>
        }
        
        <span class="cov8" title="1">if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to close temp file: %v", err)
        }</span>
        
        <span class="cov8" title="1">return file.Name()</span>
}

// SetupGitRepo initializes a git repository in the given directory
func SetupGitRepo(t *testing.T, dir string) <span class="cov8" title="1">{
        commands := [][]string{
                {"git", "init"},
                {"git", "config", "user.name", "Test User"},
                {"git", "config", "user.email", "test@example.com"},
        }
        
        for _, cmd := range commands </span><span class="cov8" title="1">{
                if err := runCommand(dir, cmd...); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to run command %v: %v", cmd, err)
                }</span>
        }
}

// AddAndCommitFile adds and commits a file to the repository
func AddAndCommitFile(t *testing.T, repoDir, filename, content, message string) <span class="cov8" title="1">{
        filePath := filepath.Join(repoDir, filename)
        
        // Create the file
        if err := os.WriteFile(filePath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to write file %s: %v", filename, err)
        }</span>
        
        <span class="cov8" title="1">commands := [][]string{
                {"git", "add", filename},
                {"git", "commit", "-m", message},
        }
        
        for _, cmd := range commands </span><span class="cov8" title="1">{
                if err := runCommand(repoDir, cmd...); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to run command %v: %v", cmd, err)
                }</span>
        }
}

// Helper to run commands
func runCommand(dir string, args ...string) error <span class="cov8" title="1">{
        cmd := exec.Command(args[0], args[1:]...)
        cmd.Dir = dir
        return cmd.Run()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package utils

import (
        "fmt"
        "strings"
)

// ErrorType represents the category of an error
type ErrorType string

const (
        // Error categories
        ConfigError     ErrorType = "CONFIG"
        GitError        ErrorType = "GIT"
        APIError        ErrorType = "API"
        ValidationError ErrorType = "VALIDATION"
        SystemError     ErrorType = "SYSTEM"
        UserError       ErrorType = "USER"
)

// StructuredError represents an error with additional context
type StructuredError struct {
        Type    ErrorType
        Message string
        Cause   error
        Context map[string]interface{}
}

// Error implements the error interface
func (e *StructuredError) Error() string <span class="cov8" title="1">{
        msg := fmt.Sprintf("[%s] %s", e.Type, e.Message)
        if e.Cause != nil </span><span class="cov8" title="1">{
                msg += fmt.Sprintf(": %s", e.Cause.Error())
        }</span>

        <span class="cov8" title="1">if len(e.Context) &gt; 0 </span><span class="cov8" title="1">{
                contextStrs := make([]string, 0, len(e.Context))
                for k, v := range e.Context </span><span class="cov8" title="1">{
                        contextStrs = append(contextStrs, fmt.Sprintf("%s=%v", k, v))
                }</span>
                <span class="cov8" title="1">msg += fmt.Sprintf(" [%s]", strings.Join(contextStrs, ", "))</span>
        }

        <span class="cov8" title="1">return msg</span>
}

// Unwrap implements the errors.Unwrap interface
func (e *StructuredError) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

// Helper functions to create different types of errors

// NewConfigError creates a new configuration error
func NewConfigError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov0" title="0">{
        return &amp;StructuredError{
                Type:    ConfigError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// NewGitError creates a new Git-related error
func NewGitError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov8" title="1">{
        return &amp;StructuredError{
                Type:    GitError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// NewAPIError creates a new API-related error
func NewAPIError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov0" title="0">{
        return &amp;StructuredError{
                Type:    APIError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// NewValidationError creates a new validation error
func NewValidationError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov0" title="0">{
        return &amp;StructuredError{
                Type:    ValidationError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// NewSystemError creates a new system-related error
func NewSystemError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov8" title="1">{
        return &amp;StructuredError{
                Type:    SystemError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// NewUserError creates a new user-related error
func NewUserError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov0" title="0">{
        return &amp;StructuredError{
                Type:    UserError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// ToUserFriendlyMessage converts an error to a user-friendly message with possible solution
func ToUserFriendlyMessage(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Try to cast to StructuredError
        <span class="cov8" title="1">if structured, ok := err.(*StructuredError); ok </span><span class="cov8" title="1">{
                switch structured.Type </span>{
                case ConfigError:<span class="cov0" title="0">
                        return fmt.Sprintf("Configuration issue: %s\nSuggestion: Check your configuration file or run 'gitcury setup' to reconfigure.", structured.Message)</span>
                case GitError:<span class="cov8" title="1">
                        return fmt.Sprintf("Git operation failed: %s\nSuggestion: Verify that Git is installed and that you have the necessary permissions.", structured.Message)</span>
                case APIError:<span class="cov0" title="0">
                        return fmt.Sprintf("API connection issue: %s\nSuggestion: Check your internet connection and API key configuration.", structured.Message)</span>
                case ValidationError:<span class="cov0" title="0">
                        return fmt.Sprintf("Invalid input: %s\nSuggestion: Review the command syntax and parameters.", structured.Message)</span>
                case SystemError:<span class="cov0" title="0">
                        return fmt.Sprintf("System error: %s\nSuggestion: Verify that you have the necessary permissions and system resources.", structured.Message)</span>
                case UserError:<span class="cov0" title="0">
                        return fmt.Sprintf("User error: %s", structured.Message)</span>
                default:<span class="cov0" title="0">
                        return fmt.Sprintf("Error: %s", err.Error())</span>
                }
        }

        // Default error handling
        <span class="cov8" title="1">return fmt.Sprintf("Error: %s", err.Error())</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
        "os"
)

func ListFiles(directory string) ([]string, error) <span class="cov0" title="0">{
        entries, err := os.ReadDir(directory)
        if err != nil </span><span class="cov0" title="0">{
                Debug("[FILES]: 🚨 Error reading directory: " + err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">var files []string
        for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        files = append(files, entry.Name())
                }</span>
        }

        <span class="cov0" title="0">Debug("[FILES]: 📂 Successfully listed files in directory: " + directory)
        return files, nil</span>
}

func ToJSON(data interface{}) string <span class="cov8" title="1">{
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                Debug("[JSON]: 🚨 Error marshalling data: " + err.Error())
                return "{}"
        }</span>
        <span class="cov8" title="1">Debug("[JSON]: ✨ Successfully marshalled data to JSON")
        return string(jsonData)</span>
}

func IsNumeric(s string) bool <span class="cov8" title="1">{
        for _, char := range s </span><span class="cov8" title="1">{
                if char &lt; '0' || char &gt; '9' </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">Debug("[NUMERIC]: 🔢 String is numeric: " + s)
        return len(s) &gt; 0</span>
}

func ParseInt(s string) (int, error) <span class="cov8" title="1">{
        if !IsNumeric(s) </span><span class="cov8" title="1">{
                Error("[PARSE]: 🚨 Error parsing string to int: " + s)
                return 0, fmt.Errorf("invalid number: %s", s)
        }</span>

        <span class="cov8" title="1">result := 0
        for _, char := range s </span><span class="cov8" title="1">{
                result = result*10 + int(char-'0')
        }</span>

        <span class="cov8" title="1">Debug("[PARSE]: 🔢 Successfully parsed string to int: " + s)
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package utils

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/google/generative-ai-go/genai"
        "google.golang.org/api/option"
        "google.golang.org/grpc/status"
)

var (
        maxRetries int
        retryDelay int
)

func SetTimeoutVar(retries, delay int) <span class="cov0" title="0">{
        maxRetries = retries
        retryDelay = delay
}</span>

func printResponse(resp *genai.GenerateContentResponse) <span class="cov0" title="0">{
        if resp == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for i, candidate := range resp.Candidates </span><span class="cov0" title="0">{
                Debug(fmt.Sprintf("[GEMINI]: Candidate %d: %s", i+1, candidate.Content.Parts[0]))
        }</span>
}

func SendToGemini(contextData map[string]map[string]string, apiKey string) (string, error) <span class="cov0" title="0">{

        ctx := context.Background()
        client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
        if err != nil </span><span class="cov0" title="0">{
                Error("[GEMINI]: 🚨 Failed to initialize Gemini client: " + err.Error())
                return "", err
        }</span>
        <span class="cov0" title="0">defer client.Close()

        model := client.GenerativeModel("gemini-2.0-flash")
        model.SetTemperature(0.5)
        model.SetMaxOutputTokens(100)
        model.ResponseMIMEType = "application/json"
        model.SystemInstruction = genai.NewUserContent(genai.Text(`
        Generate and return only a commit message as JSON with the key "message".
        Follow these guidelines for the commit message:
        • Capitalize the first word, omit final punctuation. If using conventional commits, use lowercase for the commit type.
        • Use imperative mood in the subject line.
        • Include a commit type (e.g. fix, update, refactor, bump).
        • Limit the first line to ≤ 50 characters, subsequent lines ≤ 72.
        • Be concise and direct; avoid filler words.
        • Do not include newline characters (\n) or similar formatting.

        The commit type can include the following:
        feat – a new feature
        fix – a bug fix
        chore – non-source changes
        refactor – refactored code
        docs – documentation updates
        style – formatting changes
        test – tests
        perf – performance improvements
        ci – continuous integration
        build – build system changes
        revert – revert a previous commit
        `))

        var promptBuilder strings.Builder
        promptBuilder.WriteString("Summarize the following file changes:\n\n")
        for file, data := range contextData </span><span class="cov0" title="0">{
                promptBuilder.WriteString(fmt.Sprintf("File: %s\nType: %s\nDiff:\n%s\n\n", file, data["type"], data["diff"]))
        }</span>
        <span class="cov0" title="0">prompt := promptBuilder.String()

        var resp *genai.GenerateContentResponse
        for retries := 0; retries &lt; maxRetries; retries++ </span><span class="cov0" title="0">{
                resp, err = model.GenerateContent(ctx, genai.Text(prompt))
                if err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "googleapi: Error 429: You exceeded your current quota, please check your plan and billing details.") || status.Code(err) == 14 </span><span class="cov0" title="0">{ // Retry on specific 429 error or UNAVAILABLE
                                Warning(fmt.Sprintf("[GEMINI]: ⚠️ Quota exceeded or service unavailable. Retrying in %d seconds... (attempt %d/%d)", retryDelay, retries+1, maxRetries))
                                time.Sleep(time.Duration(retryDelay) * time.Second)
                                continue</span>
                        }
                        <span class="cov0" title="0">return "", err</span>
                }
                <span class="cov0" title="0">break</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if len(resp.Candidates) == 0 </span><span class="cov0" title="0">{
                Error("[GEMINI]: ❌ No content generated by Gemini.")
                return "", errors.New("no content generated by Gemini")
        }</span>

        <span class="cov0" title="0">respMessage := fmt.Sprintf(`%s`, resp.Candidates[0].Content.Parts[0])
        Debug("[GEMINI]: ✨ Response received: " + respMessage)

        var result map[string]string
        err = json.Unmarshal([]byte(respMessage), &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                Error("[GEMINI]: 🚨 Failed to parse response: " + err.Error())
                return "", err
        }</span>

        <span class="cov0" title="0">message, ok := result["message"]
        if !ok </span><span class="cov0" title="0">{
                Error("[GEMINI]: ❌ Key 'message' not found in response.")
                return "", errors.New("key 'message' not found in response")
        }</span>

        <span class="cov0" title="0">return message, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package utils

import (
        "fmt"
        "log"
        "runtime"
        "strings"
)

// ANSI color codes - Dark Tech palette
const (
        Reset     = "\033[0m"
        Red       = "\033[38;5;196m" // Bright red
        Green     = "\033[38;5;46m"  // Neon green
        Yellow    = "\033[38;5;226m" // Warning yellow
        Blue      = "\033[38;5;33m"  // Electric blue
        Magenta   = "\033[38;5;201m" // Cyber pink
        Cyan      = "\033[38;5;51m"  // Holographic cyan
        Black     = "\033[38;5;236m" // Dark background
        Bold      = "\033[1m"
        Underline = "\033[4m"
        Blink     = "\033[5m" // Use sparingly!
        Dim       = "\033[2m"
        BlackBg   = "\033[48;5;235m" // Dark background
)

var LogLevel string = "info"

func SetLogLevel(level string) <span class="cov8" title="1">{
        LogLevel = level
}</span>

// Debug logs a message at the debug level
func Debug(message string) <span class="cov8" title="1">{
        if LogLevel != "debug" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">log.Printf("\n%s%s[SCAN    ] 🔍 %s %s\n", Cyan, BlackBg, Reset, message)</span>
}

// Info logs a message at the info level
func Info(message string) <span class="cov8" title="1">{
        fmt.Printf("\n%s%s[SYS     ] ⚡ %s %s\n", Green, BlackBg, Reset, message)
}</span>

// Success logs a success message
func Success(message string) <span class="cov8" title="1">{
        fmt.Printf("\n%s%s[SUCCESS ] 💻 %s %s\n", Green, BlackBg, Reset, message)
}</span>

// Error logs error message
func Error(message string) <span class="cov8" title="1">{
        _, file, line, ok := runtime.Caller(1)
        if ok </span><span class="cov8" title="1">{
                shortFile := file
                if parts := strings.Split(file, "/"); len(parts) &gt; 2 </span><span class="cov8" title="1">{
                        shortFile = parts[len(parts)-2] + "/" + parts[len(parts)-1]
                }</span>
                <span class="cov8" title="1">log.Printf("\n%s%s[BREACH  ] ⚠️ %s %s (at %s:%d)\n", Red, BlackBg, Reset, message, shortFile, line)</span>
        } else<span class="cov0" title="0"> {
                log.Printf("\n%s%s[BREACH  ] ⚠️ %s %s\n", Red, BlackBg, Reset, message)
        }</span>
}

// Warning logs warning message
func Warning(message string) <span class="cov8" title="1">{
        fmt.Printf("\n%s%s[ALERT   ] 🔥 %s %s\n", Yellow, BlackBg, Reset, message)
}</span>

// Print outputs data to the CLI
func Print(data string) <span class="cov0" title="0">{
        fmt.Printf("\n%s%s%s\n", Cyan, data, Reset)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package utils

import (
        "fmt"
        "io"
        "os"
        "strings"
        "sync"
        "time"
)

// ProgressReporter provides an interface for reporting progress of long-running operations
type ProgressReporter struct {
        total         int64
        current       int64
        start         time.Time
        lastUpdate    time.Time
        updateMu      sync.Mutex
        message       string
        finished      bool
        width         int
        writer        io.Writer
        hideInQuiet   bool
        updateFreq    time.Duration
        progressChar  string
        spinnerChars  []string
        spinnerPos    int
        spinnerActive bool
        spinnerTicker *time.Ticker
        spinnerDone   chan struct{}
}

// NewProgressReporter creates a new progress reporter
func NewProgressReporter(total int64, message string) *ProgressReporter <span class="cov0" title="0">{
        return &amp;ProgressReporter{
                total:        total,
                current:      0,
                start:        time.Now(),
                lastUpdate:   time.Now(),
                message:      message,
                finished:     false,
                width:        50,
                writer:       os.Stdout,
                hideInQuiet:  true,
                updateFreq:   200 * time.Millisecond,
                progressChar: "■",
                spinnerChars: []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"},
                spinnerPos:   0,
        }
}</span>

// NewIndeterminateProgressReporter creates a progress reporter for operations
// where the total amount of work is unknown
func NewIndeterminateProgressReporter(message string) *ProgressReporter <span class="cov0" title="0">{
        p := NewProgressReporter(-1, message)
        return p
}</span>

// SetWidth sets the width of the progress bar
func (p *ProgressReporter) SetWidth(width int) *ProgressReporter <span class="cov0" title="0">{
        p.width = width
        return p
}</span>

// SetWriter sets the io.Writer where progress updates are written
func (p *ProgressReporter) SetWriter(writer io.Writer) *ProgressReporter <span class="cov0" title="0">{
        p.writer = writer
        return p
}</span>

// SetHideInQuiet sets whether the progress bar should be hidden in quiet mode
func (p *ProgressReporter) SetHideInQuiet(hide bool) *ProgressReporter <span class="cov0" title="0">{
        p.hideInQuiet = hide
        return p
}</span>

// Start begins the progress reporting
func (p *ProgressReporter) Start() *ProgressReporter <span class="cov0" title="0">{
        p.updateMu.Lock()
        defer p.updateMu.Unlock()

        p.start = time.Now()
        p.lastUpdate = time.Now()
        p.finished = false

        // Start spinner for indeterminate progress
        if p.total &lt; 0 </span><span class="cov0" title="0">{
                p.spinnerActive = true
                p.spinnerDone = make(chan struct{})
                p.spinnerTicker = time.NewTicker(100 * time.Millisecond)

                go func() </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-p.spinnerTicker.C:<span class="cov0" title="0">
                                        p.updateMu.Lock()
                                        if p.spinnerActive </span><span class="cov0" title="0">{
                                                p.spinnerPos = (p.spinnerPos + 1) % len(p.spinnerChars)
                                                p.renderSpinner()
                                        }</span>
                                        <span class="cov0" title="0">p.updateMu.Unlock()</span>
                                case &lt;-p.spinnerDone:<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }()
        } else<span class="cov0" title="0"> {
                // Render the initial progress bar
                p.render()
        }</span>

        <span class="cov0" title="0">return p</span>
}

// Update updates the current progress
func (p *ProgressReporter) Update(current int64) <span class="cov0" title="0">{
        p.updateMu.Lock()
        defer p.updateMu.Unlock()

        if p.finished </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">p.current = current

        // Only update if enough time has passed since last update
        if time.Since(p.lastUpdate) &gt;= p.updateFreq </span><span class="cov0" title="0">{
                if p.total &lt; 0 </span><span class="cov0" title="0">{
                        // Indeterminate progress uses spinner
                        return
                }</span>

                // Render the progress bar
                <span class="cov0" title="0">p.render()
                p.lastUpdate = time.Now()</span>
        }
}

// UpdateMessage updates the message displayed with the progress bar
func (p *ProgressReporter) UpdateMessage(message string) <span class="cov0" title="0">{
        p.updateMu.Lock()
        defer p.updateMu.Unlock()

        if p.finished </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">p.message = message

        if p.total &lt; 0 </span><span class="cov0" title="0">{
                p.renderSpinner()
        }</span> else<span class="cov0" title="0"> {
                p.render()
        }</span>

        <span class="cov0" title="0">p.lastUpdate = time.Now()</span>
}

// Increment increases the current progress by the specified amount
func (p *ProgressReporter) Increment(amount int64) <span class="cov0" title="0">{
        p.Update(p.current + amount)
}</span>

// Done completes the progress reporting
func (p *ProgressReporter) Done() <span class="cov0" title="0">{
        p.updateMu.Lock()
        defer p.updateMu.Unlock()

        if p.finished </span><span class="cov0" title="0">{
                return
        }</span>

        // If this is a spinner, stop it
        <span class="cov0" title="0">if p.total &lt; 0 &amp;&amp; p.spinnerActive </span><span class="cov0" title="0">{
                p.spinnerActive = false
                p.spinnerTicker.Stop()
                close(p.spinnerDone)

                // Clear the spinner line
                fmt.Fprintf(p.writer, "\r%s\r", strings.Repeat(" ", 80))
        }</span> else<span class="cov0" title="0"> if p.total &gt;= 0 </span><span class="cov0" title="0">{
                // Make sure we show 100% completion
                p.current = p.total
                p.render()
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(p.writer)
        p.finished = true</span>
}

// render displays the current progress bar
func (p *ProgressReporter) render() <span class="cov0" title="0">{
        if p.hideInQuiet &amp;&amp; IsQuietMode() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">percent := float64(p.current) / float64(p.total) * 100
        if percent &gt; 100 </span><span class="cov0" title="0">{
                percent = 100
        }</span>

        <span class="cov0" title="0">elapsed := time.Since(p.start)

        // Calculate ETA
        var etaStr string
        if p.current &gt; 0 </span><span class="cov0" title="0">{
                itemsPerSecond := float64(p.current) / elapsed.Seconds()
                if itemsPerSecond &gt; 0 </span><span class="cov0" title="0">{
                        remainingItems := p.total - p.current
                        etaSeconds := float64(remainingItems) / itemsPerSecond
                        eta := time.Duration(etaSeconds) * time.Second
                        if eta &gt; 0 </span><span class="cov0" title="0">{
                                etaStr = fmt.Sprintf(" ETA: %s", formatDuration(eta))
                        }</span>
                }
        }

        // Build progress bar
        <span class="cov0" title="0">width := p.width
        completed := int(float64(width) * float64(p.current) / float64(p.total))

        progressBar := strings.Repeat(p.progressChar, completed) + strings.Repeat("░", width-completed)

        // Format and print the progress line
        fmt.Fprintf(
                p.writer,
                "\r%s [%s] %.1f%% (%d/%d)%s",
                p.message,
                progressBar,
                percent,
                p.current,
                p.total,
                etaStr,
        )</span>
}

// renderSpinner displays the spinner for indeterminate progress
func (p *ProgressReporter) renderSpinner() <span class="cov0" title="0">{
        if p.hideInQuiet &amp;&amp; IsQuietMode() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">spinner := p.spinnerChars[p.spinnerPos]
        elapsed := formatDuration(time.Since(p.start))

        fmt.Fprintf(
                p.writer,
                "\r%s %s [%s]",
                spinner,
                p.message,
                elapsed,
        )</span>
}

// formatDuration formats a duration in a user-friendly way
func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d &lt; time.Minute </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1fs", d.Seconds())
        }</span> else<span class="cov0" title="0"> if d &lt; time.Hour </span><span class="cov0" title="0">{
                minutes := int(d.Minutes())
                seconds := int(d.Seconds()) % 60
                return fmt.Sprintf("%dm%ds", minutes, seconds)
        }</span> else<span class="cov0" title="0"> {
                hours := int(d.Hours())
                minutes := int(d.Minutes()) % 60
                return fmt.Sprintf("%dh%dm", hours, minutes)
        }</span>
}

// Global quiet mode flag
var quietMode bool
var quietModeOnce sync.Once
var quietModeMu sync.RWMutex

// SetQuietMode sets the global quiet mode flag
func SetQuietMode(quiet bool) <span class="cov0" title="0">{
        quietModeOnce.Do(func() </span><span class="cov0" title="0">{
                quietModeMu.Lock()
                quietMode = quiet
                quietModeMu.Unlock()
        }</span>)
}

// IsQuietMode returns whether quiet mode is enabled
func IsQuietMode() bool <span class="cov0" title="0">{
        quietModeMu.RLock()
        defer quietModeMu.RUnlock()
        return quietMode
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package utils

import (
        "bufio"
        "fmt"
        "os"
        "strings"
)

// ConfirmAction asks the user to confirm an action with yes/no prompt
func ConfirmAction(message string, defaultYes bool) bool <span class="cov0" title="0">{
        // Skip confirmation in non-interactive environments
        if os.Getenv("GITCURY_NONINTERACTIVE") == "1" </span><span class="cov0" title="0">{
                return defaultYes
        }</span>

        <span class="cov0" title="0">prompt := message + " "
        if defaultYes </span><span class="cov0" title="0">{
                prompt += "[Y/n]: "
        }</span> else<span class="cov0" title="0"> {
                prompt += "[y/N]: "
        }</span>

        <span class="cov0" title="0">fmt.Print(prompt)

        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                Warning("[CONFIRM]: Error reading input, using default: " + err.Error())
                return defaultYes
        }</span>

        <span class="cov0" title="0">response = strings.TrimSpace(strings.ToLower(response))

        if response == "" </span><span class="cov0" title="0">{
                return defaultYes
        }</span>

        <span class="cov0" title="0">return response == "y" || response == "yes"</span>
}

// ConfirmActionWithDetails asks for confirmation and shows detailed information
func ConfirmActionWithDetails(action string, details []string, defaultYes bool) bool <span class="cov0" title="0">{
        fmt.Println("📝 " + action)

        if len(details) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Details:")
                for _, detail := range details </span><span class="cov0" title="0">{
                        fmt.Println("  • " + detail)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">return ConfirmAction("Do you want to continue?", defaultYes)</span>
}

// PromptForInput asks the user for text input with an optional default value
func PromptForInput(message string, defaultValue string) string <span class="cov0" title="0">{
        // Show default value in prompt if provided
        prompt := message
        if defaultValue != "" </span><span class="cov0" title="0">{
                prompt += fmt.Sprintf(" [default: %s]", defaultValue)
        }</span>
        <span class="cov0" title="0">prompt += ": "

        fmt.Print(prompt)

        reader := bufio.NewReader(os.Stdin)
        input, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                Warning("[PROMPT]: Error reading input, using default: " + err.Error())
                return defaultValue
        }</span>

        <span class="cov0" title="0">input = strings.TrimSpace(input)

        if input == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">return input</span>
}

// PromptForSelection asks the user to select from a list of options
func PromptForSelection(message string, options []string, defaultIndex int) (string, int) <span class="cov0" title="0">{
        if len(options) == 0 </span><span class="cov0" title="0">{
                return "", -1
        }</span>

        // Default to first item if default index is invalid
        <span class="cov0" title="0">if defaultIndex &lt; 0 || defaultIndex &gt;= len(options) </span><span class="cov0" title="0">{
                defaultIndex = 0
        }</span>

        <span class="cov0" title="0">fmt.Println(message)
        for i, option := range options </span><span class="cov0" title="0">{
                marker := " "
                if i == defaultIndex </span><span class="cov0" title="0">{
                        marker = "*"
                }</span>
                <span class="cov0" title="0">fmt.Printf("  %s %d) %s\n", marker, i+1, option)</span>
        }

        <span class="cov0" title="0">selectedIndex := -1

        for selectedIndex &lt; 0 || selectedIndex &gt;= len(options) </span><span class="cov0" title="0">{
                input := PromptForInput("Enter number", fmt.Sprintf("%d", defaultIndex+1))

                // Try to parse as number
                var parsedIndex int
                _, err := fmt.Sscanf(input, "%d", &amp;parsedIndex)
                if err != nil || parsedIndex &lt; 1 || parsedIndex &gt; len(options) </span><span class="cov0" title="0">{
                        fmt.Printf("Please enter a number between 1 and %d\n", len(options))
                        continue</span>
                }

                <span class="cov0" title="0">selectedIndex = parsedIndex - 1</span>
        }

        <span class="cov0" title="0">return options[selectedIndex], selectedIndex</span>
}

// ShowProgressiveConfirmation shows a multi-step confirmation dialog
// where each step depends on the previous one
func ShowProgressiveConfirmation(steps []string, actions []func() error) error <span class="cov0" title="0">{
        if len(steps) != len(actions) </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch between steps (%d) and actions (%d)", len(steps), len(actions))
        }</span>

        <span class="cov0" title="0">for i, step := range steps </span><span class="cov0" title="0">{
                if !ConfirmAction(fmt.Sprintf("Step %d/%d: %s", i+1, len(steps), step), true) </span><span class="cov0" title="0">{
                        return fmt.Errorf("action cancelled by user at step %d", i+1)
                }</span>

                <span class="cov0" title="0">Info(fmt.Sprintf("Executing step %d/%d: %s", i+1, len(steps), step))
                if err := actions[i](); err != nil </span><span class="cov0" title="0">{
                        Error(fmt.Sprintf("Step %d failed: %s", i+1, err.Error()))
                        return err
                }</span>

                <span class="cov0" title="0">Success(fmt.Sprintf("Step %d/%d completed successfully", i+1, len(steps)))</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package utils

import (
        "fmt"
        "runtime"
        "sync"
        "time"
)

// ResourceManager monitors and manages system resources for the application
type ResourceManager struct {
        maxMemoryPercent float64
        maxCPUPercent    float64
        checkInterval    time.Duration

        // State
        running      bool
        stopChan     chan struct{}
        resourceLock sync.RWMutex

        // Metrics
        memStats         runtime.MemStats
        lastMemoryUsage  uint64
        lastCPUUsage     float64
        lastChecked      time.Time
        resourceWarnings int
}

// NewResourceManager creates a resource manager with default settings
func NewResourceManager() *ResourceManager <span class="cov0" title="0">{
        return &amp;ResourceManager{
                maxMemoryPercent: 80.0, // Default to 80% max memory usage
                maxCPUPercent:    90.0, // Default to 90% max CPU usage
                checkInterval:    5 * time.Second,
                stopChan:         make(chan struct{}),
                resourceWarnings: 0,
                lastChecked:      time.Now(),
        }
}</span>

// SetMaxMemoryPercent sets the maximum allowed memory usage as a percentage
func (rm *ResourceManager) SetMaxMemoryPercent(percent float64) <span class="cov0" title="0">{
        if percent &lt;= 0 || percent &gt; 100 </span><span class="cov0" title="0">{
                Warning("Invalid memory percent value, using default")
                percent = 80.0
        }</span>
        <span class="cov0" title="0">rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()
        rm.maxMemoryPercent = percent</span>
}

// SetMaxCPUPercent sets the maximum allowed CPU usage as a percentage
func (rm *ResourceManager) SetMaxCPUPercent(percent float64) <span class="cov0" title="0">{
        if percent &lt;= 0 || percent &gt; 100 </span><span class="cov0" title="0">{
                Warning("Invalid CPU percent value, using default")
                percent = 90.0
        }</span>
        <span class="cov0" title="0">rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()
        rm.maxCPUPercent = percent</span>
}

// SetCheckInterval sets how often resources are checked
func (rm *ResourceManager) SetCheckInterval(interval time.Duration) <span class="cov0" title="0">{
        if interval &lt; time.Second </span><span class="cov0" title="0">{
                Warning("Check interval too small, using minimum of 1 second")
                interval = time.Second
        }</span>
        <span class="cov0" title="0">rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()
        rm.checkInterval = interval</span>
}

// Start begins monitoring system resources
func (rm *ResourceManager) Start() <span class="cov0" title="0">{
        rm.resourceLock.Lock()
        if rm.running </span><span class="cov0" title="0">{
                rm.resourceLock.Unlock()
                return
        }</span>
        <span class="cov0" title="0">rm.running = true
        rm.resourceLock.Unlock()

        Debug("[RESOURCE]: Resource monitoring started")

        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(rm.checkInterval)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                rm.checkResources()</span>
                        case &lt;-rm.stopChan:<span class="cov0" title="0">
                                Debug("[RESOURCE]: Resource monitoring stopped")
                                return</span>
                        }
                }
        }()
}

// Stop ends resource monitoring
func (rm *ResourceManager) Stop() <span class="cov0" title="0">{
        rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()

        if !rm.running </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">rm.running = false
        rm.stopChan &lt;- struct{}{}</span>
}

// IsRunning returns whether resource monitoring is active
func (rm *ResourceManager) IsRunning() bool <span class="cov0" title="0">{
        rm.resourceLock.RLock()
        defer rm.resourceLock.RUnlock()
        return rm.running
}</span>

// GetResourceUsage returns the current resource usage metrics
func (rm *ResourceManager) GetResourceUsage() map[string]interface{} <span class="cov0" title="0">{
        rm.resourceLock.RLock()
        defer rm.resourceLock.RUnlock()

        // Force an update of the metrics
        runtime.ReadMemStats(&amp;rm.memStats)

        return map[string]interface{}{
                "memoryUsageMB":    rm.memStats.Alloc / 1024 / 1024,
                "totalMemoryMB":    rm.memStats.Sys / 1024 / 1024,
                "numGoroutines":    runtime.NumGoroutine(),
                "resourceWarnings": rm.resourceWarnings,
                "lastChecked":      rm.lastChecked,
                "maxMemoryPercent": rm.maxMemoryPercent,
                "maxCPUPercent":    rm.maxCPUPercent,
        }
}</span>

// checkResources examines current resource usage and takes action if thresholds are exceeded
func (rm *ResourceManager) checkResources() <span class="cov0" title="0">{
        rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()

        rm.lastChecked = time.Now()

        // Get current memory stats
        runtime.ReadMemStats(&amp;rm.memStats)

        // Check memory usage
        totalMemory := rm.memStats.Sys
        usedMemory := rm.memStats.Alloc
        memoryPercent := float64(usedMemory) / float64(totalMemory) * 100

        // Check CPU usage (simplified since Go doesn't provide direct CPU usage)
        numGoroutines := runtime.NumGoroutine()

        // Store current values
        rm.lastMemoryUsage = usedMemory

        // Log resource usage in debug mode
        Debug(fmt.Sprintf("[RESOURCE]: Memory: %.2f%% (%d MB / %d MB), Goroutines: %d",
                memoryPercent, usedMemory/1024/1024, totalMemory/1024/1024, numGoroutines))

        // Check if we're exceeding thresholds
        if memoryPercent &gt; rm.maxMemoryPercent </span><span class="cov0" title="0">{
                rm.resourceWarnings++
                Warning(fmt.Sprintf("[RESOURCE.WARNING]: Memory usage is high: %.2f%% (threshold: %.2f%%)",
                        memoryPercent, rm.maxMemoryPercent))

                // Take action - force garbage collection if memory usage is critical
                if memoryPercent &gt; rm.maxMemoryPercent+10 </span><span class="cov0" title="0">{
                        Info("[RESOURCE]: Forcing garbage collection due to high memory usage")
                        runtime.GC()
                }</span>
        }

        // Check if number of goroutines is unusually high (simplistic approach)
        <span class="cov0" title="0">if numGoroutines &gt; 1000 </span><span class="cov0" title="0">{
                rm.resourceWarnings++
                Warning(fmt.Sprintf("[RESOURCE.WARNING]: High number of goroutines: %d", numGoroutines))
        }</span>
}

// GetRecommendedWorkerCount returns the recommended number of worker goroutines
// based on current system load and available CPU cores
func (rm *ResourceManager) GetRecommendedWorkerCount(defaultWorkers int) int <span class="cov0" title="0">{
        rm.resourceLock.RLock()
        defer rm.resourceLock.RUnlock()

        // Get number of CPU cores
        numCPU := runtime.NumCPU()

        // Calculate recommended worker count
        var recommendedWorkers int

        // If we're under resource pressure, reduce worker count
        if rm.resourceWarnings &gt; 5 </span><span class="cov0" title="0">{
                // Under significant resource pressure
                recommendedWorkers = max(1, numCPU/4)
        }</span> else<span class="cov0" title="0"> if rm.resourceWarnings &gt; 0 </span><span class="cov0" title="0">{
                // Under mild resource pressure
                recommendedWorkers = max(1, numCPU/2)
        }</span> else<span class="cov0" title="0"> {
                // No resource pressure, use 75% of available cores
                recommendedWorkers = max(1, (numCPU*3)/4)
        }</span>

        // If defaultWorkers is specified and smaller than our calculation, use that instead
        <span class="cov0" title="0">if defaultWorkers &gt; 0 &amp;&amp; defaultWorkers &lt; recommendedWorkers </span><span class="cov0" title="0">{
                recommendedWorkers = defaultWorkers
        }</span>

        <span class="cov0" title="0">return recommendedWorkers</span>
}

// Default instance
var defaultResourceManager *ResourceManager
var rmOnce sync.Once

// GetResourceManager returns the default resource manager instance
func GetResourceManager() *ResourceManager <span class="cov0" title="0">{
        rmOnce.Do(func() </span><span class="cov0" title="0">{
                defaultResourceManager = NewResourceManager()
        }</span>)
        <span class="cov0" title="0">return defaultResourceManager</span>
}

// Helper function for Go &lt; 1.21
func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package utils

import (
        "context"
        "fmt"
        "runtime/debug"
        "time"
)

// SafeExecute runs a function with panic recovery
func SafeExecute(operation string, fn func() error) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        Debug("[RECOVERY]: Recovered from panic in " + operation)
                        Debug("[RECOVERY]: Stack trace:\n" + string(debug.Stack()))

                        switch x := r.(type) </span>{
                        case string:<span class="cov8" title="1">
                                err = NewSystemError("Panic occurred", fmt.Errorf("%s", x), map[string]interface{}{
                                        "operation": operation,
                                })</span>
                        case error:<span class="cov0" title="0">
                                err = NewSystemError("Panic occurred", x, map[string]interface{}{
                                        "operation": operation,
                                })</span>
                        default:<span class="cov0" title="0">
                                err = NewSystemError("Panic occurred", fmt.Errorf("%v", x), map[string]interface{}{
                                        "operation": operation,
                                })</span>
                        }
                }
        }()

        <span class="cov8" title="1">return fn()</span>
}

// RetryConfig holds the configuration for retry operations
type RetryConfig struct {
        MaxRetries   int
        InitialDelay time.Duration
        MaxDelay     time.Duration
        Factor       float64 // Exponential backoff factor
}

// DefaultRetryConfig returns the default retry configuration
func DefaultRetryConfig() RetryConfig <span class="cov0" title="0">{
        return RetryConfig{
                MaxRetries:   3,
                InitialDelay: 1 * time.Second,
                MaxDelay:     30 * time.Second,
                Factor:       2.0,
        }
}</span>

// WithRetry executes a function with automatic retries using exponential backoff
func WithRetry(ctx context.Context, operation string, config RetryConfig, fn func() error) error <span class="cov8" title="1">{
        var lastErr error
        delay := config.InitialDelay

        for attempt := 0; attempt &lt;= config.MaxRetries; attempt++ </span><span class="cov8" title="1">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        Debug(fmt.Sprintf("[RETRY]: Attempt %d/%d for operation '%s' after delay of %v",
                                attempt, config.MaxRetries, operation, delay))
                }</span>

                <span class="cov8" title="1">err := SafeExecute(operation, fn)
                if err == nil </span><span class="cov8" title="1">{
                        if attempt &gt; 0 </span><span class="cov0" title="0">{
                                Debug(fmt.Sprintf("[RETRY]: Operation '%s' succeeded after %d attempts",
                                        operation, attempt+1))
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }

                <span class="cov0" title="0">lastErr = err
                Debug(fmt.Sprintf("[RETRY]: Operation '%s' failed (attempt %d/%d): %v",
                        operation, attempt+1, config.MaxRetries, err))

                // Don't sleep if this was the last attempt
                if attempt == config.MaxRetries </span><span class="cov0" title="0">{
                        break</span>
                }

                // Check if context is cancelled before sleeping
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return NewSystemError(
                                "Operation cancelled",
                                ctx.Err(),
                                map[string]interface{}{
                                        "operation": operation,
                                        "attempts":  attempt + 1,
                                },
                        )</span>
                case &lt;-time.After(delay):<span class="cov0" title="0">
                        // Calculate next delay with exponential backoff
                        delay = time.Duration(float64(delay) * config.Factor)
                        if delay &gt; config.MaxDelay </span><span class="cov0" title="0">{
                                delay = config.MaxDelay
                        }</span>
                }
        }

        <span class="cov0" title="0">return NewSystemError(
                fmt.Sprintf("Operation failed after %d attempts", config.MaxRetries+1),
                lastErr,
                map[string]interface{}{
                        "operation":  operation,
                        "maxRetries": config.MaxRetries,
                },
        )</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package utils

import (
        "context"
        "sync"
        "time"
)

// WorkerPool implements a reusable worker pool with configurable concurrency limit
type WorkerPool struct {
        maxWorkers int
        semaphore  chan struct{}
        wg         sync.WaitGroup
        mu         sync.Mutex
        errors     []error
}

// NewWorkerPool creates a new worker pool with the specified maximum concurrent workers
func NewWorkerPool(maxWorkers int) *WorkerPool <span class="cov8" title="1">{
        if maxWorkers &lt;= 0 </span><span class="cov8" title="1">{
                maxWorkers = 1
        }</span>

        <span class="cov8" title="1">return &amp;WorkerPool{
                maxWorkers: maxWorkers,
                semaphore:  make(chan struct{}, maxWorkers),
                errors:     make([]error, 0),
        }</span>
}

// Submit adds a task to the worker pool with the specified timeout
func (wp *WorkerPool) Submit(taskName string, timeout time.Duration, task func() error) <span class="cov8" title="1">{
        wp.wg.Add(1)

        go func() </span><span class="cov8" title="1">{
                defer wp.wg.Done()

                // Acquire semaphore slot (blocks if max workers is reached)
                wp.semaphore &lt;- struct{}{}
                defer func() </span><span class="cov8" title="1">{ &lt;-wp.semaphore }</span>()

                // Create context with timeout
                <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), timeout)
                defer cancel()

                // Channel for task completion
                done := make(chan error, 1)

                // Run the task in a separate goroutine
                go func() </span><span class="cov8" title="1">{
                        err := SafeExecute(taskName, task)
                        done &lt;- err
                }</span>()

                // Wait for either task completion or timeout
                <span class="cov8" title="1">select </span>{
                case err := &lt;-done:<span class="cov8" title="1">
                        if err != nil </span><span class="cov8" title="1">{
                                wp.addError(err)
                        }</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        wp.addError(NewSystemError(
                                "Task timed out",
                                ctx.Err(),
                                map[string]interface{}{
                                        "taskName": taskName,
                                        "timeout":  timeout.String(),
                                },
                        ))</span>
                }
        }()
}

// Wait blocks until all tasks have completed
func (wp *WorkerPool) Wait() []error <span class="cov8" title="1">{
        wp.wg.Wait()
        return wp.Errors()
}</span>

// Errors returns all errors collected from task execution
func (wp *WorkerPool) Errors() []error <span class="cov8" title="1">{
        wp.mu.Lock()
        defer wp.mu.Unlock()

        // Make a copy to avoid race conditions
        errCopy := make([]error, len(wp.errors))
        copy(errCopy, wp.errors)

        return errCopy
}</span>

// HasErrors returns true if any tasks have reported errors
func (wp *WorkerPool) HasErrors() bool <span class="cov0" title="0">{
        wp.mu.Lock()
        defer wp.mu.Unlock()
        return len(wp.errors) &gt; 0
}</span>

// addError safely adds an error to the error list
func (wp *WorkerPool) addError(err error) <span class="cov8" title="1">{
        wp.mu.Lock()
        defer wp.mu.Unlock()
        wp.errors = append(wp.errors, err)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
