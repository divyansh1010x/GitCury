
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">GitCury/config/config.go (51.1%)</option>
				
				<option value="file1">GitCury/core/commit.go (17.8%)</option>
				
				<option value="file2">GitCury/core/msgs.go (1.8%)</option>
				
				<option value="file3">GitCury/core/push.go (64.9%)</option>
				
				<option value="file4">GitCury/embeddings/embeddings.go (36.5%)</option>
				
				<option value="file5">GitCury/git/git.go (19.4%)</option>
				
				<option value="file6">GitCury/git/progress.go (0.0%)</option>
				
				<option value="file7">GitCury/git/recovery.go (31.7%)</option>
				
				<option value="file8">GitCury/output/output.go (70.5%)</option>
				
				<option value="file9">GitCury/tests/mocks/mocks.go (19.2%)</option>
				
				<option value="file10">GitCury/tests/testreport/testreport.go (0.0%)</option>
				
				<option value="file11">GitCury/tests/testutils/testutils.go (75.9%)</option>
				
				<option value="file12">GitCury/utils/errors.go (60.7%)</option>
				
				<option value="file13">GitCury/utils/files.go (58.6%)</option>
				
				<option value="file14">GitCury/utils/gemini.go (0.0%)</option>
				
				<option value="file15">GitCury/utils/logger.go (86.7%)</option>
				
				<option value="file16">GitCury/utils/progress.go (0.0%)</option>
				
				<option value="file17">GitCury/utils/prompt.go (0.0%)</option>
				
				<option value="file18">GitCury/utils/resource.go (0.0%)</option>
				
				<option value="file19">GitCury/utils/retry.go (50.0%)</option>
				
				<option value="file20">GitCury/utils/workerpool.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "GitCury/utils"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sync"
)

var (
        settings = make(map[string]interface{})
        mu       sync.RWMutex
)

type Alias struct {
        Commit  string `json:"commit"`
        Push    string `json:"push"`
        GetMsgs string `json:"getmsgs"`
        Output  string `json:"output"`
        Config  string `json:"config"`
        Setup   string `json:"setup"`
        Boom    string `json:"boom"`
}

var (
        Aliases        Alias
        DefaultAliases = Alias{
                Commit:  "seal",
                Push:    "deploy",
                GetMsgs: "genesis",
                Output:  "trace",
                Config:  "nexus",
                Setup:   "bootstrap",
                Boom:    "cascade",
        }
)

func init() <span class="cov8" title="1">{
        LoadConfig()
}</span>

func LoadConfig() error <span class="cov8" title="1">{
        configFilePath := os.Getenv("HOME") + "/.gitcury/config.json"
        file, err := os.Open(configFilePath)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                // Set default settings if the file does not exist
                settings = map[string]interface{}{
                        "app_name":         "GitCury",
                        "version":          "1.0.0",
                        "root_folders":     []string{"."},
                        "config_dir":       os.Getenv("HOME") + "/.gitcury",
                        "output_file_path": os.Getenv("HOME") + "/.gitcury/output.json",
                        "editor":           "nano",
                        "aliases": map[string]string{
                                "getmsgs": DefaultAliases.GetMsgs,
                                "commit":  DefaultAliases.Commit,
                                "push":    DefaultAliases.Push,
                                "output":  DefaultAliases.Output,
                                "config":  DefaultAliases.Config,
                                "setup":   DefaultAliases.Setup,
                                "boom":    DefaultAliases.Boom,
                        },
                        "retries":       3,
                        "timeout":       30,
                        "maxConcurrent": 5,
                        "logLevel":      "info",
                }

                // Save the default settings to the file
                if err := saveConfigToFile(configFilePath); err != nil </span><span class="cov0" title="0">{
                        utils.Error("[Config]: Failed to save default configuration: " + err.Error())
                        return utils.NewConfigError(
                                "Failed to save default configuration",
                                err,
                                map[string]interface{}{
                                        "configPath": configFilePath,
                                },
                        )
                }</span>

                <span class="cov8" title="1">utils.Debug("[Config]: Config file not found. Using default settings and saving to file: \n" + utils.ToJSON(settings))

                // Set up aliases with default values
                Aliases = DefaultAliases
                return nil</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                utils.Error("[Config]: Error opening configuration file: " + err.Error())
                return utils.NewConfigError(
                        "Error opening configuration file",
                        err,
                        map[string]interface{}{
                                "configPath": configFilePath,
                        },
                )
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Parse the config file
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;settings); err != nil </span><span class="cov0" title="0">{
                utils.Error("[Config]: Error parsing configuration file: " + err.Error())
                return utils.NewConfigError(
                        "Error parsing configuration file",
                        err,
                        map[string]interface{}{
                                "configPath": configFilePath,
                        },
                )
        }</span>

        // Validate required settings
        <span class="cov8" title="1">if err := validateConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set up aliases
        <span class="cov8" title="1">aliasesMap, ok := settings["aliases"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Warning("[Config]: No aliases configuration found. Using defaults.")
                Aliases = DefaultAliases
        }</span> else<span class="cov8" title="1"> {
                // Convert the map to our Alias struct
                commitAlias, _ := aliasesMap["commit"].(string)
                if commitAlias == "" </span><span class="cov0" title="0">{
                        commitAlias = DefaultAliases.Commit
                }</span>

                <span class="cov8" title="1">pushAlias, _ := aliasesMap["push"].(string)
                if pushAlias == "" </span><span class="cov0" title="0">{
                        pushAlias = DefaultAliases.Push
                }</span>

                <span class="cov8" title="1">getMsgsAlias, _ := aliasesMap["getmsgs"].(string)
                if getMsgsAlias == "" </span><span class="cov0" title="0">{
                        getMsgsAlias = DefaultAliases.GetMsgs
                }</span>

                <span class="cov8" title="1">outputAlias, _ := aliasesMap["output"].(string)
                if outputAlias == "" </span><span class="cov0" title="0">{
                        outputAlias = DefaultAliases.Output
                }</span>

                <span class="cov8" title="1">configAlias, _ := aliasesMap["config"].(string)
                if configAlias == "" </span><span class="cov0" title="0">{
                        configAlias = DefaultAliases.Config
                }</span>

                <span class="cov8" title="1">setupAlias, _ := aliasesMap["setup"].(string)
                if setupAlias == "" </span><span class="cov0" title="0">{
                        setupAlias = DefaultAliases.Setup
                }</span>

                <span class="cov8" title="1">boomAlias, _ := aliasesMap["boom"].(string)
                if boomAlias == "" </span><span class="cov0" title="0">{
                        boomAlias = DefaultAliases.Boom
                }</span>

                <span class="cov8" title="1">Aliases = Alias{
                        Commit:  commitAlias,
                        Push:    pushAlias,
                        GetMsgs: getMsgsAlias,
                        Output:  outputAlias,
                        Config:  configAlias,
                        Setup:   setupAlias,
                        Boom:    boomAlias,
                }</span>
        }

        // Set log level if available
        <span class="cov8" title="1">logLevel, ok := settings["logLevel"].(string)
        if ok &amp;&amp; logLevel != "" </span><span class="cov8" title="1">{
                utils.SetLogLevel(logLevel)
        }</span>

        <span class="cov8" title="1">utils.Debug("[Config]: Configuration loaded successfully: \n" + utils.ToJSON(settings))
        utils.Debug("[Config]: Aliases loaded successfully: \n" + utils.ToJSON(Aliases))

        return nil</span>
}

// validateConfig ensures that required configuration values are present and valid
func validateConfig() error <span class="cov8" title="1">{
        // Check for required configuration fields
        requiredFields := []string{"app_name", "version", "root_folders"}
        missingFields := []string{}

        for _, field := range requiredFields </span><span class="cov8" title="1">{
                if _, exists := settings[field]; !exists </span><span class="cov0" title="0">{
                        missingFields = append(missingFields, field)
                }</span>
        }

        <span class="cov8" title="1">if len(missingFields) &gt; 0 </span><span class="cov0" title="0">{
                utils.Warning("[Config]: Missing required configuration fields: " + fmt.Sprint(missingFields))
                // Add default values for missing fields
                if _, exists := settings["app_name"]; !exists </span><span class="cov0" title="0">{
                        settings["app_name"] = "GitCury"
                }</span>
                <span class="cov0" title="0">if _, exists := settings["version"]; !exists </span><span class="cov0" title="0">{
                        settings["version"] = "1.0.0"
                }</span>
                <span class="cov0" title="0">if _, exists := settings["root_folders"]; !exists </span><span class="cov0" title="0">{
                        settings["root_folders"] = []string{"."}
                }</span>
        }

        // Validate root_folders
        <span class="cov8" title="1">rootFolders, ok := settings["root_folders"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Warning("[Config]: Invalid root_folders configuration. Must be an array.")
                settings["root_folders"] = []string{"."}
        }</span> else<span class="cov8" title="1"> if len(rootFolders) == 0 </span><span class="cov0" title="0">{
                utils.Warning("[Config]: Empty root_folders configuration. Adding current directory.")
                settings["root_folders"] = []string{"."}
        }</span>

        // Ensure output_file_path is set
        <span class="cov8" title="1">if _, exists := settings["output_file_path"]; !exists </span><span class="cov0" title="0">{
                settings["output_file_path"] = os.Getenv("HOME") + "/.gitcury/output.json"
        }</span>

        // Ensure config_dir is set
        <span class="cov8" title="1">if _, exists := settings["config_dir"]; !exists </span><span class="cov0" title="0">{
                settings["config_dir"] = os.Getenv("HOME") + "/.gitcury"
        }</span>

        // Check for API key
        <span class="cov8" title="1">if geminiKey, exists := settings["GEMINI_API_KEY"]; !exists || geminiKey == "" </span><span class="cov0" title="0">{
                // Try to get from environment
                envKey := os.Getenv("GEMINI_API_KEY")
                if envKey == "" </span><span class="cov0" title="0">{
                        utils.Warning("[Config]: GEMINI_API_KEY not found in config or environment. Some features may not work correctly.")
                }</span> else<span class="cov0" title="0"> {
                        utils.Debug("[Config]: Using GEMINI_API_KEY from environment.")
                        settings["GEMINI_API_KEY"] = envKey
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func saveConfigToFile(configFilePath string) error <span class="cov8" title="1">{
        // Ensure the directory exists
        dir := filepath.Dir(configFilePath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">file, err := os.OpenFile(configFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        encoder := json.NewEncoder(file)
        return encoder.Encode(settings)</span>
}

func Set(key string, value any) <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()
        settings[key] = value

        utils.Debug("[" + Aliases.Config + "]: üíæ Saving updated configuration...")

        configFilePath := os.Getenv("HOME") + "/.gitcury/config.json"

        dir := os.Getenv("HOME") + "/.gitcury"
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ‚ö†Ô∏è Error creating config directory: " + err.Error())
                return
        }</span>

        <span class="cov8" title="1">file, err := os.OpenFile(configFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ‚ö†Ô∏è Error saving configuration: " + err.Error())
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()

        encoder := json.NewEncoder(file)
        if err := encoder.Encode(settings); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ‚ö†Ô∏è Error encoding configuration: " + err.Error())
        }</span>
}

func Get(key string) interface{} <span class="cov8" title="1">{
        mu.RLock()
        defer mu.RUnlock()
        utils.Debug("[" + Aliases.Config + "]: üîç Retrieving configuration key: " + key + " with value: " + utils.ToJSON(settings[key]))
        return settings[key]
}</span>

func GetAll() map[string]interface{} <span class="cov0" title="0">{
        mu.RLock()
        defer mu.RUnlock()
        copy := make(map[string]interface{})
        for key, value := range settings </span><span class="cov0" title="0">{
                copy[key] = value
        }</span>
        <span class="cov0" title="0">return copy</span>
}

func Remove(key string) <span class="cov0" title="0">{
        mu.Lock()
        defer mu.Unlock()
        delete(settings, key)

        go func() </span><span class="cov0" title="0">{
                mu.RLock()
                defer mu.RUnlock()

                configFilePath := os.Getenv("HOME") + "/.gitcury/ json"

                file, err := os.OpenFile(configFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("[" + Aliases.Config + "]: ‚ö†Ô∏è Error saving configuration after removal: " + err.Error())
                        return
                }</span>
                <span class="cov0" title="0">defer file.Close()

                encoder := json.NewEncoder(file)
                if err := encoder.Encode(settings); err != nil </span><span class="cov0" title="0">{
                        utils.Error("[" + Aliases.Config + "]: ‚ö†Ô∏è Error saving configuration after removal: " + err.Error())
                }</span>
        }()
}

func Delete() <span class="cov0" title="0">{
        utils.Debug("[" + Aliases.Config + "]: üóëÔ∏è Deleting configuration file...")
        mu.Lock()
        defer mu.Unlock()
        configFilePath := os.Getenv("HOME") + "/.gitcury/ json"
        if err := os.Remove(configFilePath); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ‚ö†Ô∏è Error deleting configuration file: " + err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package core

import (
        "GitCury/config"
        "GitCury/git"
        "GitCury/output"
        "GitCury/utils"
        "fmt"
        "strings"
        "time"
)

func CommitAllRoots(env ...[]string) error <span class="cov8" title="1">{
        rootFolders := output.GetAll().Folders
        if len(rootFolders) == 0 </span><span class="cov8" title="1">{
                utils.Warning("[" + config.Aliases.Commit + "]: No root folders with changes to commit")
                return nil
        }</span>

        // Determine optimal worker count based on available folders
        <span class="cov0" title="0">workerCount := 3
        if len(rootFolders) &lt; workerCount </span><span class="cov0" title="0">{
                workerCount = len(rootFolders)
        }</span>

        // Create worker pool for parallel execution with limited concurrency
        <span class="cov0" title="0">pool := utils.NewWorkerPool(workerCount)
        utils.Debug("[" + config.Aliases.Commit + "]: Created worker pool with " + fmt.Sprint(workerCount) + " workers for " + fmt.Sprint(len(rootFolders)) + " folders")

        // Submit commit tasks for each root folder
        for _, rootFolder := range rootFolders </span><span class="cov0" title="0">{
                folder := rootFolder // Create local copy to avoid closure issues
                taskName := "CommitRoot:" + folder.Name

                pool.Submit(taskName, 2*time.Minute, func() error </span><span class="cov0" title="0">{
                        utils.Debug("[" + config.Aliases.Commit + "]: Processing root folder: " + folder.Name)

                        if len(folder.Files) == 0 </span><span class="cov0" title="0">{
                                utils.Debug("[" + config.Aliases.Commit + "]: No files to commit in folder: " + folder.Name)
                                return nil
                        }</span>

                        <span class="cov0" title="0">err := git.CommitBatch(folder, env...)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[" + config.Aliases.Commit + ".FAIL]: Failed to commit batch for folder '" + folder.Name + "' - " + err.Error())
                                return utils.NewGitError(
                                        "Failed to commit changes in folder",
                                        err,
                                        map[string]interface{}{
                                                "folder":    folder.Name,
                                                "fileCount": len(folder.Files),
                                        },
                                )
                        }</span>

                        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.Commit + "]: Successfully committed changes in folder: " + folder.Name)
                        return nil</span>
                })
        }

        // Wait for all commit tasks to complete
        <span class="cov0" title="0">errors := pool.Wait()
        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                errorDetails := make([]string, 0, len(errors))
                for _, err := range errors </span><span class="cov0" title="0">{
                        errorDetails = append(errorDetails, err.Error())
                }</span>

                <span class="cov0" title="0">utils.Error("[" + config.Aliases.Commit + ".FAIL]: Batch commit completed with " + fmt.Sprint(len(errors)) + " errors")
                utils.Debug("[" + config.Aliases.Commit + ".FAIL]: Errors encountered: " + strings.Join(errorDetails, "; "))

                return utils.NewGitError(
                        fmt.Sprintf("%d errors occurred during batch commit", len(errors)),
                        fmt.Errorf("multiple commit errors"),
                        map[string]interface{}{
                                "errorCount": len(errors),
                                "errors":     errorDetails,
                        },
                )</span>
        }

        <span class="cov0" title="0">output.Clear()
        utils.Success("[" + config.Aliases.Commit + ".SUCCESS]: Batch commit completed successfully. Output cleared.")
        return nil</span>
}

func CommitOneRoot(rootFolderName string, env ...[]string) error <span class="cov8" title="1">{
        rootFolder := output.GetFolder(rootFolderName)
        if len(rootFolder.Files) == 0 </span><span class="cov8" title="1">{
                utils.Error("[" + config.Aliases.Commit + ".FAIL]: Root folder '" + rootFolderName + "' not found or contains no files.")
                return fmt.Errorf("root folder not found or has no files: %s", rootFolderName)
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.Commit + "]: Targeting root folder for commit: " + rootFolderName)

        err := git.CommitBatch(rootFolder, env...)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Commit + ".FAIL]: Failed to commit batch for folder '" + rootFolderName + "' - " + err.Error())
                return fmt.Errorf("failed to commit batch: %s", err.Error())
        }</span>

        <span class="cov0" title="0">utils.Success("[" + config.Aliases.Commit + ".SUCCESS]: Batch commit completed successfully for root folder: " + rootFolderName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

import (
        "GitCury/config"
        "GitCury/git"
        "GitCury/output"
        "GitCury/utils"
        "fmt"
        "strconv"
        "sync"
)

func GetAllMsgs(numFiles ...int) error <span class="cov0" title="0">{
        defaultNumFiles := 10 // Default value
        if len(numFiles) == 0 || numFiles[0] &lt;= 0 </span><span class="cov0" title="0">{
                numFiles[0] = defaultNumFiles
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Preparing commit messages for " + strconv.Itoa(numFiles[0]) + " files per folder.")

        rootFolders, ok := config.Get("root_folders").([]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid or missing root_folders configuration.")
                return fmt.Errorf("invalid or missing root_folders configuration")
        }</span>

        <span class="cov0" title="0">var rootFolderWg sync.WaitGroup
        var mu sync.Mutex
        var errors []string

        for _, rootFolder := range rootFolders </span><span class="cov0" title="0">{
                rootFolderStr, ok := rootFolder.(string)
                if !ok </span><span class="cov0" title="0">{
                        utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid root folder type.")
                        continue</span>
                }

                <span class="cov0" title="0">rootFolderWg.Add(1)
                go func(folder string) </span><span class="cov0" title="0">{
                        defer rootFolderWg.Done()

                        utils.Debug("[" + config.Aliases.GetMsgs + "]: Processing root folder: " + folder)

                        changedFiles, err := git.GetAllChangedFiles(folder)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[" + config.Aliases.GetMsgs + "]: Failed to retrieve changed files for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                                utils.Debug("[" + config.Aliases.GetMsgs + "]: No changed files found in folder: " + folder)
                                return
                        }</span>

                        <span class="cov0" title="0">if len(changedFiles) &gt; numFiles[0] </span><span class="cov0" title="0">{
                                changedFiles = changedFiles[:numFiles[0]]
                        }</span>

                        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Total files to process in folder '" + folder + "': " + strconv.Itoa(len(changedFiles)))

                        err = git.BatchProcessGetMessages(changedFiles, folder)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[" + config.Aliases.GetMsgs + "]: Batch processing failed for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                        }</span>
                }(rootFolderStr)
        }

        <span class="cov0" title="0">rootFolderWg.Wait()

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Batch processing completed with errors.")
                utils.Debug("[" + config.Aliases.GetMsgs + "]: Errors encountered: " + fmt.Sprint(errors))
                return fmt.Errorf("one or more errors occurred while preparing commit messages")
        }</span>

        <span class="cov0" title="0">utils.Success("[" + config.Aliases.GetMsgs + "]: Commit message generation completed successfully for all folders.")
        output.SaveToFile()
        return nil</span>
}

func GetMsgsForRootFolder(folder string, numFiles ...int) error <span class="cov8" title="1">{
        if folder == "" </span><span class="cov8" title="1">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Root folder is empty.")
                return fmt.Errorf("root folder is empty")
        }</span>

        <span class="cov0" title="0">numFilesToCommit := 10 // Default value
        if len(numFiles) &gt; 0 &amp;&amp; numFiles[0] &gt; 0 </span><span class="cov0" title="0">{
                utils.Debug("[" + config.Aliases.GetMsgs + "]: Using provided number of files to commit: " + strconv.Itoa(numFiles[0]))
                numFilesToCommit = numFiles[0]
        }</span> else<span class="cov0" title="0"> {
                if configValue := config.Get("numFilesToCommit"); configValue != "" </span><span class="cov0" title="0">{
                        if configValueFloat, ok := configValue.(float64); ok </span><span class="cov0" title="0">{
                                utils.Debug("[" + config.Aliases.GetMsgs + "]: Using config value for numFilesToCommit: " + strconv.FormatFloat(configValueFloat, 'f', -1, 64))
                                numFilesToCommit = int(configValueFloat)
                        }</span> else<span class="cov0" title="0"> if configValueStr, ok := configValue.(string); ok </span><span class="cov0" title="0">{
                                if parsedValue, err := strconv.Atoi(configValueStr); err == nil </span><span class="cov0" title="0">{
                                        utils.Debug("[" + config.Aliases.GetMsgs + "]: Using config value for numFilesToCommit from string: " + configValueStr)
                                        numFilesToCommit = parsedValue
                                }</span> else<span class="cov0" title="0"> {
                                        utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid string value for numFilesToCommit: " + configValueStr)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Preparing commit messages for " + strconv.Itoa(numFilesToCommit) + " files in folder: " + folder)

        changedFiles, err := git.GetAllChangedFiles(folder)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Failed to retrieve changed files for folder '" + folder + "' - " + err.Error())
                return fmt.Errorf("failed to get changed files: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                utils.Debug("[" + config.Aliases.GetMsgs + "]: No changed files found in folder: " + folder)
                return nil
        }</span>

        <span class="cov0" title="0">if len(changedFiles) &gt; numFilesToCommit </span><span class="cov0" title="0">{
                changedFiles = changedFiles[:numFilesToCommit]
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Total files to process in folder '" + folder + "': " + strconv.Itoa(len(changedFiles)))

        err = git.BatchProcessGetMessages(changedFiles, folder)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Batch processing failed for folder '" + folder + "' - " + err.Error())
                return fmt.Errorf("batch processing failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">utils.Success("[" + config.Aliases.GetMsgs + "]: Commit message generation completed successfully for folder: " + folder)
        utils.Debug("[" + config.Aliases.GetMsgs + "]: All output: " + fmt.Sprint(output.GetAll()))
        output.SaveToFile()
        return nil</span>
}

func GroupAndGetAllMsgs(numFiles ...int) error <span class="cov0" title="0">{

        utils.Debug("[" + config.Aliases.GetMsgs + "]: Preparing grouped commit messages with embeddings for " + strconv.Itoa(numFiles[0]) + " files per folder.")

        rootFolders, ok := config.Get("root_folders").([]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid or missing root_folders configuration.")
                return fmt.Errorf("invalid or missing root_folders configuration")
        }</span>

        <span class="cov0" title="0">clusters := 10 // Default value
        if len(numFiles) &gt; 0 &amp;&amp; numFiles[0] &gt; 0 </span><span class="cov0" title="0">{
                utils.Debug("[" + config.Aliases.GetMsgs + "]: Using provided number of files to commit: " + strconv.Itoa(numFiles[0]))
                clusters = numFiles[0]
        }</span> else<span class="cov0" title="0"> {
                if configValue := config.Get("numFilesToCommit"); configValue != "" </span><span class="cov0" title="0">{
                        if configValueFloat, ok := configValue.(float64); ok </span><span class="cov0" title="0">{
                                utils.Debug("[" + config.Aliases.GetMsgs + "]: Using config value for numFilesToCommit: " + strconv.FormatFloat(configValueFloat, 'f', -1, 64))
                                clusters = int(configValueFloat)
                        }</span> else<span class="cov0" title="0"> if configValueStr, ok := configValue.(string); ok </span><span class="cov0" title="0">{
                                if parsedValue, err := strconv.Atoi(configValueStr); err == nil </span><span class="cov0" title="0">{
                                        utils.Debug("[" + config.Aliases.GetMsgs + "]: Using config value for numFilesToCommit from string: " + configValueStr)
                                        clusters = parsedValue
                                }</span> else<span class="cov0" title="0"> {
                                        utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid string value for numFilesToCommit: " + configValueStr)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">var rootFolderWg sync.WaitGroup
        var mu sync.Mutex
        var errors []string

        for _, rootFolder := range rootFolders </span><span class="cov0" title="0">{
                rootFolderStr, ok := rootFolder.(string)
                if !ok </span><span class="cov0" title="0">{
                        utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid root folder type.")
                        continue</span>
                }

                <span class="cov0" title="0">rootFolderWg.Add(1)
                go func(folder string) </span><span class="cov0" title="0">{
                        defer rootFolderWg.Done()

                        utils.Debug("[" + config.Aliases.GetMsgs + "]: Grouped (embedding-based) processing for folder: " + folder)

                        changedFiles, err := git.GetAllChangedFiles(folder)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[" + config.Aliases.GetMsgs + "]: Failed to retrieve changed files for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                                utils.Debug("[" + config.Aliases.GetMsgs + "]: No changed files found in folder: " + folder)
                                return
                        }</span>

                        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Total files to process with embeddings in folder '" + folder + "': " + strconv.Itoa(len(changedFiles)))

                        err = git.BatchProcessWithEmbeddings(changedFiles, folder, clusters)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[" + config.Aliases.GetMsgs + "]: Embedding-based batch processing failed for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                        }</span>
                }(rootFolderStr)
        }

        <span class="cov0" title="0">rootFolderWg.Wait()

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Grouped embedding-based batch processing completed with errors.")
                utils.Debug("[" + config.Aliases.GetMsgs + "]: Errors encountered: " + fmt.Sprint(errors))
                return fmt.Errorf("one or more errors occurred during grouped commit message generation with embeddings")
        }</span>

        <span class="cov0" title="0">utils.Success("[" + config.Aliases.GetMsgs + "]: Grouped commit message generation with embeddings completed successfully for all folders.")
        output.SaveToFile()
        return nil</span>
}

func GroupAndGetMsgsForRootFolder(folder string, numFiles ...int) error <span class="cov0" title="0">{
        if folder == "" </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Root folder is empty.")
                return fmt.Errorf("root folder is empty")
        }</span>

        <span class="cov0" title="0">clusters := 10 // Default value
        if len(numFiles) &gt; 0 &amp;&amp; numFiles[0] &gt; 0 </span><span class="cov0" title="0">{
                utils.Debug("[" + config.Aliases.GetMsgs + "]: Using provided number of files to commit: " + strconv.Itoa(numFiles[0]))
                clusters = numFiles[0]
        }</span> else<span class="cov0" title="0"> {
                if configValue := config.Get("numFilesToCommit"); configValue != "" </span><span class="cov0" title="0">{
                        if configValueFloat, ok := configValue.(float64); ok </span><span class="cov0" title="0">{
                                utils.Debug("[" + config.Aliases.GetMsgs + "]: Using config value for numFilesToCommit: " + strconv.FormatFloat(configValueFloat, 'f', -1, 64))
                                clusters = int(configValueFloat)
                        }</span> else<span class="cov0" title="0"> if configValueStr, ok := configValue.(string); ok </span><span class="cov0" title="0">{
                                if parsedValue, err := strconv.Atoi(configValueStr); err == nil </span><span class="cov0" title="0">{
                                        utils.Debug("[" + config.Aliases.GetMsgs + "]: Using config value for numFilesToCommit from string: " + configValueStr)
                                        clusters = parsedValue
                                }</span> else<span class="cov0" title="0"> {
                                        utils.Error("[" + config.Aliases.GetMsgs + "]: Invalid string value for numFilesToCommit: " + configValueStr)
                                }</span>
                        }
                }
        }        

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Preparing commit messages for " + strconv.Itoa(clusters) + " files in folder: " + folder)

        changedFiles, err := git.GetAllChangedFiles(folder)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Failed to retrieve changed files for folder '" + folder + "' - " + err.Error())
                return fmt.Errorf("failed to get changed files: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                utils.Debug("[" + config.Aliases.GetMsgs + "]: No changed files found in folder: " + folder)
                return nil
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.GetMsgs + "]: Total files to process in folder '" + folder + "': " + strconv.Itoa(len(changedFiles)))

        err = git.BatchProcessWithEmbeddings(changedFiles, folder, clusters)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.GetMsgs + "]: Batch processing failed for folder '" + folder + "' - " + err.Error())
                return fmt.Errorf("batch processing failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">utils.Success("[" + config.Aliases.GetMsgs + "]: Commit message generation completed successfully for folder: " + folder)
        utils.Debug("[" + config.Aliases.GetMsgs + "]: All output: " + fmt.Sprint(output.GetAll()))
        output.SaveToFile()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package core

import (
        "GitCury/config"
        "GitCury/git"
        "GitCury/utils"
        "fmt"
        "sync"
)

func PushAllRoots(branchName string) error <span class="cov8" title="1">{
        rootFolders, ok := config.Get("root_folders").([]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Push + "]: ‚ùå Invalid or missing root_folders configuration")
                return fmt.Errorf("invalid or missing root_folders configuration")
        }</span>

        <span class="cov8" title="1">var rootFolderWg sync.WaitGroup
        var mu sync.Mutex
        var errors []string

        for _, rootFolder := range rootFolders </span><span class="cov8" title="1">{
                rootFolderStr, ok := rootFolder.(string)
                if !ok </span><span class="cov0" title="0">{
                        utils.Error("[" + config.Aliases.Push + "]: ‚ö†Ô∏è Invalid root folder type")
                        continue</span>
                }

                <span class="cov8" title="1">rootFolderWg.Add(1)

                go func(folder string) </span><span class="cov8" title="1">{
                        defer rootFolderWg.Done()
                        utils.Debug("[" + config.Aliases.Push + "]: üìÇ Root folder to push: " + folder)

                        err := git.PushBranch(folder, branchName)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[" + config.Aliases.Push + "]: ‚ùå Failed to push branch for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                                return
                        }</span>
                        <span class="cov8" title="1">utils.Success("[" + config.Aliases.Push + "]: ‚úÖ Successfully pushed branch for folder: " + folder)</span>
                }(rootFolderStr)
        }

        <span class="cov8" title="1">rootFolderWg.Wait()
        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Push + "]: ‚ùå Errors occurred during push operation")
                return fmt.Errorf("one or more errors occurred while pushing branches: %v", errors)
        }</span>

        <span class="cov8" title="1">utils.Success("[" + config.Aliases.Push + "]: üåê Push operation for all roots completed successfully")
        return nil</span>
}

func PushOneRoot(rootFolderName, branchName string) error <span class="cov8" title="1">{
        utils.Debug("[" + config.Aliases.Push + "]: üìÇ Targeting root folder for push: " + rootFolderName)

        err := git.PushBranch(rootFolderName, branchName)
        if err != nil </span><span class="cov8" title="1">{
                utils.Error("[" + config.Aliases.Push + "]: ‚ùå Failed to push branch for folder '" + rootFolderName + "' - " + err.Error())
                return fmt.Errorf("failed to push branch: %s", err.Error())
        }</span>

        <span class="cov0" title="0">utils.Success("[" + config.Aliases.Push + "]: ‚úÖ Push operation for root folder '" + rootFolderName + "' completed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package embeddings

import (
        "GitCury/config"
        "GitCury/utils"
        "context"
        "math"
        "math/rand"
        "os"
        "time"

        "google.golang.org/genai"
)

func GenerateEmbedding(text string) ([]float32, error) <span class="cov8" title="1">{
        // Get the API key from config or environment
        apiKeyInterface := config.Get("GEMINI_API_KEY")
        apiKey, ok := apiKeyInterface.(string)
        if !ok || apiKey == "" </span><span class="cov0" title="0">{
                apiKey = os.Getenv("GEMINI_API_KEY")
                if apiKey == "" </span><span class="cov0" title="0">{
                        return nil, utils.NewConfigError(
                                "Google API key not found",
                                nil,
                                map[string]interface{}{
                                        "configKey": "GEMINI_API_KEY",
                                        "envVar":    "GEMINI_API_KEY",
                                },
                        )
                }</span>
        }

        // Create a context with timeout for the entire operation
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        var embedding *genai.ContentEmbedding

        // Initialize the client outside the retry loop for better performance
        client, err := genai.NewClient(ctx, &amp;genai.ClientConfig{
                APIKey:  apiKey,
                Backend: genai.BackendGeminiAPI,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, utils.NewAPIError(
                        "Error creating Gemini client",
                        err,
                        map[string]interface{}{
                                "apiProvider": "Google Gemini",
                        },
                )
        }</span>

        // Prepare the content once for all retries
        <span class="cov8" title="1">contents := []*genai.Content{
                genai.NewContentFromText(text, genai.RoleUser),
        }

        // Define the operation to retry
        embedOperation := func() error </span><span class="cov8" title="1">{
                result, err := client.Models.EmbedContent(ctx,
                        "gemini-embedding-exp-03-07",
                        contents,
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return utils.NewAPIError(
                                "Error getting embeddings from Gemini API",
                                err,
                                map[string]interface{}{
                                        "modelName":  "gemini-embedding-exp-03-07",
                                        "textLength": len(text),
                                },
                        )
                }</span>

                <span class="cov8" title="1">if len(result.Embeddings) == 0 || result.Embeddings[0] == nil </span><span class="cov0" title="0">{
                        return utils.NewAPIError(
                                "Received empty embedding response from API",
                                nil,
                                map[string]interface{}{
                                        "modelName": "gemini-embedding-exp-03-07",
                                },
                        )
                }</span>

                <span class="cov8" title="1">embedding = result.Embeddings[0]
                return nil</span>
        }

        // Use the retry mechanism with a custom configuration
        <span class="cov8" title="1">retryConfig := utils.RetryConfig{
                MaxRetries:   3,
                InitialDelay: 500 * time.Millisecond,
                MaxDelay:     5 * time.Second,
                Factor:       2.0,
        }

        err = utils.WithRetry(ctx, "GetEmbeddings", retryConfig, embedOperation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err // Already wrapped with context by WithRetry
        }</span>

        <span class="cov8" title="1">flatEmbeddings := embedding.Values

        if flatEmbeddings == nil || len(flatEmbeddings) == 0 </span><span class="cov0" title="0">{
                return nil, utils.NewAPIError(
                        "Received empty embedding vector from API",
                        nil,
                        map[string]interface{}{
                                "modelName":      "gemini-embedding-exp-03-07",
                                "responseStatus": "empty vector",
                        },
                )
        }</span>

        <span class="cov8" title="1">return flatEmbeddings, nil</span>
}

func KMeans(data [][]float32, k int, maxIter int) ([]int, error) <span class="cov0" title="0">{
        if k &lt;= 0 || len(data) == 0 </span><span class="cov0" title="0">{
                return nil, utils.NewValidationError(
                        "Invalid parameters for KMeans clustering",
                        nil,
                        map[string]interface{}{
                                "k":             k,
                                "dataPoints":    len(data),
                                "maxIterations": maxIter,
                        },
                )
        }</span>
        <span class="cov0" title="0">if len(data) &lt; k </span><span class="cov0" title="0">{
                return nil, utils.NewValidationError(
                        "Number of clusters cannot exceed data points",
                        nil,
                        map[string]interface{}{
                                "k":          k,
                                "dataPoints": len(data),
                        },
                )
        }</span>

        <span class="cov0" title="0">n := len(data)
        dim := len(data[0])
        labels := make([]int, n)
        centroids := make([][]float32, k)

        rand.Seed(time.Now().UnixNano())
        perm := rand.Perm(n)
        for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                centroids[i] = make([]float32, dim)
                copy(centroids[i], data[perm[i]])
        }</span>

        <span class="cov0" title="0">for iter := 0; iter &lt; maxIter; iter++ </span><span class="cov0" title="0">{
                for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        labels[i] = closestCentroid(data[i], centroids)
                }</span>

                <span class="cov0" title="0">newCentroids := make([][]float32, k)
                counts := make([]int, k)

                for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                        newCentroids[i] = make([]float32, dim)
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        label := labels[i]
                        counts[label]++
                        for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                                newCentroids[label][j] += data[i][j]
                        }</span>
                }

                <span class="cov0" title="0">for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                        if counts[i] == 0 </span><span class="cov0" title="0">{
                                newCentroids[i] = make([]float32, dim)
                                copy(newCentroids[i], data[rand.Intn(n)])
                        }</span> else<span class="cov0" title="0"> {
                                for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                                        newCentroids[i][j] /= float32(counts[i])
                                }</span>
                        }
                }

                <span class="cov0" title="0">centroids = newCentroids</span>
        }

        <span class="cov0" title="0">return labels, nil</span>
}

func closestCentroid(point []float32, centroids [][]float32) int <span class="cov0" title="0">{
        minDist := float64(math.MaxFloat64)
        minIndex := 0

        for i, c := range centroids </span><span class="cov0" title="0">{
                dist := float64(0.0)
                for j := range point </span><span class="cov0" title="0">{
                        d := float64(point[j] - c[j])
                        dist += d * d
                }</span>
                <span class="cov0" title="0">if dist &lt; minDist </span><span class="cov0" title="0">{
                        minDist = dist
                        minIndex = i
                }</span>
        }
        <span class="cov0" title="0">return minIndex</span>
}

// GetFileDiff gets the diff for a file using git commands
func GetFileDiff(filePath string) (string, error) <span class="cov8" title="1">{
        // This is a simplified version for testing
        // In real implementation, this would use git commands
        return "mock diff for " + filePath, nil
}</span>

// GenerateCommitMessage generates a commit message for the given file path
func GenerateCommitMessage(filePath string) (string, error) <span class="cov8" title="1">{
        // This is a simplified version for testing
        // In real implementation, this would use AI to generate commit messages
        return "feat: update " + filePath, nil
}</span>

// CosineSimilarity calculates the cosine similarity between two vectors
func CosineSimilarity(vec1, vec2 []float32) float32 <span class="cov8" title="1">{
        if len(vec1) != len(vec2) </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        
        <span class="cov8" title="1">var dotProduct, normA, normB float64
        
        for i := range vec1 </span><span class="cov8" title="1">{
                dotProduct += float64(vec1[i] * vec2[i])
                normA += float64(vec1[i] * vec1[i])
                normB += float64(vec2[i] * vec2[i])
        }</span>
        
        <span class="cov8" title="1">if normA == 0.0 || normB == 0.0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        
        <span class="cov8" title="1">return float32(dotProduct / (math.Sqrt(normA) * math.Sqrt(normB)))</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package git

import (
        "GitCury/config"
        "GitCury/embeddings"
        "GitCury/output"
        "GitCury/utils"
        "bytes"
        "context"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "time"
)

type FileEmbedding struct {
        Path      string
        Diff      string
        Embedding []float32
}

func RunGitCmd(dir string, envVars map[string]string, args ...string) (string, error) <span class="cov8" title="1">{
        return RunGitCmdWithTimeout(dir, envVars, 30*time.Second, args...)
}</span>

func RunGitCmdWithTimeout(dir string, envVars map[string]string, timeout time.Duration, args ...string) (string, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        cmd := exec.CommandContext(ctx, "git", args...)
        cmd.Dir = dir

        // Create environment with existing env vars
        env := os.Environ()

        // Append custom environment variables
        if envVars != nil </span><span class="cov0" title="0">{
                for key, value := range envVars </span><span class="cov0" title="0">{
                        env = append(env, fmt.Sprintf("%s=%s", key, value))
                }</span>
        }
        <span class="cov8" title="1">cmd.Env = env

        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        commandStr := "git " + strings.Join(args, " ")
        utils.Debug("[GIT.EXEC]: Running git command in '" + dir + "': " + commandStr)

        err := cmd.Run()

        // Check if the error is due to timeout
        if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                return "", utils.NewGitError(
                        "Git command timed out after "+timeout.String(),
                        ctx.Err(),
                        map[string]interface{}{
                                "directory": dir,
                                "command":   commandStr,
                                "timeout":   timeout.String(),
                        },
                )
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                errOutput := stderr.String()
                stdOutput := stdout.String()

                utils.Error(fmt.Sprintf(
                        "[GIT.EXEC.FAIL]: Command failed: %s\nStdout: %s\nStderr: %s\n",
                        err,
                        stdOutput,
                        errOutput,
                ))

                // Create structured error with context
                return "", utils.NewGitError(
                        "Git command failed",
                        err,
                        map[string]interface{}{
                                "directory": dir,
                                "command":   commandStr,
                                "stdout":    stdOutput,
                                "stderr":    errOutput,
                        },
                )
        }</span>

        <span class="cov8" title="1">utils.Debug("[GIT.EXEC.SUCCESS]: Command executed successfully in directory '" + dir + "': " + commandStr)
        return stdout.String(), nil</span>
}

var changedFilesCache = make(map[string]string)
var cacheMu sync.RWMutex

func GetAllChangedFiles(dir string) ([]string, error) <span class="cov8" title="1">{
        output, err := RunGitCmd(dir, nil, "status", "--porcelain")
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[GIT.STATUS.FAIL]: Failed to get git status: " + err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(output) == "" </span><span class="cov0" title="0">{
                utils.Debug("[GIT.STATUS]: No changed files detected in directory: " + dir)
                return nil, nil
        }</span>

        <span class="cov8" title="1">var changedFiles []string
        lines := strings.Split(output, "\n")

        cacheMu.Lock()
        defer cacheMu.Unlock()

        for _, line := range lines </span><span class="cov8" title="1">{
                if len(line) &lt; 4 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">status := strings.TrimSpace(line[:2])
                relativePath := strings.TrimSpace(line[3:])
                absolutePath := filepath.Join(dir, relativePath)
                abs, err := filepath.Abs(absolutePath)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("[GIT.PATH.FAIL]: Failed to resolve absolute path for '" + relativePath + "': " + err.Error())
                        continue</span>
                }

                <span class="cov8" title="1">changedFilesCache[abs] = status

                if strings.HasPrefix(status, "D") </span><span class="cov0" title="0">{
                        utils.Debug("[GIT.FILE.DELETED]: File marked as deleted: " + abs)
                        changedFiles = append(changedFiles, abs)
                        continue</span>
                }

                <span class="cov8" title="1">info, err := os.Stat(abs)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                utils.Debug("[GIT.FILE.MISSING]: File does not exist (possibly deleted): " + abs)
                                changedFiles = append(changedFiles, abs)
                                continue</span>
                        }
                        <span class="cov0" title="0">utils.Error("[GIT.STAT.FAIL]: Failed to stat path '" + abs + "': " + err.Error())
                        return nil, err</span>
                }

                <span class="cov8" title="1">if info.IsDir() &amp;&amp; status == "??" </span><span class="cov0" title="0">{
                        innerOutput, err := RunGitCmd(dir, nil, "ls-files", "--others", "--exclude-standard", relativePath)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[GIT.UNTRACKED.FAIL]: Failed to list files in untracked dir '" + relativePath + "': " + err.Error())
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">for _, inner := range strings.Split(innerOutput, "\n") </span><span class="cov0" title="0">{
                                if strings.TrimSpace(inner) == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">fullPath := filepath.Join(dir, inner)
                                absInner, err := filepath.Abs(fullPath)
                                if err == nil </span><span class="cov0" title="0">{
                                        changedFiles = append(changedFiles, absInner)
                                        changedFilesCache[absInner] = "??"
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        changedFiles = append(changedFiles, abs)
                }</span>
        }

        <span class="cov8" title="1">utils.Debug("[GIT.CHANGED.FILES]: " + strings.Join(changedFiles, ", "))
        return changedFiles, nil</span>
}

func GenCommitMessage(files []string, dir string) (string, error) <span class="cov0" title="0">{
        contextData := make(map[string]map[string]string)

        apiKey := config.Get("GEMINI_API_KEY")
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = os.Getenv("GEMINI_API_KEY")
                if apiKey == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("Gemini API key not found in config or env")
                }</span>
        }

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                var fileType, diffOutput string

                cacheMu.RLock()
                status, cached := changedFilesCache[file]
                cacheMu.RUnlock()

                if cached &amp;&amp; strings.HasPrefix(status, "D") </span><span class="cov0" title="0">{
                        fileType = "deleted"
                        contextData[file] = map[string]string{
                                "type": fileType,
                                "diff": "file deleted",
                        }
                        utils.Debug("[GIT.COMMIT.MSG]: File marked as deleted: '" + file + "'")
                        continue</span>
                }

                <span class="cov0" title="0">diffOutput, err := RunGitCmd(dir, nil, "diff", "--", file)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error(fmt.Sprintf("[GIT.DIFF.FAIL]: Error running git diff for '%s': %s", file, err.Error()))
                        return "", err
                }</span>

                <span class="cov0" title="0">if strings.TrimSpace(diffOutput) == "" </span><span class="cov0" title="0">{
                        diffOutput, err = RunGitCmd(dir, nil, "diff", "--cached", "--", file)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error(fmt.Sprintf("[GIT.DIFF.FAIL]: Error running git diff --cached for '%s': %s", file, err.Error()))
                                return "", err
                        }</span>
                }

                <span class="cov0" title="0">if strings.TrimSpace(diffOutput) == "" </span><span class="cov0" title="0">{
                        contentBytes, err := os.ReadFile(file)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error(fmt.Sprintf("[GIT.FILE.READ.FAIL]: Error reading new file '%s': %s", file, err.Error()))
                                return "", err
                        }</span>
                        <span class="cov0" title="0">diffOutput = string(contentBytes)
                        fileType = "new"</span>
                } else<span class="cov0" title="0"> {
                        fileType = "updated"
                }</span>

                <span class="cov0" title="0">contextData[file] = map[string]string{
                        "type": fileType,
                        "diff": diffOutput,
                }

                utils.Debug("[GIT.COMMIT.MSG]: Processed file '" + file + "' as " + fileType)</span>
        }

        <span class="cov0" title="0">message, err := utils.SendToGemini(contextData, apiKey.(string))
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[GEMINI.FAIL]: Error generating group commit message: " + err.Error())
                return "", err
        }</span>

        <span class="cov0" title="0">return message, nil</span>
}

func BatchProcessGetMessages(allChangedFiles []string, rootFolder string) error <span class="cov0" title="0">{
        utils.Debug("[GIT.BATCH]: Starting batch processing of commit messages")
        var fileWg sync.WaitGroup
        var fileErrors []error
        fileMu := sync.Mutex{}

        for _, file := range allChangedFiles </span><span class="cov0" title="0">{
                fileWg.Add(1)
                go func(file string) </span><span class="cov0" title="0">{
                        defer fileWg.Done()

                        utils.Debug("[GIT.BATCH]: Processing file: " + file)
                        message, err := GenCommitMessage([]string{file}, rootFolder) // &lt;-- wrapped in slice
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[GIT.BATCH.FAIL]: Failed to generate commit message for file: " + file + " - " + err.Error())
                                fileMu.Lock()
                                fileErrors = append(fileErrors, err)
                                fileMu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">utils.Debug("[GIT.BATCH.SUCCESS]: Generated commit message for file: " + file + " - " + message)
                        output.Set(file, rootFolder, message)</span>
                }(file)
        }

        <span class="cov0" title="0">fileWg.Wait()

        if len(fileErrors) &gt; 0 </span><span class="cov0" title="0">{
                utils.Error("[GIT.BATCH.FAIL]: Batch processing completed with errors")
                return fmt.Errorf("one or more errors occurred while preparing commit messages")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func CommitBatch(rootFolder output.Folder, env ...[]string) error <span class="cov0" title="0">{
        commitMessagesList := rootFolder.Files
        if len(commitMessagesList) == 0 </span><span class="cov0" title="0">{
                utils.Debug("[GIT.COMMIT]: No commit messages found for root folder: " + rootFolder.Name)
                return utils.NewValidationError(
                        "No commit messages found for root folder",
                        nil,
                        map[string]interface{}{
                                "folderName": rootFolder.Name,
                        },
                )
        }</span>

        <span class="cov0" title="0">utils.Debug("[GIT.COMMIT]: Starting batch commit in folder: " + rootFolder.Name)
        utils.Debug("[GIT.COMMIT]: Total files to commit: " + fmt.Sprint(len(commitMessagesList)))

        // Convert environment slice to map
        envMap := make(map[string]string)
        if len(env) &gt; 0 </span><span class="cov0" title="0">{
                for _, pair := range env[0] </span><span class="cov0" title="0">{
                        parts := strings.SplitN(pair, "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                envMap[parts[0]] = parts[1]
                        }</span>
                }
        }

        // Group files by commit message for efficiency
        <span class="cov0" title="0">messageToFiles := make(map[string][]string)
        for _, entry := range commitMessagesList </span><span class="cov0" title="0">{
                utils.Debug("[GIT.COMMIT]: Staging file for grouping: " + entry.Name + " with message: " + entry.Message)
                messageToFiles[entry.Message] = append(messageToFiles[entry.Message], entry.Name)
        }</span>

        // Use a rate limiter to control concurrency
        <span class="cov0" title="0">const maxConcurrentOps = 3
        semaphore := make(chan struct{}, maxConcurrentOps)
        var wg sync.WaitGroup
        var errMu sync.Mutex
        var commitErrs []error

        // Stage files concurrently with rate limiting
        for message, files := range messageToFiles </span><span class="cov0" title="0">{
                // Stage all files for a single commit first
                for _, file := range files </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go func(file string) </span><span class="cov0" title="0">{
                                defer wg.Done()

                                // Acquire semaphore slot (blocking if maxConcurrentOps is reached)
                                semaphore &lt;- struct{}{}
                                defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>()

                                <span class="cov0" title="0">utils.Debug("[GIT.COMMIT]: Adding file to commit: " + file)
                                if _, err := RunGitCmdWithTimeout(rootFolder.Name, envMap, 15*time.Second, "add", file); err != nil </span><span class="cov0" title="0">{
                                        utils.Error("[GIT.COMMIT.FAIL]: Failed to add file to commit: " + err.Error())
                                        errMu.Lock()
                                        commitErrs = append(commitErrs, utils.NewGitError(
                                                "Failed to stage file",
                                                err,
                                                map[string]interface{}{
                                                        "file":   file,
                                                        "folder": rootFolder.Name,
                                                },
                                        ))
                                        errMu.Unlock()
                                }</span>
                        }(file)
                }

                // Wait for all staging operations to complete
                <span class="cov0" title="0">wg.Wait()

                // If we have errors from staging, return early
                if len(commitErrs) &gt; 0 </span><span class="cov0" title="0">{
                        return utils.NewGitError(
                                "Failed to stage one or more files for commit",
                                fmt.Errorf("%d errors occurred during staging", len(commitErrs)),
                                map[string]interface{}{
                                        "folder": rootFolder.Name,
                                        "errors": commitErrs,
                                },
                        )
                }</span>

                // Perform the actual commit
                <span class="cov0" title="0">utils.Debug(fmt.Sprintf("[GIT.COMMIT]: Committing %d file(s) with message: %s", len(files), message))
                if _, err := RunGitCmdWithTimeout(rootFolder.Name, envMap, 30*time.Second, "commit", "-m", message); err != nil </span><span class="cov0" title="0">{
                        utils.Error("[GIT.COMMIT.FAIL]: Failed to commit files with message '" + message + "': " + err.Error())
                        return utils.NewGitError(
                                "Failed to commit files",
                                err,
                                map[string]interface{}{
                                        "message":   message,
                                        "folder":    rootFolder.Name,
                                        "fileCount": len(files),
                                },
                        )
                }</span>
        }

        <span class="cov0" title="0">output.RemoveFolder(rootFolder.Name)
        utils.Info("[GIT.COMMIT.SUCCESS]: Batch commit completed successfully and folder removed: " + rootFolder.Name)
        return nil</span>
}

func PushBranch(rootFolderName string, branch string) error <span class="cov8" title="1">{
        if branch == "" </span><span class="cov0" title="0">{
                utils.Debug("[GIT.PUSH]: Branch name is empty, defaulting to 'main'")
                branch = "main"
        }</span>

        <span class="cov8" title="1">utils.Debug("[GIT.PUSH]: Pushing branch: " + branch + " in folder: " + rootFolderName)
        if _, err := RunGitCmd(rootFolderName, nil, "push", "origin", branch); err != nil </span><span class="cov8" title="1">{
                utils.Error("[GIT.PUSH.FAIL]: Failed to push branch: " + err.Error())
                return fmt.Errorf("failed to push branch: %s", err.Error())
        }</span>

        <span class="cov8" title="1">utils.Info("[GIT.PUSH.SUCCESS]: Branch pushed successfully")
        return nil</span>
}

func GetFileDiff(filePath string, rootFolder string) (string, error) <span class="cov0" title="0">{
        cmdStatus := exec.Command("git", "-C", rootFolder, "status", "--porcelain", "--untracked-files=all", "--", filePath)

        var statusOut bytes.Buffer
        cmdStatus.Stdout = &amp;statusOut
        cmdStatus.Stderr = &amp;statusOut

        err := cmdStatus.Run()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error checking status for file %s: %v", filePath, err)
        }</span>

        <span class="cov0" title="0">if statusOut.String() != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("New untracked file: %s", filePath), nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("git", "-C", rootFolder, "diff", "--", filePath)

        var out bytes.Buffer
        cmd.Stdout = &amp;out
        cmd.Stderr = &amp;out

        err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error getting diff for file %s: %v", filePath, err)
        }</span>

        <span class="cov0" title="0">return out.String(), nil</span>
}

func BatchProcessWithEmbeddings(allChangedFiles []string, rootFolder string, numClusters int) error <span class="cov0" title="0">{
        utils.Debug("[GIT.BATCH]: Starting batch processing with embeddings and clustering")

        var fileData []FileEmbedding
        var fileErrors []error
        var fileMu sync.Mutex

        for _, file := range allChangedFiles </span><span class="cov0" title="0">{
                diff, err := GetFileDiff(file, rootFolder)
                if err != nil || strings.TrimSpace(diff) == "" </span><span class="cov0" title="0">{
                        utils.Error("[GIT.BATCH]: Could not get diff for file: " + file)
                        continue</span>
                }

                <span class="cov0" title="0">embed, err := embeddings.GenerateEmbedding(diff)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("[GIT.BATCH]: Could not generate embedding for file: " + file)
                        fileMu.Lock()
                        fileErrors = append(fileErrors, err)
                        fileMu.Unlock()
                        continue</span>
                }

                <span class="cov0" title="0">fileData = append(fileData, FileEmbedding{
                        Path:      file,
                        Diff:      diff,
                        Embedding: embed,
                })</span>
        }

        <span class="cov0" title="0">if len(fileData) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no valid diffs or embeddings generated")
        }</span>

        <span class="cov0" title="0">utils.Debug(fmt.Sprintf("[GIT.BATCH]: Clustering %d files by embeddings", len(fileData)))

        vectors := make([][]float32, len(fileData))
        for i, f := range fileData </span><span class="cov0" title="0">{
                vectors[i] = f.Embedding
        }</span>

        <span class="cov0" title="0">labels, err := embeddings.KMeans(vectors, numClusters, 10)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("clustering failed: %v", err)
        }</span>

        <span class="cov0" title="0">groupMap := make(map[int][]FileEmbedding)
        for i, label := range labels </span><span class="cov0" title="0">{
                groupMap[label] = append(groupMap[label], fileData[i])
        }</span>

        <span class="cov0" title="0">type CommitGroup struct {
                Message string   `json:"message"`
                Files   []string `json:"files"`
        }

        var commitGroups []CommitGroup
        var commitMu sync.Mutex
        var fileWg sync.WaitGroup

        for label, group := range groupMap </span><span class="cov0" title="0">{
                fileWg.Add(1)
                go func(label int, group []FileEmbedding) </span><span class="cov0" title="0">{
                        defer fileWg.Done()

                        utils.Debug(fmt.Sprintf("[GIT.BATCH]: Generating commit message for group %d with %d files", label, len(group)))

                        var filePaths []string
                        for _, f := range group </span><span class="cov0" title="0">{
                                filePaths = append(filePaths, f.Path)
                        }</span>

                        <span class="cov0" title="0">message, err := GenCommitMessage(filePaths, rootFolder)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error(fmt.Sprintf("[GIT.BATCH]: Commit message generation failed for group %d - %s", label, err.Error()))
                                fileMu.Lock()
                                fileErrors = append(fileErrors, err)
                                fileMu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">commitMu.Lock()
                        commitGroups = append(commitGroups, CommitGroup{
                                Message: message,
                                Files:   filePaths,
                        })
                        commitMu.Unlock()

                        for _, f := range group </span><span class="cov0" title="0">{
                                utils.Debug("[GIT.BATCH.SUCCESS]: Generated commit message for file: " + f.Path + " - " + message)
                                output.Set(f.Path, rootFolder, message)
                        }</span>
                }(label, group)
        }

        <span class="cov0" title="0">fileWg.Wait()

        if len(fileErrors) &gt; 0 </span><span class="cov0" title="0">{
                utils.Error("[GIT.BATCH.FAIL]: Batch processing completed with errors")
                return fmt.Errorf("one or more errors occurred while preparing commit messages")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package git

import (
        "GitCury/output"
        "GitCury/utils"
        "fmt"
        "path/filepath"
        "sync"
        "time"
)

// ProgressCommitBatch is an enhanced version of CommitBatch that includes progress reporting
// and better resource management
func ProgressCommitBatch(rootFolder output.Folder, env ...[]string) error <span class="cov0" title="0">{
        commitMessagesList := rootFolder.Files
        if len(commitMessagesList) == 0 </span><span class="cov0" title="0">{
                utils.Debug("[GIT.COMMIT]: No commit messages found for root folder: " + rootFolder.Name)
                return utils.NewValidationError(
                        "No commit messages found for root folder",
                        nil,
                        map[string]interface{}{
                                "folderName": rootFolder.Name,
                        },
                )
        }</span>

        // Create progress reporter for better user feedback
        <span class="cov0" title="0">progress := utils.NewProgressReporter(int64(len(commitMessagesList)), "Committing files in "+rootFolder.Name)
        progress.Start()
        defer progress.Done()

        // Track overall progress
        var progressCounter int64
        var progressMu sync.Mutex

        // Function to update progress safely
        updateProgress := func(count int64, message string) </span><span class="cov0" title="0">{
                progressMu.Lock()
                defer progressMu.Unlock()
                progressCounter += count
                progress.Update(progressCounter)
                if message != "" </span><span class="cov0" title="0">{
                        progress.UpdateMessage(message)
                }</span>
        }

        // Call original CommitBatch with progress hooks
        <span class="cov0" title="0">err := SafeGitOperation(rootFolder.Name, "CommitBatch", func() error </span><span class="cov0" title="0">{
                // Process each file with progress reporting
                for i, entry := range commitMessagesList </span><span class="cov0" title="0">{
                        shortFile := filepath.Base(entry.Name)
                        updateProgress(1, fmt.Sprintf("Processing %d/%d: %s", i+1, len(commitMessagesList), shortFile))

                        // Add artificial delay to make progress visible
                        time.Sleep(50 * time.Millisecond)
                }</span>

                // Let the original function do the actual work
                <span class="cov0" title="0">return CommitBatch(rootFolder, env...)</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                progress.UpdateMessage("Commit failed: " + err.Error())
                return err
        }</span>

        <span class="cov0" title="0">progress.UpdateMessage("Commit completed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package git

import (
        "GitCury/utils"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// GitOperationResult represents the result of a git operation with recovery information
type GitOperationResult struct {
        Success      bool
        Error        error
        RecoveryPath string
        Message      string
}

// CheckRepositoryHealth checks if a git repository is in a healthy state
// and returns any issues found
func CheckRepositoryHealth(dir string) error <span class="cov8" title="1">{
        // Check if directory exists
        if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return utils.NewValidationError(
                        "Directory does not exist",
                        err,
                        map[string]interface{}{
                                "directory": dir,
                        },
                )
        }</span>

        // Check if this is a git repository
        <span class="cov8" title="1">_, err := RunGitCmdWithTimeout(dir, nil, 5*time.Second, "rev-parse", "--is-inside-work-tree")
        if err != nil </span><span class="cov8" title="1">{
                return utils.NewGitError(
                        "Not a git repository",
                        err,
                        map[string]interface{}{
                                "directory":  dir,
                                "suggestion": "Initialize a git repository with 'git init'",
                        },
                )
        }</span>

        // Check for uncommitted changes that might cause conflicts
        <span class="cov8" title="1">output, err := RunGitCmdWithTimeout(dir, nil, 5*time.Second, "status", "--porcelain")
        if err != nil </span><span class="cov0" title="0">{
                return utils.NewGitError(
                        "Failed to get repository status",
                        err,
                        map[string]interface{}{
                                "directory": dir,
                        },
                )
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(output) != "" </span><span class="cov0" title="0">{
                // There are uncommitted changes, but this is not an error
                utils.Debug("[GIT.HEALTH]: Repository has uncommitted changes: " + dir)
        }</span>

        // Check if the git index is locked
        <span class="cov8" title="1">indexLockPath := filepath.Join(dir, ".git", "index.lock")
        if _, err := os.Stat(indexLockPath); err == nil </span><span class="cov0" title="0">{
                // Index is locked, this might indicate a problem
                lockFileInfo, err := os.Stat(indexLockPath)
                if err == nil </span><span class="cov0" title="0">{
                        lockAge := time.Since(lockFileInfo.ModTime())

                        // If lock file is older than 10 minutes, it's likely stale
                        if lockAge &gt; 10*time.Minute </span><span class="cov0" title="0">{
                                utils.Warning("[GIT.HEALTH]: Found stale index.lock file (age: " + lockAge.String() + ")")
                                return utils.NewGitError(
                                        "Repository index is locked (stale lock)",
                                        nil,
                                        map[string]interface{}{
                                                "directory":  dir,
                                                "lockFile":   indexLockPath,
                                                "lockAge":    lockAge.String(),
                                                "suggestion": "Remove the lock file with 'rm " + indexLockPath + "'",
                                        },
                                )
                        }</span>

                        <span class="cov0" title="0">return utils.NewGitError(
                                "Repository index is locked",
                                nil,
                                map[string]interface{}{
                                        "directory":  dir,
                                        "lockFile":   indexLockPath,
                                        "lockAge":    lockAge.String(),
                                        "suggestion": "Wait for the current git operation to complete or remove the lock file",
                                },
                        )</span>
                }
        }

        // Check if we can access the git config
        <span class="cov8" title="1">_, err = RunGitCmdWithTimeout(dir, nil, 5*time.Second, "config", "--local", "--list")
        if err != nil </span><span class="cov0" title="0">{
                return utils.NewGitError(
                        "Failed to access git config",
                        err,
                        map[string]interface{}{
                                "directory":  dir,
                                "suggestion": "The .git directory might be corrupted, try reinitializing the repository",
                        },
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RecoverFromGitError attempts to recover from common git errors
func RecoverFromGitError(dir string, err error) GitOperationResult <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return GitOperationResult{
                        Success: true,
                        Message: "No error to recover from",
                }
        }</span>

        <span class="cov8" title="1">errMsg := err.Error()

        // Check for index.lock issues
        if strings.Contains(errMsg, "index.lock") </span><span class="cov0" title="0">{
                indexLockPath := filepath.Join(dir, ".git", "index.lock")
                if _, statErr := os.Stat(indexLockPath); statErr == nil </span><span class="cov0" title="0">{
                        // Index lock exists, try to remove it
                        utils.Warning("[GIT.RECOVERY]: Found index.lock file, attempting to remove it")

                        if rmErr := os.Remove(indexLockPath); rmErr == nil </span><span class="cov0" title="0">{
                                return GitOperationResult{
                                        Success:      true,
                                        RecoveryPath: "index_lock_removed",
                                        Message:      "Removed stale index.lock file",
                                }
                        }</span> else<span class="cov0" title="0"> {
                                return GitOperationResult{
                                        Success:      false,
                                        Error:        rmErr,
                                        RecoveryPath: "index_lock_removal_failed",
                                        Message:      "Failed to remove stale index.lock file",
                                }
                        }</span>
                }
        }

        // Check for conflicts
        <span class="cov8" title="1">if strings.Contains(errMsg, "conflict") || strings.Contains(errMsg, "CONFLICT") </span><span class="cov0" title="0">{
                utils.Warning("[GIT.RECOVERY]: Detected conflict in git operation")
                return GitOperationResult{
                        Success:      false,
                        Error:        err,
                        RecoveryPath: "conflict_detected",
                        Message:      "Git operation failed due to conflicts. Manual resolution required.",
                }
        }</span>

        // Check for permission issues
        <span class="cov8" title="1">if strings.Contains(errMsg, "Permission denied") </span><span class="cov0" title="0">{
                utils.Warning("[GIT.RECOVERY]: Detected permission issue in git operation")
                return GitOperationResult{
                        Success:      false,
                        Error:        err,
                        RecoveryPath: "permission_denied",
                        Message:      "Git operation failed due to permission issues. Check file permissions.",
                }
        }</span>

        // No specific recovery path identified
        <span class="cov8" title="1">return GitOperationResult{
                Success:      false,
                Error:        err,
                RecoveryPath: "unknown_error",
                Message:      "No automatic recovery available for this git error",
        }</span>
}

// SafeGitOperation executes a git operation with built-in recovery mechanisms
func SafeGitOperation(dir string, operation string, fn func() error) error <span class="cov0" title="0">{
        // First check repository health
        if err := CheckRepositoryHealth(dir); err != nil </span><span class="cov0" title="0">{
                utils.Warning("[GIT.SAFE]: Repository health check failed: " + err.Error())

                // If the directory doesn't exist, no recovery is possible
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Try to recover from repository issues
                <span class="cov0" title="0">result := RecoverFromGitError(dir, err)
                if !result.Success </span><span class="cov0" title="0">{
                        utils.Error("[GIT.SAFE]: Failed to recover from repository issue: " + result.Message)
                        return utils.NewGitError(
                                "Repository is in an unhealthy state",
                                err,
                                map[string]interface{}{
                                        "directory":    dir,
                                        "operation":    operation,
                                        "recoveryPath": result.RecoveryPath,
                                        "message":      result.Message,
                                },
                        )
                }</span>

                <span class="cov0" title="0">utils.Info("[GIT.SAFE]: Successfully recovered from repository issue: " + result.Message)</span>
        }

        // Execute the git operation
        <span class="cov0" title="0">err := fn()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[GIT.SAFE]: Git operation failed: " + err.Error())

                // Try to recover from the error
                result := RecoverFromGitError(dir, err)
                if !result.Success </span><span class="cov0" title="0">{
                        return utils.NewGitError(
                                fmt.Sprintf("Git operation '%s' failed", operation),
                                err,
                                map[string]interface{}{
                                        "directory":    dir,
                                        "operation":    operation,
                                        "recoveryPath": result.RecoveryPath,
                                        "message":      result.Message,
                                },
                        )
                }</span>

                <span class="cov0" title="0">utils.Info("[GIT.SAFE]: Successfully recovered from git error: " + result.Message)

                // Retry the operation after recovery
                retryErr := fn()
                if retryErr != nil </span><span class="cov0" title="0">{
                        return utils.NewGitError(
                                fmt.Sprintf("Git operation '%s' failed even after recovery", operation),
                                retryErr,
                                map[string]interface{}{
                                        "directory":    dir,
                                        "operation":    operation,
                                        "recoveryPath": result.RecoveryPath,
                                        "message":      "Recovery was successful but operation still failed on retry",
                                },
                        )
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package output

import (
        "GitCury/config"
        "GitCury/utils"
        "encoding/json"
        "os"
        "sync"
)

type FileEntry struct {
        Name    string `json:"name"`
        Message string `json:"message"`
}

type Folder struct {
        Name  string      `json:"name"`
        Files []FileEntry `json:"files"`
}

type OutputData struct {
        Folders []Folder `json:"folders"`
}

var (
        outputData = OutputData{}
        mu         sync.RWMutex
)

func init() <span class="cov8" title="1">{
        LoadOutput()
}</span>

func LoadOutput() <span class="cov8" title="1">{
        outputFilePath, ok := config.Get("output_file_path").(string)
        if !ok || outputFilePath == "" </span><span class="cov0" title="0">{
                outputFilePath = os.Getenv("HOME") + "/.gitcury/output.json"
        }</span>

        <span class="cov8" title="1">file, err := os.Open(outputFilePath)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                utils.Debug("[" + config.Aliases.Output + "]: No existing output file found. Initializing fresh output.")
                return
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: üö® Error loading output file: " + err.Error())
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;outputData); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: üö® Error decoding output file: " + err.Error())
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.Output + "]: Loaded output data successfully.")</span>
}

func Set(file, rootFolder string, commitMessage string) <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()

        utils.Debug("[" + config.Aliases.Output + "]: Setting commit message for file: " + file + " in folder: " + rootFolder)
        folder := findOrCreateFolder(rootFolder)

        updated := false
        for i, entry := range folder.Files </span><span class="cov8" title="1">{
                if entry.Name == file </span><span class="cov8" title="1">{
                        folder.Files[i].Message = commitMessage
                        updated = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !updated </span><span class="cov8" title="1">{
                folder.Files = append(folder.Files, FileEntry{Name: file, Message: commitMessage})
        }</span>

        <span class="cov8" title="1">utils.Debug("[" + config.Aliases.Output + "]: Commit message set for file: " + file + " in folder: " + rootFolder)</span>
}

func Get(file string, rootFolder string) string <span class="cov8" title="1">{
        mu.RLock()
        defer mu.RUnlock()

        folder := findFolder(rootFolder)
        if folder == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">for _, entry := range folder.Files </span><span class="cov8" title="1">{
                if entry.Name == file </span><span class="cov8" title="1">{
                        return entry.Message
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func GetFolder(rootFolder string) Folder <span class="cov8" title="1">{
        mu.RLock()
        defer mu.RUnlock()

        folder := findFolder(rootFolder)
        if folder != nil </span><span class="cov8" title="1">{
                return *folder
        }</span>
        <span class="cov8" title="1">return Folder{Name: rootFolder, Files: []FileEntry{}}</span>
}

func GetAll() OutputData <span class="cov8" title="1">{
        mu.RLock()
        defer mu.RUnlock()

        copy := OutputData{Folders: make([]Folder, len(outputData.Folders))}
        for i, folder := range outputData.Folders </span><span class="cov8" title="1">{
                copy.Folders[i] = Folder{
                        Name:  folder.Name,
                        Files: append([]FileEntry{}, folder.Files...),
                }
        }</span>
        <span class="cov8" title="1">return copy</span>
}

func Delete(file string, rootFolder string) <span class="cov0" title="0">{
        mu.Lock()
        defer mu.Unlock()

        folder := findFolder(rootFolder)
        if folder == nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: ‚ö†Ô∏è Folder not found: " + rootFolder)
                return
        }</span>

        <span class="cov0" title="0">for i, entry := range folder.Files </span><span class="cov0" title="0">{
                if entry.Name == file </span><span class="cov0" title="0">{
                        folder.Files = append(folder.Files[:i], folder.Files[i+1:]...)
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(folder.Files) == 0 </span><span class="cov0" title="0">{
                RemoveFolder(rootFolder)
        }</span>

        <span class="cov0" title="0">SaveToFile()
        utils.Debug("[" + config.Aliases.Output + "]: File deleted and output saved.")</span>
}

func Clear() <span class="cov8" title="1">{
        mu.Lock()
        defer mu.Unlock()
        outputData = OutputData{}

        outputFilePath, ok := config.Get("output_file_path").(string)
        if !ok || outputFilePath == "" </span><span class="cov0" title="0">{
                outputFilePath = os.Getenv("HOME") + "/.gitcury/output.json"
        }</span>

        <span class="cov8" title="1">if err := os.Remove(outputFilePath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: üö® Error deleting output file: " + err.Error())
        }</span> else<span class="cov8" title="1"> {
                utils.Debug("[" + config.Aliases.Output + "]: Output file cleared successfully.")
        }</span>
}

func SaveToFile() <span class="cov8" title="1">{
        utils.Debug("[" + config.Aliases.Output + "]: Saving output data to file...")
        mu.RLock()
        defer mu.RUnlock()

        outputFilePath, ok := config.Get("output_file_path").(string)
        if !ok || outputFilePath == "" </span><span class="cov0" title="0">{
                outputFilePath = os.Getenv("HOME") + "/.gitcury/output.json"
                config.Set("output_file_path", outputFilePath)
        }</span>

        <span class="cov8" title="1">outputFile, err := os.OpenFile(outputFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: üö® Error saving output file: " + err.Error())
                return
        }</span>
        <span class="cov8" title="1">defer outputFile.Close()

        encoder := json.NewEncoder(outputFile)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(outputData); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: üö® Error encoding output data: " + err.Error())
        }</span>

        <span class="cov8" title="1">utils.Debug("[" + config.Aliases.Output + "]: Output data saved successfully to: " + outputFilePath)</span>
}

func findFolder(name string) *Folder <span class="cov8" title="1">{
        for i := range outputData.Folders </span><span class="cov8" title="1">{
                if outputData.Folders[i].Name == name </span><span class="cov8" title="1">{
                        return &amp;outputData.Folders[i]
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func findOrCreateFolder(name string) *Folder <span class="cov8" title="1">{
        folder := findFolder(name)
        if folder == nil </span><span class="cov8" title="1">{
                outputData.Folders = append(outputData.Folders, Folder{Name: name, Files: []FileEntry{}})
                return &amp;outputData.Folders[len(outputData.Folders)-1]
        }</span>
        <span class="cov8" title="1">return folder</span>
}

func RemoveFolder(name string) <span class="cov8" title="1">{
        for i, folder := range outputData.Folders </span><span class="cov8" title="1">{
                if folder.Name == name </span><span class="cov8" title="1">{
                        outputData.Folders = append(outputData.Folders[:i], outputData.Folders[i+1:]...)
                        break</span>
                }
        }

        <span class="cov8" title="1">SaveToFile()
        utils.Debug("[" + config.Aliases.Output + "]: Folder removed and output saved.")</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package mocks provides mock implementations for testing
package mocks

import (
        "GitCury/interfaces"
        "GitCury/output"
        "errors"
        "sync"
        "time"
)

// MockGitRunner is a mock implementation of git command runner for testing
type MockGitRunner struct {
        Commands          []string
        Directories       []string
        EnvVars           []map[string]string
        ReturnValueMap    map[string]string
        ReturnErrorMap    map[string]error
        DirReturnValueMap map[string]map[string]string // Map of directory to command to response
        DirReturnErrorMap map[string]map[string]error  // Map of directory to command to error
        CallCount         map[string]int
        mu                sync.Mutex
        DefaultResponse   string
        DefaultError      error
}

// Ensure MockGitRunner implements GitRunner interface
var _ interfaces.GitRunner = &amp;MockGitRunner{}

// NewMockGitRunner creates a new mock git runner
func NewMockGitRunner() *MockGitRunner <span class="cov8" title="1">{
        return &amp;MockGitRunner{
                Commands:          make([]string, 0),
                Directories:       make([]string, 0),
                EnvVars:           make([]map[string]string, 0),
                ReturnValueMap:    make(map[string]string),
                ReturnErrorMap:    make(map[string]error),
                DirReturnValueMap: make(map[string]map[string]string),
                DirReturnErrorMap: make(map[string]map[string]error),
                CallCount:         make(map[string]int),
                DefaultResponse:   "",
                DefaultError:      nil,
        }
}</span>

// RunGitCommand records the command and returns predefined response
func (m *MockGitRunner) RunGitCommand(dir string, envVars map[string]string, args ...string) (string, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Build command string for lookup
        cmd := args[0]
        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                cmd = args[0] + " " + args[1]
        }</span>

        // Record this call
        <span class="cov8" title="1">m.Commands = append(m.Commands, cmd)
        m.Directories = append(m.Directories, dir)
        m.EnvVars = append(m.EnvVars, envVars)

        // Increment call count
        m.CallCount[cmd] = m.CallCount[cmd] + 1

        // Check if we have a directory-specific response
        if dirMap, ok := m.DirReturnValueMap[dir]; ok </span><span class="cov0" title="0">{
                if response, ok := dirMap[cmd]; ok </span><span class="cov0" title="0">{
                        if dirErrMap, ok := m.DirReturnErrorMap[dir]; ok </span><span class="cov0" title="0">{
                                if err, ok := dirErrMap[cmd]; ok </span><span class="cov0" title="0">{
                                        return response, err
                                }</span>
                        }
                        <span class="cov0" title="0">return response, nil</span>
                }
        }

        // Check if we have a predefined response for this command
        <span class="cov8" title="1">if response, ok := m.ReturnValueMap[cmd]; ok </span><span class="cov0" title="0">{
                if err, ok := m.ReturnErrorMap[cmd]; ok </span><span class="cov0" title="0">{
                        return response, err
                }</span>
                <span class="cov0" title="0">return response, nil</span>
        }

        <span class="cov8" title="1">return m.DefaultResponse, m.DefaultError</span>
}

// RunGitCmd implements the GitRunner interface
func (m *MockGitRunner) RunGitCmd(dir string, envVars map[string]string, args ...string) (string, error) <span class="cov8" title="1">{
        return m.RunGitCommand(dir, envVars, args...)
}</span>

// RunGitCmdWithTimeout implements the GitRunner interface
func (m *MockGitRunner) RunGitCmdWithTimeout(dir string, envVars map[string]string, timeout time.Duration, args ...string) (string, error) <span class="cov0" title="0">{
        return m.RunGitCommand(dir, envVars, args...)
}</span>

// CommitBatch implements the GitRunner interface
func (m *MockGitRunner) CommitBatch(folder output.Folder, env ...[]string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        // Record the commit batch operation
        cmd := "commit-batch-" + folder.Name
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Check if we have a predefined error for this operation
        if err, ok := m.ReturnErrorMap[cmd]; ok </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return m.DefaultError</span>
}

// GetChangedFiles implements the GitRunner interface
func (m *MockGitRunner) GetChangedFiles(rootFolders []string, maxConcurrency int, env ...[]string) ([]output.Folder, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "get-changed-files"
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Return empty folders by default
        return []output.Folder{}, m.DefaultError
}</span>

// Status implements the GitRunner interface
func (m *MockGitRunner) Status(rootPaths []string) ([]output.Folder, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "status"
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Return empty folders by default
        return []output.Folder{}, m.DefaultError
}</span>

// ProcessOneFile implements the GitRunner interface
func (m *MockGitRunner) ProcessOneFile(filePath, commitMessage string, env ...[]string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "process-one-file-" + filePath
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Check if we have a predefined error for this operation
        if err, ok := m.ReturnErrorMap[cmd]; ok </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return m.DefaultError</span>
}

// GetDiff implements the GitRunner interface
func (m *MockGitRunner) GetDiff(filePath string, env ...[]string) (string, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "diff-" + filePath
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Check if we have a predefined response for this file
        if response, ok := m.ReturnValueMap[cmd]; ok </span><span class="cov0" title="0">{
                if err, ok := m.ReturnErrorMap[cmd]; ok </span><span class="cov0" title="0">{
                        return response, err
                }</span>
                <span class="cov0" title="0">return response, nil</span>
        }
        
        <span class="cov0" title="0">return m.DefaultResponse, m.DefaultError</span>
}

// IsGitRepository implements the GitRunner interface
func (m *MockGitRunner) IsGitRepository(path string) bool <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "is-git-repo-" + path
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Check if we have a predefined response
        if response, ok := m.ReturnValueMap[cmd]; ok </span><span class="cov0" title="0">{
                return response == "true"
        }</span>
        
        // Default to true for testing
        <span class="cov0" title="0">return true</span>
}

// GetGitConfigValue implements the GitRunner interface
func (m *MockGitRunner) GetGitConfigValue(key string, env ...[]string) (string, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "config-get-" + key
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Check if we have a predefined response
        if response, ok := m.ReturnValueMap[cmd]; ok </span><span class="cov0" title="0">{
                if err, ok := m.ReturnErrorMap[cmd]; ok </span><span class="cov0" title="0">{
                        return response, err
                }</span>
                <span class="cov0" title="0">return response, nil</span>
        }
        
        <span class="cov0" title="0">return m.DefaultResponse, m.DefaultError</span>
}

// SetGitConfigValue implements the GitRunner interface
func (m *MockGitRunner) SetGitConfigValue(key, value string, env ...[]string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        cmd := "config-set-" + key + "-" + value
        m.Commands = append(m.Commands, cmd)
        m.CallCount[cmd] = m.CallCount[cmd] + 1
        
        // Check if we have a predefined error
        if err, ok := m.ReturnErrorMap[cmd]; ok </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return m.DefaultError</span>
}

// MockOutputManager mocks the output.go functionality
type MockOutputManager struct {
        Folders      map[string]output.Folder
        SavedToFile  bool
        ClearedCalls int
        mu           sync.Mutex
}

// Ensure MockOutputManager implements OutputManager interface
var _ interfaces.OutputManager = &amp;MockOutputManager{}

// NewMockOutputManager creates a new mock output manager
func NewMockOutputManager() *MockOutputManager <span class="cov8" title="1">{
        return &amp;MockOutputManager{
                Folders:      make(map[string]output.Folder),
                SavedToFile:  false,
                ClearedCalls: 0,
        }
}</span>

// Set mocks output.Set
func (m *MockOutputManager) Set(file, rootFolder, commitMessage string) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        folder, ok := m.Folders[rootFolder]
        if !ok </span><span class="cov8" title="1">{
                folder = output.Folder{
                        Name:  rootFolder,
                        Files: []output.FileEntry{},
                }
        }</span>

        <span class="cov8" title="1">updated := false
        for i, entry := range folder.Files </span><span class="cov0" title="0">{
                if entry.Name == file </span><span class="cov0" title="0">{
                        folder.Files[i].Message = commitMessage
                        updated = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !updated </span><span class="cov8" title="1">{
                folder.Files = append(folder.Files, output.FileEntry{
                        Name:    file,
                        Message: commitMessage,
                })
        }</span>

        <span class="cov8" title="1">m.Folders[rootFolder] = folder</span>
}

// Get mocks output.Get
func (m *MockOutputManager) Get(file, rootFolder string) string <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        folder, ok := m.Folders[rootFolder]
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">for _, entry := range folder.Files </span><span class="cov8" title="1">{
                if entry.Name == file </span><span class="cov8" title="1">{
                        return entry.Message
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// GetFolder mocks output.GetFolder
func (m *MockOutputManager) GetFolder(rootFolder string) output.Folder <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if folder, ok := m.Folders[rootFolder]; ok </span><span class="cov0" title="0">{
                return folder
        }</span>

        <span class="cov0" title="0">return output.Folder{
                Name:  rootFolder,
                Files: []output.FileEntry{},
        }</span>
}

// GetAll mocks output.GetAll
func (m *MockOutputManager) GetAll() output.OutputData <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        folders := make([]output.Folder, 0, len(m.Folders))
        for _, folder := range m.Folders </span><span class="cov8" title="1">{
                folders = append(folders, folder)
        }</span>

        <span class="cov8" title="1">return output.OutputData{
                Folders: folders,
        }</span>
}

// RemoveFolder implements the OutputManager interface
func (m *MockOutputManager) RemoveFolder(name string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        delete(m.Folders, name)
}</span>

// Clear mocks output.Clear
func (m *MockOutputManager) Clear() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.Folders = make(map[string]output.Folder)
        m.ClearedCalls++
}</span>

// SaveToFile implements the OutputManager interface
func (m *MockOutputManager) SaveToFile() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.SavedToFile = true
}</span>

// MockConfig mocks the config functionality
type MockConfig struct {
        Settings map[string]interface{}
        mu       sync.Mutex
}

// NewMockConfig creates a new mock config
func NewMockConfig() *MockConfig <span class="cov0" title="0">{
        return &amp;MockConfig{
                Settings: make(map[string]interface{}),
        }
}</span>

// Get mocks config.Get
func (m *MockConfig) Get(key string) interface{} <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if value, ok := m.Settings[key]; ok </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Set mocks config.Set
func (m *MockConfig) Set(key string, value interface{}) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.Settings[key] = value
}</span>

// GetAll mocks config.GetAll
func (m *MockConfig) GetAll() map[string]interface{} <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        return m.Settings
}</span>

// MockAPIClient mocks API interactions for testing
type MockAPIClient struct {
        Responses       map[string]string
        Errors          map[string]error
        CallCount       map[string]int
        DefaultResponse string
        DefaultError    error
        mu              sync.Mutex
}

// NewMockAPIClient creates a new mock API client
func NewMockAPIClient() *MockAPIClient <span class="cov8" title="1">{
        return &amp;MockAPIClient{
                Responses:       make(map[string]string),
                Errors:          make(map[string]error),
                CallCount:       make(map[string]int),
                DefaultResponse: "",
                DefaultError:    nil,
        }
}</span>

// SendToGemini mocks utils.SendToGemini
func (m *MockAPIClient) SendToGemini(contextData map[string]map[string]string, apiKey string) (string, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Create a key from the context data
        var key string
        if len(contextData) &gt; 0 </span><span class="cov0" title="0">{
                for file := range contextData </span><span class="cov0" title="0">{
                        key = file
                        break</span>
                }
        }

        // Increment call count
        <span class="cov0" title="0">m.CallCount[key] = m.CallCount[key] + 1

        // Check if we have a predefined response for this key
        if response, ok := m.Responses[key]; ok </span><span class="cov0" title="0">{
                if err, ok := m.Errors[key]; ok </span><span class="cov0" title="0">{
                        return response, err
                }</span>
                <span class="cov0" title="0">return response, nil</span>
        }

        <span class="cov0" title="0">return m.DefaultResponse, m.DefaultError</span>
}

// MockFileSystem mocks filesystem operations for testing
type MockFileSystem struct {
        FileContent map[string]string
        FileInfo    map[string]bool // true = directory, false = file
        mu          sync.Mutex
}

// NewMockFileSystem creates a new mock filesystem
func NewMockFileSystem() *MockFileSystem <span class="cov0" title="0">{
        return &amp;MockFileSystem{
                FileContent: make(map[string]string),
                FileInfo:    make(map[string]bool),
        }
}</span>

// ReadFile mocks reading a file
func (m *MockFileSystem) ReadFile(path string) (string, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if content, ok := m.FileContent[path]; ok </span><span class="cov0" title="0">{
                return content, nil
        }</span>

        <span class="cov0" title="0">return "", errors.New("file not found: " + path)</span>
}

// WriteFile mocks writing to a file
func (m *MockFileSystem) WriteFile(path, content string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.FileContent[path] = content
        m.FileInfo[path] = false
        return nil
}</span>

// Exists mocks checking if a file exists
func (m *MockFileSystem) Exists(path string) (bool, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        _, ok := m.FileInfo[path]
        return ok, nil
}</span>

// IsDir mocks checking if a path is a directory
func (m *MockFileSystem) IsDir(path string) (bool, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if isDir, ok := m.FileInfo[path]; ok </span><span class="cov0" title="0">{
                return isDir, nil
        }</span>

        <span class="cov0" title="0">return false, errors.New("path not found: " + path)</span>
}

// CreateDir mocks creating a directory
func (m *MockFileSystem) CreateDir(path string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.FileInfo[path] = true
        return nil
}</span>

// MockProgressReporter provides a mock implementation of progress reporting
type MockProgressReporter struct {
        Reports      []string
        StartCalled  bool
        FinishCalled bool
        ErrorCount   int
        mu           sync.Mutex
}

// NewMockProgressReporter creates a new mock progress reporter
func NewMockProgressReporter() *MockProgressReporter <span class="cov0" title="0">{
        return &amp;MockProgressReporter{
                Reports:      make([]string, 0),
                StartCalled:  false,
                FinishCalled: false,
                ErrorCount:   0,
        }
}</span>

// Start mocks starting progress reporting
func (m *MockProgressReporter) Start(message string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.StartCalled = true
        m.Reports = append(m.Reports, "START: "+message)
}</span>

// Update mocks updating progress
func (m *MockProgressReporter) Update(message string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.Reports = append(m.Reports, "UPDATE: "+message)
}</span>

// Finish mocks finishing progress reporting
func (m *MockProgressReporter) Finish(message string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.FinishCalled = true
        m.Reports = append(m.Reports, "FINISH: "+message)
}</span>

// Error mocks reporting an error
func (m *MockProgressReporter) Error(message string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.ErrorCount++
        m.Reports = append(m.Reports, "ERROR: "+message)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package testreport provides utilities for generating test reports
package testreport

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"
)

// TestResult represents the result of a single test
type TestResult struct {
        Name      string        `json:"name"`
        Package   string        `json:"package"`
        Success   bool          `json:"success"`
        Duration  time.Duration `json:"duration"`
        ErrorMsg  string        `json:"errorMsg,omitempty"`
        SkipMsg   string        `json:"skipMsg,omitempty"`
        TimeStamp time.Time     `json:"timestamp"`
}

// TestReport represents a complete test report
type TestReport struct {
        TotalTests      int           `json:"totalTests"`
        PassedTests     int           `json:"passedTests"`
        FailedTests     int           `json:"failedTests"`
        SkippedTests    int           `json:"skippedTests"`
        TotalDuration   time.Duration `json:"totalDuration"`
        Coverage        float64       `json:"coverage,omitempty"`
        Results         []TestResult  `json:"results"`
        TimeStamp       time.Time     `json:"timestamp"`
        GitCuryVersion  string        `json:"gitCuryVersion"`
        GoVersion       string        `json:"goVersion"`
        OperatingSystem string        `json:"operatingSystem"`
}

// GenerateTestReport runs all tests and generates a comprehensive report
func GenerateTestReport(outputPath string, coverageEnabled bool) (*TestReport, error) <span class="cov0" title="0">{
        startTime := time.Now()
        
        // Initialize report
        report := &amp;TestReport{
                Results:   make([]TestResult, 0),
                TimeStamp: startTime,
        }
        
        // Get system information
        report.GoVersion = getGoVersion()
        report.OperatingSystem = getOS()
        report.GitCuryVersion = getGitCuryVersion()
        
        // Build test command
        args := []string{"test", "./..."}
        if coverageEnabled </span><span class="cov0" title="0">{
                args = append(args, "-cover")
        }</span>
        <span class="cov0" title="0">args = append(args, "-v", "-json")
        
        // Run tests with JSON output
        cmd := exec.Command("go", args...)
        cmd.Env = os.Environ()
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                // Don't return error here, we want to generate a report even if tests fail
                fmt.Printf("Warning: tests completed with error: %v\n", err)
        }</span>
        
        // Parse test output
        <span class="cov0" title="0">lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Try to parse as JSON
                <span class="cov0" title="0">var testEvent map[string]interface{}
                if err := json.Unmarshal([]byte(line), &amp;testEvent); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Check if this is a test result
                <span class="cov0" title="0">if eventType, ok := testEvent["Action"].(string); ok &amp;&amp; eventType == "run" </span><span class="cov0" title="0">{
                        // Process test result
                        testName, _ := testEvent["Test"].(string)
                        pkgName, _ := testEvent["Package"].(string)
                        
                        // Find corresponding pass/fail/skip event
                        result := findTestResult(lines, testName, pkgName)
                        if result != nil </span><span class="cov0" title="0">{
                                report.Results = append(report.Results, *result)
                        }</span>
                }
        }
        
        // Calculate statistics
        <span class="cov0" title="0">for _, result := range report.Results </span><span class="cov0" title="0">{
                report.TotalTests++
                if result.Success </span><span class="cov0" title="0">{
                        report.PassedTests++
                }</span> else<span class="cov0" title="0"> if result.SkipMsg != "" </span><span class="cov0" title="0">{
                        report.SkippedTests++
                }</span> else<span class="cov0" title="0"> {
                        report.FailedTests++
                }</span>
                <span class="cov0" title="0">report.TotalDuration += result.Duration</span>
        }
        
        // Get coverage if enabled
        <span class="cov0" title="0">if coverageEnabled </span><span class="cov0" title="0">{
                report.Coverage = extractCoverage(string(output))
        }</span>
        
        // Write report to file if path provided
        <span class="cov0" title="0">if outputPath != "" </span><span class="cov0" title="0">{
                if err := writeReport(report, outputPath); err != nil </span><span class="cov0" title="0">{
                        return report, fmt.Errorf("failed to write report: %w", err)
                }</span>
        }
        
        <span class="cov0" title="0">return report, nil</span>
}

// Helper to find test result from output
func findTestResult(lines []string, testName, pkgName string) *TestResult <span class="cov0" title="0">{
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">var testEvent map[string]interface{}
                if err := json.Unmarshal([]byte(line), &amp;testEvent); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">eventTestName, _ := testEvent["Test"].(string)
                eventPkgName, _ := testEvent["Package"].(string)
                eventType, _ := testEvent["Action"].(string)
                
                if eventTestName == testName &amp;&amp; eventPkgName == pkgName &amp;&amp; 
                   (eventType == "pass" || eventType == "fail" || eventType == "skip") </span><span class="cov0" title="0">{
                        
                        // Create test result
                        result := &amp;TestResult{
                                Name:      testName,
                                Package:   pkgName,
                                Success:   eventType == "pass",
                                TimeStamp: time.Now(),
                        }
                        
                        // Get duration
                        if duration, ok := testEvent["Elapsed"].(float64); ok </span><span class="cov0" title="0">{
                                result.Duration = time.Duration(duration * float64(time.Second))
                        }</span>
                        
                        // Get error message for failed tests
                        <span class="cov0" title="0">if eventType == "fail" </span><span class="cov0" title="0">{
                                if output, ok := testEvent["Output"].([]interface{}); ok &amp;&amp; len(output) &gt; 0 </span><span class="cov0" title="0">{
                                        var errorMsg strings.Builder
                                        for _, line := range output </span><span class="cov0" title="0">{
                                                errorMsg.WriteString(line.(string))
                                                errorMsg.WriteString("\n")
                                        }</span>
                                        <span class="cov0" title="0">result.ErrorMsg = errorMsg.String()</span>
                                }
                        }
                        
                        // Get skip message
                        <span class="cov0" title="0">if eventType == "skip" </span><span class="cov0" title="0">{
                                if output, ok := testEvent["Output"].([]interface{}); ok &amp;&amp; len(output) &gt; 0 </span><span class="cov0" title="0">{
                                        var skipMsg strings.Builder
                                        for _, line := range output </span><span class="cov0" title="0">{
                                                skipMsg.WriteString(line.(string))
                                                skipMsg.WriteString("\n")
                                        }</span>
                                        <span class="cov0" title="0">result.SkipMsg = skipMsg.String()</span>
                                }
                        }
                        
                        <span class="cov0" title="0">return result</span>
                }
        }
        
        <span class="cov0" title="0">return nil</span>
}

// Helper to extract coverage percentage
func extractCoverage(output string) float64 <span class="cov0" title="0">{
        // Look for coverage line in output
        lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, "coverage:") </span><span class="cov0" title="0">{
                        // Parse coverage percentage
                        parts := strings.Split(line, "coverage:")
                        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                coveragePart := strings.TrimSpace(parts[1])
                                coveragePct := strings.TrimSuffix(coveragePart, "%")
                                if coverage, err := parseFloat(coveragePct); err == nil </span><span class="cov0" title="0">{
                                        return coverage
                                }</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return 0.0</span>
}

// Helper to parse float
func parseFloat(s string) (float64, error) <span class="cov0" title="0">{
        var result float64
        _, err := fmt.Sscanf(s, "%f", &amp;result)
        return result, err
}</span>

// Helper to write report to file
func writeReport(report *TestReport, path string) error <span class="cov0" title="0">{
        // Create directory if needed
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Marshal to JSON
        <span class="cov0" title="0">data, err := json.MarshalIndent(report, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Write to file
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// Helper to get Go version
func getGoVersion() string <span class="cov0" title="0">{
        cmd := exec.Command("go", "version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(output))</span>
}

// Helper to get OS information
func getOS() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s", os.Getenv("GOOS"), os.Getenv("GOARCH"))
}</span>

// Helper to get GitCury version
func getGitCuryVersion() string <span class="cov0" title="0">{
        // This would ideally use the GitCury version from a version package
        return "development" // Replace with actual version
}</span>

// PrintReportSummary prints a summary of the test report
func PrintReportSummary(report *TestReport) <span class="cov0" title="0">{
        fmt.Println("=== GitCury Test Report Summary ===")
        fmt.Printf("Total Tests: %d\n", report.TotalTests)
        fmt.Printf("Passed: %d\n", report.PassedTests)
        fmt.Printf("Failed: %d\n", report.FailedTests)
        fmt.Printf("Skipped: %d\n", report.SkippedTests)
        fmt.Printf("Total Duration: %v\n", report.TotalDuration)
        
        if report.Coverage &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Code Coverage: %.2f%%\n", report.Coverage)
        }</span>
        
        <span class="cov0" title="0">fmt.Println("===============================")
        
        // Print failed tests if any
        if report.FailedTests &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Failed Tests:")
                for _, result := range report.Results </span><span class="cov0" title="0">{
                        if !result.Success &amp;&amp; result.SkipMsg == "" </span><span class="cov0" title="0">{
                                fmt.Printf("- %s.%s\n", result.Package, result.Name)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package testutils

import (
        "io/ioutil"
        "os"
        "os/exec"
        "path/filepath"
        "testing"
)

// CreateTempDir creates a temporary directory for testing
func CreateTempDir(t *testing.T) string <span class="cov8" title="1">{
        tempDir, err := ioutil.TempDir("", "gitcury-test-*")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp directory: %v", err)
        }</span>
        
        <span class="cov8" title="1">t.Cleanup(func() </span><span class="cov8" title="1">{
                os.RemoveAll(tempDir)
        }</span>)
        
        <span class="cov8" title="1">return tempDir</span>
}

// CreateTempFile creates a temporary file with the given content
func CreateTempFile(t *testing.T, dir, prefix, content string) string <span class="cov8" title="1">{
        file, err := ioutil.TempFile(dir, prefix)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp file: %v", err)
        }</span>
        
        <span class="cov8" title="1">if content != "" </span><span class="cov8" title="1">{
                if _, err := file.WriteString(content); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to write to temp file: %v", err)
                }</span>
        }
        
        <span class="cov8" title="1">if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to close temp file: %v", err)
        }</span>
        
        <span class="cov8" title="1">return file.Name()</span>
}

// SetupGitRepo initializes a git repository in the given directory
func SetupGitRepo(t *testing.T, dir string) <span class="cov8" title="1">{
        commands := [][]string{
                {"git", "init"},
                {"git", "config", "user.name", "Test User"},
                {"git", "config", "user.email", "test@example.com"},
        }
        
        for _, cmd := range commands </span><span class="cov8" title="1">{
                if err := runCommand(dir, cmd...); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to run command %v: %v", cmd, err)
                }</span>
        }
}

// AddAndCommitFile adds and commits a file to the repository
func AddAndCommitFile(t *testing.T, repoDir, filename, content, message string) <span class="cov8" title="1">{
        filePath := filepath.Join(repoDir, filename)
        
        // Create the file
        if err := os.WriteFile(filePath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to write file %s: %v", filename, err)
        }</span>
        
        <span class="cov8" title="1">commands := [][]string{
                {"git", "add", filename},
                {"git", "commit", "-m", message},
        }
        
        for _, cmd := range commands </span><span class="cov8" title="1">{
                if err := runCommand(repoDir, cmd...); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("Failed to run command %v: %v", cmd, err)
                }</span>
        }
}

// Helper to run commands
func runCommand(dir string, args ...string) error <span class="cov8" title="1">{
        cmd := exec.Command(args[0], args[1:]...)
        cmd.Dir = dir
        return cmd.Run()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package utils

import (
        "fmt"
        "strings"
)

// ErrorType represents the category of an error
type ErrorType string

const (
        // Error categories
        ConfigError     ErrorType = "CONFIG"
        GitError        ErrorType = "GIT"
        APIError        ErrorType = "API"
        ValidationError ErrorType = "VALIDATION"
        SystemError     ErrorType = "SYSTEM"
        UserError       ErrorType = "USER"
)

// StructuredError represents an error with additional context
type StructuredError struct {
        Type    ErrorType
        Message string
        Cause   error
        Context map[string]interface{}
}

// Error implements the error interface
func (e *StructuredError) Error() string <span class="cov8" title="1">{
        msg := fmt.Sprintf("[%s] %s", e.Type, e.Message)
        if e.Cause != nil </span><span class="cov8" title="1">{
                msg += fmt.Sprintf(": %s", e.Cause.Error())
        }</span>

        <span class="cov8" title="1">if len(e.Context) &gt; 0 </span><span class="cov8" title="1">{
                contextStrs := make([]string, 0, len(e.Context))
                for k, v := range e.Context </span><span class="cov8" title="1">{
                        contextStrs = append(contextStrs, fmt.Sprintf("%s=%v", k, v))
                }</span>
                <span class="cov8" title="1">msg += fmt.Sprintf(" [%s]", strings.Join(contextStrs, ", "))</span>
        }

        <span class="cov8" title="1">return msg</span>
}

// Unwrap implements the errors.Unwrap interface
func (e *StructuredError) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

// Helper functions to create different types of errors

// NewConfigError creates a new configuration error
func NewConfigError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov0" title="0">{
        return &amp;StructuredError{
                Type:    ConfigError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// NewGitError creates a new Git-related error
func NewGitError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov8" title="1">{
        return &amp;StructuredError{
                Type:    GitError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// NewAPIError creates a new API-related error
func NewAPIError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov0" title="0">{
        return &amp;StructuredError{
                Type:    APIError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// NewValidationError creates a new validation error
func NewValidationError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov0" title="0">{
        return &amp;StructuredError{
                Type:    ValidationError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// NewSystemError creates a new system-related error
func NewSystemError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov8" title="1">{
        return &amp;StructuredError{
                Type:    SystemError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// NewUserError creates a new user-related error
func NewUserError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov0" title="0">{
        return &amp;StructuredError{
                Type:    UserError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// ToUserFriendlyMessage converts an error to a user-friendly message with possible solution
func ToUserFriendlyMessage(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Try to cast to StructuredError
        <span class="cov8" title="1">if structured, ok := err.(*StructuredError); ok </span><span class="cov8" title="1">{
                switch structured.Type </span>{
                case ConfigError:<span class="cov0" title="0">
                        return fmt.Sprintf("Configuration issue: %s\nSuggestion: Check your configuration file or run 'gitcury setup' to reconfigure.", structured.Message)</span>
                case GitError:<span class="cov8" title="1">
                        return fmt.Sprintf("Git operation failed: %s\nSuggestion: Verify that Git is installed and that you have the necessary permissions.", structured.Message)</span>
                case APIError:<span class="cov0" title="0">
                        return fmt.Sprintf("API connection issue: %s\nSuggestion: Check your internet connection and API key configuration.", structured.Message)</span>
                case ValidationError:<span class="cov0" title="0">
                        return fmt.Sprintf("Invalid input: %s\nSuggestion: Review the command syntax and parameters.", structured.Message)</span>
                case SystemError:<span class="cov0" title="0">
                        return fmt.Sprintf("System error: %s\nSuggestion: Verify that you have the necessary permissions and system resources.", structured.Message)</span>
                case UserError:<span class="cov0" title="0">
                        return fmt.Sprintf("User error: %s", structured.Message)</span>
                default:<span class="cov0" title="0">
                        return fmt.Sprintf("Error: %s", err.Error())</span>
                }
        }

        // Default error handling
        <span class="cov8" title="1">return fmt.Sprintf("Error: %s", err.Error())</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
        "os"
)

func ListFiles(directory string) ([]string, error) <span class="cov0" title="0">{
        entries, err := os.ReadDir(directory)
        if err != nil </span><span class="cov0" title="0">{
                Debug("[FILES]: üö® Error reading directory: " + err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">var files []string
        for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        files = append(files, entry.Name())
                }</span>
        }

        <span class="cov0" title="0">Debug("[FILES]: üìÇ Successfully listed files in directory: " + directory)
        return files, nil</span>
}

func ToJSON(data interface{}) string <span class="cov8" title="1">{
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                Debug("[JSON]: üö® Error marshalling data: " + err.Error())
                return "{}"
        }</span>
        <span class="cov8" title="1">Debug("[JSON]: ‚ú® Successfully marshalled data to JSON")
        return string(jsonData)</span>
}

func IsNumeric(s string) bool <span class="cov8" title="1">{
        for _, char := range s </span><span class="cov8" title="1">{
                if char &lt; '0' || char &gt; '9' </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">Debug("[NUMERIC]: üî¢ String is numeric: " + s)
        return len(s) &gt; 0</span>
}

func ParseInt(s string) (int, error) <span class="cov8" title="1">{
        if !IsNumeric(s) </span><span class="cov8" title="1">{
                Error("[PARSE]: üö® Error parsing string to int: " + s)
                return 0, fmt.Errorf("invalid number: %s", s)
        }</span>

        <span class="cov8" title="1">result := 0
        for _, char := range s </span><span class="cov8" title="1">{
                result = result*10 + int(char-'0')
        }</span>

        <span class="cov8" title="1">Debug("[PARSE]: üî¢ Successfully parsed string to int: " + s)
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package utils

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/google/generative-ai-go/genai"
        "google.golang.org/api/option"
        "google.golang.org/grpc/status"
)

var (
        maxRetries int
        retryDelay int
)

func SetTimeoutVar(retries, delay int) <span class="cov0" title="0">{
        maxRetries = retries
        retryDelay = delay
}</span>

func printResponse(resp *genai.GenerateContentResponse) <span class="cov0" title="0">{
        if resp == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for i, candidate := range resp.Candidates </span><span class="cov0" title="0">{
                Debug(fmt.Sprintf("[GEMINI]: Candidate %d: %s", i+1, candidate.Content.Parts[0]))
        }</span>
}

func SendToGemini(contextData map[string]map[string]string, apiKey string) (string, error) <span class="cov0" title="0">{

        ctx := context.Background()
        client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
        if err != nil </span><span class="cov0" title="0">{
                Error("[GEMINI]: üö® Failed to initialize Gemini client: " + err.Error())
                return "", err
        }</span>
        <span class="cov0" title="0">defer client.Close()

        model := client.GenerativeModel("gemini-2.0-flash")
        model.SetTemperature(0.5)
        model.SetMaxOutputTokens(100)
        model.ResponseMIMEType = "application/json"
        model.SystemInstruction = genai.NewUserContent(genai.Text(`
        Generate and return only a commit message as JSON with the key "message".
        Follow these guidelines for the commit message:
        ‚Ä¢ Capitalize the first word, omit final punctuation. If using conventional commits, use lowercase for the commit type.
        ‚Ä¢ Use imperative mood in the subject line.
        ‚Ä¢ Include a commit type (e.g. fix, update, refactor, bump).
        ‚Ä¢ Limit the first line to ‚â§ 50 characters, subsequent lines ‚â§ 72.
        ‚Ä¢ Be concise and direct; avoid filler words.
        ‚Ä¢ Do not include newline characters (\n) or similar formatting.

        The commit type can include the following:
        feat ‚Äì a new feature
        fix ‚Äì a bug fix
        chore ‚Äì non-source changes
        refactor ‚Äì refactored code
        docs ‚Äì documentation updates
        style ‚Äì formatting changes
        test ‚Äì tests
        perf ‚Äì performance improvements
        ci ‚Äì continuous integration
        build ‚Äì build system changes
        revert ‚Äì revert a previous commit
        `))

        var promptBuilder strings.Builder
        promptBuilder.WriteString("Summarize the following file changes:\n\n")
        for file, data := range contextData </span><span class="cov0" title="0">{
                promptBuilder.WriteString(fmt.Sprintf("File: %s\nType: %s\nDiff:\n%s\n\n", file, data["type"], data["diff"]))
        }</span>
        <span class="cov0" title="0">prompt := promptBuilder.String()

        var resp *genai.GenerateContentResponse
        for retries := 0; retries &lt; maxRetries; retries++ </span><span class="cov0" title="0">{
                resp, err = model.GenerateContent(ctx, genai.Text(prompt))
                if err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "googleapi: Error 429: You exceeded your current quota, please check your plan and billing details.") || status.Code(err) == 14 </span><span class="cov0" title="0">{ // Retry on specific 429 error or UNAVAILABLE
                                Warning(fmt.Sprintf("[GEMINI]: ‚ö†Ô∏è Quota exceeded or service unavailable. Retrying in %d seconds... (attempt %d/%d)", retryDelay, retries+1, maxRetries))
                                time.Sleep(time.Duration(retryDelay) * time.Second)
                                continue</span>
                        }
                        <span class="cov0" title="0">return "", err</span>
                }
                <span class="cov0" title="0">break</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if len(resp.Candidates) == 0 </span><span class="cov0" title="0">{
                Error("[GEMINI]: ‚ùå No content generated by Gemini.")
                return "", errors.New("no content generated by Gemini")
        }</span>

        <span class="cov0" title="0">respMessage := fmt.Sprintf(`%s`, resp.Candidates[0].Content.Parts[0])
        Debug("[GEMINI]: ‚ú® Response received: " + respMessage)

        var result map[string]string
        err = json.Unmarshal([]byte(respMessage), &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                Error("[GEMINI]: üö® Failed to parse response: " + err.Error())
                return "", err
        }</span>

        <span class="cov0" title="0">message, ok := result["message"]
        if !ok </span><span class="cov0" title="0">{
                Error("[GEMINI]: ‚ùå Key 'message' not found in response.")
                return "", errors.New("key 'message' not found in response")
        }</span>

        <span class="cov0" title="0">return message, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package utils

import (
        "fmt"
        "log"
        "runtime"
        "strings"
)

// ANSI color codes - Dark Tech palette
const (
        Reset     = "\033[0m"
        Red       = "\033[38;5;196m" // Bright red
        Green     = "\033[38;5;46m"  // Neon green
        Yellow    = "\033[38;5;226m" // Warning yellow
        Blue      = "\033[38;5;33m"  // Electric blue
        Magenta   = "\033[38;5;201m" // Cyber pink
        Cyan      = "\033[38;5;51m"  // Holographic cyan
        Black     = "\033[38;5;236m" // Dark background
        Bold      = "\033[1m"
        Underline = "\033[4m"
        Blink     = "\033[5m" // Use sparingly!
        Dim       = "\033[2m"
        BlackBg   = "\033[48;5;235m" // Dark background
)

var LogLevel string = "info"

func SetLogLevel(level string) <span class="cov8" title="1">{
        LogLevel = level
}</span>

// Debug logs a message at the debug level
func Debug(message string) <span class="cov8" title="1">{
        if LogLevel != "debug" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">log.Printf("\n%s%s[SCAN    ] üîç %s %s\n", Cyan, BlackBg, Reset, message)</span>
}

// Info logs a message at the info level
func Info(message string) <span class="cov8" title="1">{
        fmt.Printf("\n%s%s[SYS     ] ‚ö° %s %s\n", Green, BlackBg, Reset, message)
}</span>

// Success logs a success message
func Success(message string) <span class="cov8" title="1">{
        fmt.Printf("\n%s%s[SUCCESS ] üíª %s %s\n", Green, BlackBg, Reset, message)
}</span>

// Error logs error message
func Error(message string) <span class="cov8" title="1">{
        _, file, line, ok := runtime.Caller(1)
        if ok </span><span class="cov8" title="1">{
                shortFile := file
                if parts := strings.Split(file, "/"); len(parts) &gt; 2 </span><span class="cov8" title="1">{
                        shortFile = parts[len(parts)-2] + "/" + parts[len(parts)-1]
                }</span>
                <span class="cov8" title="1">log.Printf("\n%s%s[BREACH  ] ‚ö†Ô∏è %s %s (at %s:%d)\n", Red, BlackBg, Reset, message, shortFile, line)</span>
        } else<span class="cov0" title="0"> {
                log.Printf("\n%s%s[BREACH  ] ‚ö†Ô∏è %s %s\n", Red, BlackBg, Reset, message)
        }</span>
}

// Warning logs warning message
func Warning(message string) <span class="cov8" title="1">{
        fmt.Printf("\n%s%s[ALERT   ] üî• %s %s\n", Yellow, BlackBg, Reset, message)
}</span>

// Print outputs data to the CLI
func Print(data string) <span class="cov0" title="0">{
        fmt.Printf("\n%s%s%s\n", Cyan, data, Reset)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package utils

import (
        "fmt"
        "io"
        "os"
        "strings"
        "sync"
        "time"
)

// ProgressReporter provides an interface for reporting progress of long-running operations
type ProgressReporter struct {
        total         int64
        current       int64
        start         time.Time
        lastUpdate    time.Time
        updateMu      sync.Mutex
        message       string
        finished      bool
        width         int
        writer        io.Writer
        hideInQuiet   bool
        updateFreq    time.Duration
        progressChar  string
        spinnerChars  []string
        spinnerPos    int
        spinnerActive bool
        spinnerTicker *time.Ticker
        spinnerDone   chan struct{}
}

// NewProgressReporter creates a new progress reporter
func NewProgressReporter(total int64, message string) *ProgressReporter <span class="cov0" title="0">{
        return &amp;ProgressReporter{
                total:        total,
                current:      0,
                start:        time.Now(),
                lastUpdate:   time.Now(),
                message:      message,
                finished:     false,
                width:        50,
                writer:       os.Stdout,
                hideInQuiet:  true,
                updateFreq:   200 * time.Millisecond,
                progressChar: "‚ñ†",
                spinnerChars: []string{"‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è"},
                spinnerPos:   0,
        }
}</span>

// NewIndeterminateProgressReporter creates a progress reporter for operations
// where the total amount of work is unknown
func NewIndeterminateProgressReporter(message string) *ProgressReporter <span class="cov0" title="0">{
        p := NewProgressReporter(-1, message)
        return p
}</span>

// SetWidth sets the width of the progress bar
func (p *ProgressReporter) SetWidth(width int) *ProgressReporter <span class="cov0" title="0">{
        p.width = width
        return p
}</span>

// SetWriter sets the io.Writer where progress updates are written
func (p *ProgressReporter) SetWriter(writer io.Writer) *ProgressReporter <span class="cov0" title="0">{
        p.writer = writer
        return p
}</span>

// SetHideInQuiet sets whether the progress bar should be hidden in quiet mode
func (p *ProgressReporter) SetHideInQuiet(hide bool) *ProgressReporter <span class="cov0" title="0">{
        p.hideInQuiet = hide
        return p
}</span>

// Start begins the progress reporting
func (p *ProgressReporter) Start() *ProgressReporter <span class="cov0" title="0">{
        p.updateMu.Lock()
        defer p.updateMu.Unlock()

        p.start = time.Now()
        p.lastUpdate = time.Now()
        p.finished = false

        // Start spinner for indeterminate progress
        if p.total &lt; 0 </span><span class="cov0" title="0">{
                p.spinnerActive = true
                p.spinnerDone = make(chan struct{})
                p.spinnerTicker = time.NewTicker(100 * time.Millisecond)

                go func() </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-p.spinnerTicker.C:<span class="cov0" title="0">
                                        p.updateMu.Lock()
                                        if p.spinnerActive </span><span class="cov0" title="0">{
                                                p.spinnerPos = (p.spinnerPos + 1) % len(p.spinnerChars)
                                                p.renderSpinner()
                                        }</span>
                                        <span class="cov0" title="0">p.updateMu.Unlock()</span>
                                case &lt;-p.spinnerDone:<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }()
        } else<span class="cov0" title="0"> {
                // Render the initial progress bar
                p.render()
        }</span>

        <span class="cov0" title="0">return p</span>
}

// Update updates the current progress
func (p *ProgressReporter) Update(current int64) <span class="cov0" title="0">{
        p.updateMu.Lock()
        defer p.updateMu.Unlock()

        if p.finished </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">p.current = current

        // Only update if enough time has passed since last update
        if time.Since(p.lastUpdate) &gt;= p.updateFreq </span><span class="cov0" title="0">{
                if p.total &lt; 0 </span><span class="cov0" title="0">{
                        // Indeterminate progress uses spinner
                        return
                }</span>

                // Render the progress bar
                <span class="cov0" title="0">p.render()
                p.lastUpdate = time.Now()</span>
        }
}

// UpdateMessage updates the message displayed with the progress bar
func (p *ProgressReporter) UpdateMessage(message string) <span class="cov0" title="0">{
        p.updateMu.Lock()
        defer p.updateMu.Unlock()

        if p.finished </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">p.message = message

        if p.total &lt; 0 </span><span class="cov0" title="0">{
                p.renderSpinner()
        }</span> else<span class="cov0" title="0"> {
                p.render()
        }</span>

        <span class="cov0" title="0">p.lastUpdate = time.Now()</span>
}

// Increment increases the current progress by the specified amount
func (p *ProgressReporter) Increment(amount int64) <span class="cov0" title="0">{
        p.Update(p.current + amount)
}</span>

// Done completes the progress reporting
func (p *ProgressReporter) Done() <span class="cov0" title="0">{
        p.updateMu.Lock()
        defer p.updateMu.Unlock()

        if p.finished </span><span class="cov0" title="0">{
                return
        }</span>

        // If this is a spinner, stop it
        <span class="cov0" title="0">if p.total &lt; 0 &amp;&amp; p.spinnerActive </span><span class="cov0" title="0">{
                p.spinnerActive = false
                p.spinnerTicker.Stop()
                close(p.spinnerDone)

                // Clear the spinner line
                fmt.Fprintf(p.writer, "\r%s\r", strings.Repeat(" ", 80))
        }</span> else<span class="cov0" title="0"> if p.total &gt;= 0 </span><span class="cov0" title="0">{
                // Make sure we show 100% completion
                p.current = p.total
                p.render()
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(p.writer)
        p.finished = true</span>
}

// render displays the current progress bar
func (p *ProgressReporter) render() <span class="cov0" title="0">{
        if p.hideInQuiet &amp;&amp; IsQuietMode() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">percent := float64(p.current) / float64(p.total) * 100
        if percent &gt; 100 </span><span class="cov0" title="0">{
                percent = 100
        }</span>

        <span class="cov0" title="0">elapsed := time.Since(p.start)

        // Calculate ETA
        var etaStr string
        if p.current &gt; 0 </span><span class="cov0" title="0">{
                itemsPerSecond := float64(p.current) / elapsed.Seconds()
                if itemsPerSecond &gt; 0 </span><span class="cov0" title="0">{
                        remainingItems := p.total - p.current
                        etaSeconds := float64(remainingItems) / itemsPerSecond
                        eta := time.Duration(etaSeconds) * time.Second
                        if eta &gt; 0 </span><span class="cov0" title="0">{
                                etaStr = fmt.Sprintf(" ETA: %s", formatDuration(eta))
                        }</span>
                }
        }

        // Build progress bar
        <span class="cov0" title="0">width := p.width
        completed := int(float64(width) * float64(p.current) / float64(p.total))

        progressBar := strings.Repeat(p.progressChar, completed) + strings.Repeat("‚ñë", width-completed)

        // Format and print the progress line
        fmt.Fprintf(
                p.writer,
                "\r%s [%s] %.1f%% (%d/%d)%s",
                p.message,
                progressBar,
                percent,
                p.current,
                p.total,
                etaStr,
        )</span>
}

// renderSpinner displays the spinner for indeterminate progress
func (p *ProgressReporter) renderSpinner() <span class="cov0" title="0">{
        if p.hideInQuiet &amp;&amp; IsQuietMode() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">spinner := p.spinnerChars[p.spinnerPos]
        elapsed := formatDuration(time.Since(p.start))

        fmt.Fprintf(
                p.writer,
                "\r%s %s [%s]",
                spinner,
                p.message,
                elapsed,
        )</span>
}

// formatDuration formats a duration in a user-friendly way
func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d &lt; time.Minute </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1fs", d.Seconds())
        }</span> else<span class="cov0" title="0"> if d &lt; time.Hour </span><span class="cov0" title="0">{
                minutes := int(d.Minutes())
                seconds := int(d.Seconds()) % 60
                return fmt.Sprintf("%dm%ds", minutes, seconds)
        }</span> else<span class="cov0" title="0"> {
                hours := int(d.Hours())
                minutes := int(d.Minutes()) % 60
                return fmt.Sprintf("%dh%dm", hours, minutes)
        }</span>
}

// Global quiet mode flag
var quietMode bool
var quietModeOnce sync.Once
var quietModeMu sync.RWMutex

// SetQuietMode sets the global quiet mode flag
func SetQuietMode(quiet bool) <span class="cov0" title="0">{
        quietModeOnce.Do(func() </span><span class="cov0" title="0">{
                quietModeMu.Lock()
                quietMode = quiet
                quietModeMu.Unlock()
        }</span>)
}

// IsQuietMode returns whether quiet mode is enabled
func IsQuietMode() bool <span class="cov0" title="0">{
        quietModeMu.RLock()
        defer quietModeMu.RUnlock()
        return quietMode
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package utils

import (
        "bufio"
        "fmt"
        "os"
        "strings"
)

// ConfirmAction asks the user to confirm an action with yes/no prompt
func ConfirmAction(message string, defaultYes bool) bool <span class="cov0" title="0">{
        // Skip confirmation in non-interactive environments
        if os.Getenv("GITCURY_NONINTERACTIVE") == "1" </span><span class="cov0" title="0">{
                return defaultYes
        }</span>

        <span class="cov0" title="0">prompt := message + " "
        if defaultYes </span><span class="cov0" title="0">{
                prompt += "[Y/n]: "
        }</span> else<span class="cov0" title="0"> {
                prompt += "[y/N]: "
        }</span>

        <span class="cov0" title="0">fmt.Print(prompt)

        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                Warning("[CONFIRM]: Error reading input, using default: " + err.Error())
                return defaultYes
        }</span>

        <span class="cov0" title="0">response = strings.TrimSpace(strings.ToLower(response))

        if response == "" </span><span class="cov0" title="0">{
                return defaultYes
        }</span>

        <span class="cov0" title="0">return response == "y" || response == "yes"</span>
}

// ConfirmActionWithDetails asks for confirmation and shows detailed information
func ConfirmActionWithDetails(action string, details []string, defaultYes bool) bool <span class="cov0" title="0">{
        fmt.Println("üìù " + action)

        if len(details) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Details:")
                for _, detail := range details </span><span class="cov0" title="0">{
                        fmt.Println("  ‚Ä¢ " + detail)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">return ConfirmAction("Do you want to continue?", defaultYes)</span>
}

// PromptForInput asks the user for text input with an optional default value
func PromptForInput(message string, defaultValue string) string <span class="cov0" title="0">{
        // Show default value in prompt if provided
        prompt := message
        if defaultValue != "" </span><span class="cov0" title="0">{
                prompt += fmt.Sprintf(" [default: %s]", defaultValue)
        }</span>
        <span class="cov0" title="0">prompt += ": "

        fmt.Print(prompt)

        reader := bufio.NewReader(os.Stdin)
        input, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                Warning("[PROMPT]: Error reading input, using default: " + err.Error())
                return defaultValue
        }</span>

        <span class="cov0" title="0">input = strings.TrimSpace(input)

        if input == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">return input</span>
}

// PromptForSelection asks the user to select from a list of options
func PromptForSelection(message string, options []string, defaultIndex int) (string, int) <span class="cov0" title="0">{
        if len(options) == 0 </span><span class="cov0" title="0">{
                return "", -1
        }</span>

        // Default to first item if default index is invalid
        <span class="cov0" title="0">if defaultIndex &lt; 0 || defaultIndex &gt;= len(options) </span><span class="cov0" title="0">{
                defaultIndex = 0
        }</span>

        <span class="cov0" title="0">fmt.Println(message)
        for i, option := range options </span><span class="cov0" title="0">{
                marker := " "
                if i == defaultIndex </span><span class="cov0" title="0">{
                        marker = "*"
                }</span>
                <span class="cov0" title="0">fmt.Printf("  %s %d) %s\n", marker, i+1, option)</span>
        }

        <span class="cov0" title="0">selectedIndex := -1

        for selectedIndex &lt; 0 || selectedIndex &gt;= len(options) </span><span class="cov0" title="0">{
                input := PromptForInput("Enter number", fmt.Sprintf("%d", defaultIndex+1))

                // Try to parse as number
                var parsedIndex int
                _, err := fmt.Sscanf(input, "%d", &amp;parsedIndex)
                if err != nil || parsedIndex &lt; 1 || parsedIndex &gt; len(options) </span><span class="cov0" title="0">{
                        fmt.Printf("Please enter a number between 1 and %d\n", len(options))
                        continue</span>
                }

                <span class="cov0" title="0">selectedIndex = parsedIndex - 1</span>
        }

        <span class="cov0" title="0">return options[selectedIndex], selectedIndex</span>
}

// ShowProgressiveConfirmation shows a multi-step confirmation dialog
// where each step depends on the previous one
func ShowProgressiveConfirmation(steps []string, actions []func() error) error <span class="cov0" title="0">{
        if len(steps) != len(actions) </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch between steps (%d) and actions (%d)", len(steps), len(actions))
        }</span>

        <span class="cov0" title="0">for i, step := range steps </span><span class="cov0" title="0">{
                if !ConfirmAction(fmt.Sprintf("Step %d/%d: %s", i+1, len(steps), step), true) </span><span class="cov0" title="0">{
                        return fmt.Errorf("action cancelled by user at step %d", i+1)
                }</span>

                <span class="cov0" title="0">Info(fmt.Sprintf("Executing step %d/%d: %s", i+1, len(steps), step))
                if err := actions[i](); err != nil </span><span class="cov0" title="0">{
                        Error(fmt.Sprintf("Step %d failed: %s", i+1, err.Error()))
                        return err
                }</span>

                <span class="cov0" title="0">Success(fmt.Sprintf("Step %d/%d completed successfully", i+1, len(steps)))</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package utils

import (
        "fmt"
        "runtime"
        "sync"
        "time"
)

// ResourceManager monitors and manages system resources for the application
type ResourceManager struct {
        maxMemoryPercent float64
        maxCPUPercent    float64
        checkInterval    time.Duration

        // State
        running      bool
        stopChan     chan struct{}
        resourceLock sync.RWMutex

        // Metrics
        memStats         runtime.MemStats
        lastMemoryUsage  uint64
        lastCPUUsage     float64
        lastChecked      time.Time
        resourceWarnings int
}

// NewResourceManager creates a resource manager with default settings
func NewResourceManager() *ResourceManager <span class="cov0" title="0">{
        return &amp;ResourceManager{
                maxMemoryPercent: 80.0, // Default to 80% max memory usage
                maxCPUPercent:    90.0, // Default to 90% max CPU usage
                checkInterval:    5 * time.Second,
                stopChan:         make(chan struct{}),
                resourceWarnings: 0,
                lastChecked:      time.Now(),
        }
}</span>

// SetMaxMemoryPercent sets the maximum allowed memory usage as a percentage
func (rm *ResourceManager) SetMaxMemoryPercent(percent float64) <span class="cov0" title="0">{
        if percent &lt;= 0 || percent &gt; 100 </span><span class="cov0" title="0">{
                Warning("Invalid memory percent value, using default")
                percent = 80.0
        }</span>
        <span class="cov0" title="0">rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()
        rm.maxMemoryPercent = percent</span>
}

// SetMaxCPUPercent sets the maximum allowed CPU usage as a percentage
func (rm *ResourceManager) SetMaxCPUPercent(percent float64) <span class="cov0" title="0">{
        if percent &lt;= 0 || percent &gt; 100 </span><span class="cov0" title="0">{
                Warning("Invalid CPU percent value, using default")
                percent = 90.0
        }</span>
        <span class="cov0" title="0">rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()
        rm.maxCPUPercent = percent</span>
}

// SetCheckInterval sets how often resources are checked
func (rm *ResourceManager) SetCheckInterval(interval time.Duration) <span class="cov0" title="0">{
        if interval &lt; time.Second </span><span class="cov0" title="0">{
                Warning("Check interval too small, using minimum of 1 second")
                interval = time.Second
        }</span>
        <span class="cov0" title="0">rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()
        rm.checkInterval = interval</span>
}

// Start begins monitoring system resources
func (rm *ResourceManager) Start() <span class="cov0" title="0">{
        rm.resourceLock.Lock()
        if rm.running </span><span class="cov0" title="0">{
                rm.resourceLock.Unlock()
                return
        }</span>
        <span class="cov0" title="0">rm.running = true
        rm.resourceLock.Unlock()

        Debug("[RESOURCE]: Resource monitoring started")

        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(rm.checkInterval)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                rm.checkResources()</span>
                        case &lt;-rm.stopChan:<span class="cov0" title="0">
                                Debug("[RESOURCE]: Resource monitoring stopped")
                                return</span>
                        }
                }
        }()
}

// Stop ends resource monitoring
func (rm *ResourceManager) Stop() <span class="cov0" title="0">{
        rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()

        if !rm.running </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">rm.running = false
        rm.stopChan &lt;- struct{}{}</span>
}

// IsRunning returns whether resource monitoring is active
func (rm *ResourceManager) IsRunning() bool <span class="cov0" title="0">{
        rm.resourceLock.RLock()
        defer rm.resourceLock.RUnlock()
        return rm.running
}</span>

// GetResourceUsage returns the current resource usage metrics
func (rm *ResourceManager) GetResourceUsage() map[string]interface{} <span class="cov0" title="0">{
        rm.resourceLock.RLock()
        defer rm.resourceLock.RUnlock()

        // Force an update of the metrics
        runtime.ReadMemStats(&amp;rm.memStats)

        return map[string]interface{}{
                "memoryUsageMB":    rm.memStats.Alloc / 1024 / 1024,
                "totalMemoryMB":    rm.memStats.Sys / 1024 / 1024,
                "numGoroutines":    runtime.NumGoroutine(),
                "resourceWarnings": rm.resourceWarnings,
                "lastChecked":      rm.lastChecked,
                "maxMemoryPercent": rm.maxMemoryPercent,
                "maxCPUPercent":    rm.maxCPUPercent,
        }
}</span>

// checkResources examines current resource usage and takes action if thresholds are exceeded
func (rm *ResourceManager) checkResources() <span class="cov0" title="0">{
        rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()

        rm.lastChecked = time.Now()

        // Get current memory stats
        runtime.ReadMemStats(&amp;rm.memStats)

        // Check memory usage
        totalMemory := rm.memStats.Sys
        usedMemory := rm.memStats.Alloc
        memoryPercent := float64(usedMemory) / float64(totalMemory) * 100

        // Check CPU usage (simplified since Go doesn't provide direct CPU usage)
        numGoroutines := runtime.NumGoroutine()

        // Store current values
        rm.lastMemoryUsage = usedMemory

        // Log resource usage in debug mode
        Debug(fmt.Sprintf("[RESOURCE]: Memory: %.2f%% (%d MB / %d MB), Goroutines: %d",
                memoryPercent, usedMemory/1024/1024, totalMemory/1024/1024, numGoroutines))

        // Check if we're exceeding thresholds
        if memoryPercent &gt; rm.maxMemoryPercent </span><span class="cov0" title="0">{
                rm.resourceWarnings++
                Warning(fmt.Sprintf("[RESOURCE.WARNING]: Memory usage is high: %.2f%% (threshold: %.2f%%)",
                        memoryPercent, rm.maxMemoryPercent))

                // Take action - force garbage collection if memory usage is critical
                if memoryPercent &gt; rm.maxMemoryPercent+10 </span><span class="cov0" title="0">{
                        Info("[RESOURCE]: Forcing garbage collection due to high memory usage")
                        runtime.GC()
                }</span>
        }

        // Check if number of goroutines is unusually high (simplistic approach)
        <span class="cov0" title="0">if numGoroutines &gt; 1000 </span><span class="cov0" title="0">{
                rm.resourceWarnings++
                Warning(fmt.Sprintf("[RESOURCE.WARNING]: High number of goroutines: %d", numGoroutines))
        }</span>
}

// GetRecommendedWorkerCount returns the recommended number of worker goroutines
// based on current system load and available CPU cores
func (rm *ResourceManager) GetRecommendedWorkerCount(defaultWorkers int) int <span class="cov0" title="0">{
        rm.resourceLock.RLock()
        defer rm.resourceLock.RUnlock()

        // Get number of CPU cores
        numCPU := runtime.NumCPU()

        // Calculate recommended worker count
        var recommendedWorkers int

        // If we're under resource pressure, reduce worker count
        if rm.resourceWarnings &gt; 5 </span><span class="cov0" title="0">{
                // Under significant resource pressure
                recommendedWorkers = max(1, numCPU/4)
        }</span> else<span class="cov0" title="0"> if rm.resourceWarnings &gt; 0 </span><span class="cov0" title="0">{
                // Under mild resource pressure
                recommendedWorkers = max(1, numCPU/2)
        }</span> else<span class="cov0" title="0"> {
                // No resource pressure, use 75% of available cores
                recommendedWorkers = max(1, (numCPU*3)/4)
        }</span>

        // If defaultWorkers is specified and smaller than our calculation, use that instead
        <span class="cov0" title="0">if defaultWorkers &gt; 0 &amp;&amp; defaultWorkers &lt; recommendedWorkers </span><span class="cov0" title="0">{
                recommendedWorkers = defaultWorkers
        }</span>

        <span class="cov0" title="0">return recommendedWorkers</span>
}

// Default instance
var defaultResourceManager *ResourceManager
var rmOnce sync.Once

// GetResourceManager returns the default resource manager instance
func GetResourceManager() *ResourceManager <span class="cov0" title="0">{
        rmOnce.Do(func() </span><span class="cov0" title="0">{
                defaultResourceManager = NewResourceManager()
        }</span>)
        <span class="cov0" title="0">return defaultResourceManager</span>
}

// Helper function for Go &lt; 1.21
func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package utils

import (
        "context"
        "fmt"
        "runtime/debug"
        "time"
)

// SafeExecute runs a function with panic recovery
func SafeExecute(operation string, fn func() error) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        Debug("[RECOVERY]: Recovered from panic in " + operation)
                        Debug("[RECOVERY]: Stack trace:\n" + string(debug.Stack()))

                        switch x := r.(type) </span>{
                        case string:<span class="cov8" title="1">
                                err = NewSystemError("Panic occurred", fmt.Errorf("%s", x), map[string]interface{}{
                                        "operation": operation,
                                })</span>
                        case error:<span class="cov0" title="0">
                                err = NewSystemError("Panic occurred", x, map[string]interface{}{
                                        "operation": operation,
                                })</span>
                        default:<span class="cov0" title="0">
                                err = NewSystemError("Panic occurred", fmt.Errorf("%v", x), map[string]interface{}{
                                        "operation": operation,
                                })</span>
                        }
                }
        }()

        <span class="cov8" title="1">return fn()</span>
}

// RetryConfig holds the configuration for retry operations
type RetryConfig struct {
        MaxRetries   int
        InitialDelay time.Duration
        MaxDelay     time.Duration
        Factor       float64 // Exponential backoff factor
}

// DefaultRetryConfig returns the default retry configuration
func DefaultRetryConfig() RetryConfig <span class="cov0" title="0">{
        return RetryConfig{
                MaxRetries:   3,
                InitialDelay: 1 * time.Second,
                MaxDelay:     30 * time.Second,
                Factor:       2.0,
        }
}</span>

// WithRetry executes a function with automatic retries using exponential backoff
func WithRetry(ctx context.Context, operation string, config RetryConfig, fn func() error) error <span class="cov8" title="1">{
        var lastErr error
        delay := config.InitialDelay

        for attempt := 0; attempt &lt;= config.MaxRetries; attempt++ </span><span class="cov8" title="1">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        Debug(fmt.Sprintf("[RETRY]: Attempt %d/%d for operation '%s' after delay of %v",
                                attempt, config.MaxRetries, operation, delay))
                }</span>

                <span class="cov8" title="1">err := SafeExecute(operation, fn)
                if err == nil </span><span class="cov8" title="1">{
                        if attempt &gt; 0 </span><span class="cov0" title="0">{
                                Debug(fmt.Sprintf("[RETRY]: Operation '%s' succeeded after %d attempts",
                                        operation, attempt+1))
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }

                <span class="cov0" title="0">lastErr = err
                Debug(fmt.Sprintf("[RETRY]: Operation '%s' failed (attempt %d/%d): %v",
                        operation, attempt+1, config.MaxRetries, err))

                // Don't sleep if this was the last attempt
                if attempt == config.MaxRetries </span><span class="cov0" title="0">{
                        break</span>
                }

                // Check if context is cancelled before sleeping
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return NewSystemError(
                                "Operation cancelled",
                                ctx.Err(),
                                map[string]interface{}{
                                        "operation": operation,
                                        "attempts":  attempt + 1,
                                },
                        )</span>
                case &lt;-time.After(delay):<span class="cov0" title="0">
                        // Calculate next delay with exponential backoff
                        delay = time.Duration(float64(delay) * config.Factor)
                        if delay &gt; config.MaxDelay </span><span class="cov0" title="0">{
                                delay = config.MaxDelay
                        }</span>
                }
        }

        <span class="cov0" title="0">return NewSystemError(
                fmt.Sprintf("Operation failed after %d attempts", config.MaxRetries+1),
                lastErr,
                map[string]interface{}{
                        "operation":  operation,
                        "maxRetries": config.MaxRetries,
                },
        )</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package utils

import (
        "context"
        "sync"
        "time"
)

// WorkerPool implements a reusable worker pool with configurable concurrency limit
type WorkerPool struct {
        maxWorkers int
        semaphore  chan struct{}
        wg         sync.WaitGroup
        mu         sync.Mutex
        errors     []error
}

// NewWorkerPool creates a new worker pool with the specified maximum concurrent workers
func NewWorkerPool(maxWorkers int) *WorkerPool <span class="cov8" title="1">{
        if maxWorkers &lt;= 0 </span><span class="cov8" title="1">{
                maxWorkers = 1
        }</span>

        <span class="cov8" title="1">return &amp;WorkerPool{
                maxWorkers: maxWorkers,
                semaphore:  make(chan struct{}, maxWorkers),
                errors:     make([]error, 0),
        }</span>
}

// Submit adds a task to the worker pool with the specified timeout
func (wp *WorkerPool) Submit(taskName string, timeout time.Duration, task func() error) <span class="cov8" title="1">{
        wp.wg.Add(1)

        go func() </span><span class="cov8" title="1">{
                defer wp.wg.Done()

                // Acquire semaphore slot (blocks if max workers is reached)
                wp.semaphore &lt;- struct{}{}
                defer func() </span><span class="cov8" title="1">{ &lt;-wp.semaphore }</span>()

                // Create context with timeout
                <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), timeout)
                defer cancel()

                // Channel for task completion
                done := make(chan error, 1)

                // Run the task in a separate goroutine
                go func() </span><span class="cov8" title="1">{
                        err := SafeExecute(taskName, task)
                        done &lt;- err
                }</span>()

                // Wait for either task completion or timeout
                <span class="cov8" title="1">select </span>{
                case err := &lt;-done:<span class="cov8" title="1">
                        if err != nil </span><span class="cov8" title="1">{
                                wp.addError(err)
                        }</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        wp.addError(NewSystemError(
                                "Task timed out",
                                ctx.Err(),
                                map[string]interface{}{
                                        "taskName": taskName,
                                        "timeout":  timeout.String(),
                                },
                        ))</span>
                }
        }()
}

// Wait blocks until all tasks have completed
func (wp *WorkerPool) Wait() []error <span class="cov8" title="1">{
        wp.wg.Wait()
        return wp.Errors()
}</span>

// Errors returns all errors collected from task execution
func (wp *WorkerPool) Errors() []error <span class="cov8" title="1">{
        wp.mu.Lock()
        defer wp.mu.Unlock()

        // Make a copy to avoid race conditions
        errCopy := make([]error, len(wp.errors))
        copy(errCopy, wp.errors)

        return errCopy
}</span>

// HasErrors returns true if any tasks have reported errors
func (wp *WorkerPool) HasErrors() bool <span class="cov0" title="0">{
        wp.mu.Lock()
        defer wp.mu.Unlock()
        return len(wp.errors) &gt; 0
}</span>

// addError safely adds an error to the error list
func (wp *WorkerPool) addError(err error) <span class="cov8" title="1">{
        wp.mu.Lock()
        defer wp.mu.Unlock()
        wp.errors = append(wp.errors, err)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
