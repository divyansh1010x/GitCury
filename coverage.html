
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">GitCury/api/config.go (0.0%)</option>
				
				<option value="file1">GitCury/cmd/alias.go (0.0%)</option>
				
				<option value="file2">GitCury/cmd/commit.go (0.0%)</option>
				
				<option value="file3">GitCury/cmd/config.go (0.0%)</option>
				
				<option value="file4">GitCury/cmd/end_to_end.go (0.0%)</option>
				
				<option value="file5">GitCury/cmd/msgs.go (0.0%)</option>
				
				<option value="file6">GitCury/cmd/output.go (0.0%)</option>
				
				<option value="file7">GitCury/cmd/push.go (0.0%)</option>
				
				<option value="file8">GitCury/cmd/root.go (0.0%)</option>
				
				<option value="file9">GitCury/cmd/setup.go (0.0%)</option>
				
				<option value="file10">GitCury/config/clustering.go (0.0%)</option>
				
				<option value="file11">GitCury/config/config.go (0.0%)</option>
				
				<option value="file12">GitCury/config/reset_config.go (0.0%)</option>
				
				<option value="file13">GitCury/core/commit.go (0.0%)</option>
				
				<option value="file14">GitCury/core/msgs.go (0.0%)</option>
				
				<option value="file15">GitCury/core/push.go (0.0%)</option>
				
				<option value="file16">GitCury/di/gemini.go (0.0%)</option>
				
				<option value="file17">GitCury/embeddings/embeddings.go (0.0%)</option>
				
				<option value="file18">GitCury/git/clustering.go (0.0%)</option>
				
				<option value="file19">GitCury/git/default_runner.go (0.0%)</option>
				
				<option value="file20">GitCury/git/git.go (0.0%)</option>
				
				<option value="file21">GitCury/git/progress.go (0.0%)</option>
				
				<option value="file22">GitCury/git/recovery.go (0.0%)</option>
				
				<option value="file23">GitCury/handlers/handlers.go (0.0%)</option>
				
				<option value="file24">GitCury/main.go (0.0%)</option>
				
				<option value="file25">GitCury/output/output.go (0.0%)</option>
				
				<option value="file26">GitCury/tests/mock/gemini_mock.go (0.0%)</option>
				
				<option value="file27">GitCury/tests/mock/git_mock.go (0.0%)</option>
				
				<option value="file28">GitCury/tests/testutils/test_env.go (0.0%)</option>
				
				<option value="file29">GitCury/utils/creative_loader.go (0.0%)</option>
				
				<option value="file30">GitCury/utils/default_runner.go (0.0%)</option>
				
				<option value="file31">GitCury/utils/errors.go (0.0%)</option>
				
				<option value="file32">GitCury/utils/files.go (0.0%)</option>
				
				<option value="file33">GitCury/utils/gemini.go (0.0%)</option>
				
				<option value="file34">GitCury/utils/logger.go (0.0%)</option>
				
				<option value="file35">GitCury/utils/progress.go (0.0%)</option>
				
				<option value="file36">GitCury/utils/prompt.go (0.0%)</option>
				
				<option value="file37">GitCury/utils/resource.go (0.0%)</option>
				
				<option value="file38">GitCury/utils/retry.go (0.0%)</option>
				
				<option value="file39">GitCury/utils/stats.go (0.0%)</option>
				
				<option value="file40">GitCury/utils/stats_clustering.go (0.0%)</option>
				
				<option value="file41">GitCury/utils/string_utils.go (0.0%)</option>
				
				<option value="file42">GitCury/utils/workerpool.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "os"
        "sync"
)

var (
        // APIConfig holds common settings for API interactions
        APIConfig struct {
                MaxRetries    int
                RetryDelay    int
                GeminiAPIKey  string
                MaxConcurrent int
                Timeout       int
        }

        // configMutex protects concurrent access to the API configuration
        configMutex sync.RWMutex
)

// SetRetryConfig sets the retry configuration for API calls
func SetRetryConfig(maxRetries, retryDelay int) <span class="cov0" title="0">{
        configMutex.Lock()
        defer configMutex.Unlock()

        // Ensure we have sensible defaults
        if maxRetries &lt;= 0 </span><span class="cov0" title="0">{
                maxRetries = 3 // Default to 3 retries
        }</span>

        <span class="cov0" title="0">if retryDelay &lt;= 0 </span><span class="cov0" title="0">{
                retryDelay = 5 // Default to 5 seconds
        }</span>

        <span class="cov0" title="0">APIConfig.MaxRetries = maxRetries
        APIConfig.RetryDelay = retryDelay</span>
}

// SetAPIKey sets the Gemini API key
func SetAPIKey(apiKey string) <span class="cov0" title="0">{
        configMutex.Lock()
        defer configMutex.Unlock()
        APIConfig.GeminiAPIKey = apiKey
}</span>

// GetAPIKey returns the Gemini API key
func GetAPIKey() string <span class="cov0" title="0">{
        configMutex.RLock()
        defer configMutex.RUnlock()
        return APIConfig.GeminiAPIKey
}</span>

// GetRetryConfig returns the current max retries and retry delay settings
func GetRetryConfig() (int, int) <span class="cov0" title="0">{
        configMutex.RLock()
        defer configMutex.RUnlock()
        return APIConfig.MaxRetries, APIConfig.RetryDelay
}</span>

// SetConcurrencyConfig sets the max concurrent API calls and timeout
func SetConcurrencyConfig(maxConcurrent, timeout int) <span class="cov0" title="0">{
        configMutex.Lock()
        defer configMutex.Unlock()

        // Ensure we have sensible defaults
        if maxConcurrent &lt;= 0 </span><span class="cov0" title="0">{
                maxConcurrent = 5 // Default to 5 concurrent calls
        }</span>

        <span class="cov0" title="0">if timeout &lt;= 0 </span><span class="cov0" title="0">{
                timeout = 30 // Default to 30 seconds timeout
        }</span>

        <span class="cov0" title="0">APIConfig.MaxConcurrent = maxConcurrent
        APIConfig.Timeout = timeout</span>
}

// GetConcurrencyConfig returns the current max concurrent calls and timeout settings
func GetConcurrencyConfig() (int, int) <span class="cov0" title="0">{
        configMutex.RLock()
        defer configMutex.RUnlock()
        return APIConfig.MaxConcurrent, APIConfig.Timeout
}</span>

// Init initializes the API configuration with defaults
func Init() <span class="cov0" title="0">{
        SetRetryConfig(3, 5)
        SetConcurrencyConfig(5, 30)
}</span>

func init() <span class="cov0" title="0">{
        // Set default values when the package is imported
        Init()
}</span>

// LoadConfig loads the API configuration from the given settings map
func LoadConfig(settings map[string]interface{}) <span class="cov0" title="0">{
        // Initialize retry configuration
        retriesValue, ok := settings["retries"].(int)
        if !ok </span><span class="cov0" title="0">{
                // Try to convert from float64 (JSON numbers)
                if retriesFloat, ok := settings["retries"].(float64); ok </span><span class="cov0" title="0">{
                        retriesValue = int(retriesFloat)
                }</span> else<span class="cov0" title="0"> {
                        // Default if not found or invalid
                        retriesValue = 3
                }</span>
        }

        // Initialize timeout configuration
        <span class="cov0" title="0">timeoutValue, ok := settings["timeout"].(int)
        if !ok </span><span class="cov0" title="0">{
                // Try to convert from float64 (JSON numbers)
                if timeoutFloat, ok := settings["timeout"].(float64); ok </span><span class="cov0" title="0">{
                        timeoutValue = int(timeoutFloat)
                }</span> else<span class="cov0" title="0"> {
                        // Default if not found or invalid
                        timeoutValue = 30
                }</span>
        }

        // Get max concurrent value
        <span class="cov0" title="0">maxConcurrentValue, ok := settings["maxConcurrent"].(int)
        if !ok </span><span class="cov0" title="0">{
                // Try to convert from float64 (JSON numbers)
                if maxConcurrentFloat, ok := settings["maxConcurrent"].(float64); ok </span><span class="cov0" title="0">{
                        maxConcurrentValue = int(maxConcurrentFloat)
                }</span> else<span class="cov0" title="0"> {
                        // Default if not found or invalid
                        maxConcurrentValue = 5
                }</span>
        }

        // Get API key
        <span class="cov0" title="0">apiKey, _ := settings["GEMINI_API_KEY"].(string)
        if apiKey == "" </span><span class="cov0" title="0">{
                // Try environment variable
                apiKey = os.Getenv("GEMINI_API_KEY")
        }</span>

        // Update the API configuration
        <span class="cov0" title="0">SetRetryConfig(retriesValue, timeoutValue)
        SetConcurrencyConfig(maxConcurrentValue, timeoutValue)
        SetAPIKey(apiKey)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "GitCury/config"
        "GitCury/utils"

        "github.com/spf13/cobra"
)

var Aliases = make(map[string]string)

func loadAliases() <span class="cov0" title="0">{
        if len(Aliases) &gt; 0 </span><span class="cov0" title="0">{
                return // Already loaded
        }</span>

        <span class="cov0" title="0">rawAliases := config.Get("aliases")
        if rawAliases == nil </span><span class="cov0" title="0">{
                // Use default aliases if none configured
                Aliases = map[string]string{
                        "commit":  config.DefaultAliases.Commit,
                        "push":    config.DefaultAliases.Push,
                        "getmsgs": config.DefaultAliases.GetMsgs,
                        "output":  config.DefaultAliases.Output,
                        "config":  config.DefaultAliases.Config,
                        "setup":   config.DefaultAliases.Setup,
                        "boom":    config.DefaultAliases.Boom,
                }
                return
        }</span>

        <span class="cov0" title="0">if aliasMap, ok := rawAliases.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                convertedAliases := make(map[string]string)
                for key, value := range aliasMap </span><span class="cov0" title="0">{
                        if strValue, ok := value.(string); ok </span><span class="cov0" title="0">{
                                convertedAliases[key] = strValue
                        }</span>
                }
                <span class="cov0" title="0">Aliases = convertedAliases</span>
        }
}

var aliasCmd = &amp;cobra.Command{
        Use:   "alias",
        Short: "Manage command aliases",
        Long: `
Manage command aliases for GitCury.

Options:
• --add &lt;command&gt; &lt;alias&gt; : Add a new alias for a command.
• --remove &lt;alias&gt; : Remove an existing alias.
• --list : List all existing aliases.

Examples:
• Add an alias for the 'commit' command:
        gitcury alias --add commit cm

• Remove an alias:
        gitcury alias --remove cm

• List all aliases:
        gitcury alias --list

[NOTICE]: Ensure aliases do not conflict with existing commands.
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                loadAliases() // Ensure aliases are loaded
                if cmd.Flag("add").Changed </span><span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                utils.Error("Invalid arguments. Usage: --add &lt;command&gt; &lt;alias&gt;")
                                cmd.Help()
                                return
                        }</span>
                        <span class="cov0" title="0">utils.Info("Adding alias '" + args[1] + "' for command '" + args[0] + "'.")
                        Aliases[args[0]] = args[1]
                        config.Set("aliases", Aliases)
                        utils.Success("Alias added successfully.")</span>
                } else<span class="cov0" title="0"> if cmd.Flag("remove").Changed </span><span class="cov0" title="0">{
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                utils.Error("Invalid arguments. Usage: --remove &lt;alias&gt;")
                                cmd.Help()
                                return
                        }</span>
                        <span class="cov0" title="0">utils.Info("Removing alias '" + args[0] + "'.")
                        delete(Aliases, args[0])
                        config.Set("aliases", Aliases)
                        utils.Success("Alias removed successfully.")</span>
                } else<span class="cov0" title="0"> if cmd.Flag("list").Changed </span><span class="cov0" title="0">{
                        utils.Info("Listing all aliases.")
                        for cmdName, alias := range Aliases </span><span class="cov0" title="0">{
                                cmd.Printf("%s -&gt; %s\n", cmdName, alias)
                        }</span>
                        <span class="cov0" title="0">utils.Success("Alias listing completed.")</span>
                } else<span class="cov0" title="0"> {
                        utils.Error("No valid flag provided. Use --add, --remove, or --list.")
                        cmd.Help()
                }</span>
        },
}

func ReampAlias(root *cobra.Command) <span class="cov0" title="0">{
        loadAliases() // Ensure aliases are loaded before remapping
        utils.Debug("Re-mapping aliases to commands.")
        for cmdName, alias := range Aliases </span><span class="cov0" title="0">{
                cmd, _, err := root.Find([]string{cmdName})
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Error finding command '" + cmdName + "' - " + err.Error())
                        continue</span>
                }
                <span class="cov0" title="0">if cmd == nil </span><span class="cov0" title="0">{
                        utils.Error("Command '" + cmdName + "' not found.")
                        continue</span>
                }
                <span class="cov0" title="0">cmd.Aliases = append(cmd.Aliases, alias)
                utils.Debug("Alias '" + alias + "' mapped to command '" + cmdName + "'.")</span>
        }
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(aliasCmd)
        aliasCmd.Flags().StringSliceP("add", "a", []string{}, "Add a new alias for a command")
        aliasCmd.Flags().StringP("remove", "r", "", "Remove an existing alias")
        aliasCmd.Flags().BoolP("list", "l", false, "List all existing aliases")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// package cmd

// import (
//         "GitCury/config"
//         "GitCury/core"
//         "GitCury/git"
//         "GitCury/utils"
//         "os"
//         "time"

//         "github.com/spf13/cobra"
// )

// var (
//         sealDateTime string
//         sealAllFlag  bool
//         folderName   string
// )

// var commitCmd = &amp;cobra.Command{
//         Use:   "commit",
//         Short: "Commit changes with autogenerated commit messages",
//         Long: `
// Commit changes with autogenerated commit messages.

// Aliases:
// • ` + config.Aliases.Commit + `

// Options:
// • --all : Commit all changes with autogenerated messages.
// • --root &lt;folder&gt; : Commit changes in a specific root folder with autogenerated messages.

// Examples:
// • Commit all changes:
//         gitcury commit --all

// • Commit changes in a folder:
//         gitcury commit --root my-folder

// [NOTICE]: Ensure the commit messages are generated before committing.
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 // Use our SafeExecute function to add panic recovery
//                 err := utils.SafeExecute("CommitChanges", func() error {
//                         if sealAllFlag {
//                                 utils.Info("[" + config.Aliases.Commit + "]: Committing all changes across root folders.")
//                                 err := core.CommitAllRoots()
//                                 if err != nil {
//                                         return utils.NewGitError(
//                                                 "Failed to commit all changes",
//                                                 err,
//                                                 map[string]interface{}{
//                                                         "operation": "CommitAllRoots",
//                                                 },
//                                         )
//                                 }
//                                 utils.Success("[" + config.Aliases.Commit + "]: All changes committed successfully.")
//                         } else if folderName != "" {
//                                 // Validate the folder exists
//                                 if _, err := os.Stat(folderName); os.IsNotExist(err) {
//                                         return utils.NewValidationError(
//                                                 "Root folder does not exist",
//                                                 err,
//                                                 map[string]interface{}{
//                                                         "folderName": folderName,
//                                                 },
//                                         )
//                                 }

//                                 utils.Info("[" + config.Aliases.Commit + "]: Targeting root folder: " + folderName)
//                                 err := core.CommitOneRoot(folderName)
//                                 if err != nil {
//                                         return utils.NewGitError(
//                                                 "Failed to commit changes in folder",
//                                                 err,
//                                                 map[string]interface{}{
//                                                         "operation": "CommitOneRoot",
//                                                         "folder": folderName,
//                                                 },
//                                         )
//                                 }
//                                 utils.Success("[" + config.Aliases.Commit + "]: Changes in the specified folder committed successfully.")
//                         } else {
//                                 return utils.NewValidationError(
//                                         "You must specify either --all or --root flag",
//                                         nil,
//                                         map[string]interface{}{
//                                                 "availableFlags": []string{"--all", "--root"},
//                                         },
//                                 )
//                         }
//                         return nil
//                 })

//                 if err != nil {
//                         utils.Error(utils.ToUserFriendlyMessage(err))
//                 }
//         },
// }

// var withDateCmd = &amp;cobra.Command{
//         Use:   "with-date",
//         Short: "Commit changes with a specified timestamp",
//         Long: `
// Commit changes with a specific date and time.

// Options:
// • --all : Commit all changes with the given timestamp.
// • --root &lt;folder&gt; : Commit changes in a specific folder with the given timestamp.

// Examples:
// • Commit all changes with a timestamp:
//         gitcury commit with-date --datetime "2025-01-01T12:00:00" --all

// • Commit changes in a folder with a timestamp:
//         gitcury commit with-date --datetime "2025-01-01T12:00:00" --root my-folder

// [NOTICE]: Ensure the date and time format is 'YYYY-MM-DDTHH:MM:SS'.
// [NOTICE]: The system date and time will not be changed; only the commit date and time will be set.
// [NOTICE]: Use with caution, as this may affect commit history and collaboration.
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 err := utils.SafeExecute("CommitWithDate", func() error {
//                         if sealDateTime == "" {
//                                 return utils.NewValidationError(
//                                         "Datetime parameter is required",
//                                         nil,
//                                         map[string]interface{}{
//                                                 "requiredFormat": "YYYY-MM-DDTHH:MM:SS",
//                                                 "example": "2025-01-01T12:00:00",
//                                         },
//                                 )
//                         }

//                         // Validate date-time format
//                         _, err := time.Parse("2006-01-02T15:04:05", sealDateTime)
//                         if err != nil {
//                                 return utils.NewValidationError(
//                                         "Invalid datetime format",
//                                         err,
//                                         map[string]interface{}{
//                                                 "providedValue": sealDateTime,
//                                                 "requiredFormat": "YYYY-MM-DDTHH:MM:SS",
//                                                 "example": "2025-01-01T12:00:00",
//                                         },
//                                 )
//                         }

//                         // Set Git environment variables for the commit
//                         env := append(os.Environ(),
//                                 "GIT_AUTHOR_DATE="+sealDateTime,
//                                 "GIT_COMMITTER_DATE="+sealDateTime,
//                         )
//                         utils.Info("[" + config.Aliases.Commit + "]: Setting commit date and time to: " + sealDateTime)

//                         // Execute commit logic
//                         if sealAllFlag {
//                                 utils.Info("[" + config.Aliases.Commit + "]: Committing all changes with custom timestamp.")
//                                 err := core.CommitAllRoots(env)
//                                 if err != nil {
//                                         return utils.NewGitError(
//                                                 "Failed to commit all changes with custom timestamp",
//                                                 err,
//                                                 map[string]interface{}{
//                                                         "operation": "CommitAllRoots",
//                                                         "timestamp": sealDateTime,
//                                                 },
//                                         )
//                                 }
//                         } else if folderName != "" {
//                                 // Validate the folder exists
//                                 if _, err := os.Stat(folderName); os.IsNotExist(err) {
//                                         return utils.NewValidationError(
//                                                 "Root folder does not exist",
//                                                 err,
//                                                 map[string]interface{}{
//                                                         "folderName": folderName,
//                                                 },
//                                         )
//                                 }

//                                 utils.Info("[" + config.Aliases.Commit + "]: Committing changes in folder with custom timestamp: " + folderName)
//                                 err := core.CommitOneRoot(folderName, env)
//                                 if err != nil {
//                                         return utils.NewGitError(
//                                                 "Failed to commit changes in folder with custom timestamp",
//                                                 err,
//                                                 map[string]interface{}{
//                                                         "operation": "CommitOneRoot",
//                                                         "folder": folderName,
//                                                         "timestamp": sealDateTime,
//                                                 },
//                                         )
//                                 }
//                         } else {
//                                 return utils.NewValidationError(
//                                         "You must specify either --all or --root flag",
//                                         nil,
//                                         map[string]interface{}{
//                                                 "availableFlags": []string{"--all", "--root"},
//                                         },
//                                 )
//                         }

//                         utils.Success("[" + config.Aliases.Commit + "]: Changes committed with the specified timestamp successfully.")
//                         return nil
//                 })

//                 if err != nil {
//                         utils.Error(utils.ToUserFriendlyMessage(err))
//                 }
//         },
// }

// func init() {
//         // Add flags for the with-date subcommand
//         withDateCmd.Flags().StringVarP(&amp;sealDateTime, "datetime", "d", "", "Specify the commit date and time in 'YYYY-MM-DDTHH:MM:SS' format")
//         withDateCmd.Flags().BoolVarP(&amp;sealAllFlag, "all", "a", false, "Commit all changes with autogenerated messages")
//         withDateCmd.Flags().StringVarP(&amp;folderName, "root", "r", "", "Commit changes in the specified root folder with autogenerated messages")

//         // Add the with-date subcommand to the seal command
//         commitCmd.AddCommand(withDateCmd)

//         // Add flags to the main seal command
//         commitCmd.Flags().BoolVarP(&amp;sealAllFlag, "all", "a", false, "Commit all changes with autogenerated messages")
//         commitCmd.Flags().StringVarP(&amp;folderName, "root", "r", "", "Commit changes in the specified root folder with autogenerated messages")

//         // Add the seal command to the root command
//         rootCmd.AddCommand(commitCmd)
// }

package cmd

import (
        "GitCury/config"
        "GitCury/core"
        "GitCury/utils"
        "os"
        "time"

        "github.com/spf13/cobra"
)

var (
        sealDateTime string
        sealAllFlag  bool
        folderName   string
)

var commitCmd = &amp;cobra.Command{
        Use:   "commit",
        Short: "Commit changes with autogenerated commit messages",
        Long: `
Commit changes with autogenerated commit messages.

Aliases:
• ` + config.Aliases.Commit + `

Options:
• --all : Commit all changes with autogenerated messages.
• --root &lt;folder&gt; : Commit changes in a specific root folder with autogenerated messages.

Examples:
• Commit all changes:
        gitcury commit --all

• Commit changes in a folder:
        gitcury commit --root my-folder

[NOTICE]: Ensure the commit messages are generated before committing.
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Use our SafeExecute function to add panic recovery
                err := utils.SafeExecute("CommitChanges", func() error </span><span class="cov0" title="0">{
                        if sealAllFlag </span><span class="cov0" title="0">{
                                utils.Info("Committing all changes across root folders...")
                                err := core.CommitAllRoots()
                                if err != nil </span><span class="cov0" title="0">{
                                        return utils.NewGitError(
                                                "Failed to commit all changes",
                                                err,
                                                map[string]interface{}{
                                                        "operation": "CommitAllRoots",
                                                },
                                        )
                                }</span>
                                <span class="cov0" title="0">utils.Success("✅ All changes committed successfully.")</span>
                        } else<span class="cov0" title="0"> if folderName != "" </span><span class="cov0" title="0">{
                                // Validate the folder exists
                                if _, err := os.Stat(folderName); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        return utils.NewValidationError(
                                                "Root folder does not exist",
                                                err,
                                                map[string]interface{}{
                                                        "folderName": folderName,
                                                },
                                        )
                                }</span>

                                <span class="cov0" title="0">utils.Info("Committing changes in folder: " + folderName)
                                err := core.CommitOneRoot(folderName)
                                if err != nil </span><span class="cov0" title="0">{
                                        return utils.NewGitError(
                                                "Failed to commit changes in folder",
                                                err,
                                                map[string]interface{}{
                                                        "operation": "CommitOneRoot",
                                                        "folder":    folderName,
                                                },
                                        )
                                }</span>
                                <span class="cov0" title="0">utils.Success("✅ Changes in folder committed successfully.")</span>
                        } else<span class="cov0" title="0"> {
                                return utils.NewValidationError(
                                        "You must specify either --all or --root flag",
                                        nil,
                                        map[string]interface{}{
                                                "availableFlags": []string{"--all", "--root"},
                                        },
                                )
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        utils.Error(utils.ToUserFriendlyMessage(err))
                }</span>
        },
}

var withDateCmd = &amp;cobra.Command{
        Use:   "with-date",
        Short: "Commit changes with a specified timestamp",
        Long: `
Commit changes with a specific date and time.

Options:
• --all : Commit all changes with the given timestamp.
• --root &lt;folder&gt; : Commit changes in a specific folder with the given timestamp.

Examples:
• Commit all changes with a timestamp:
        gitcury commit with-date --datetime "2025-01-01T12:00:00" --all

• Commit changes in a folder with a timestamp:
        gitcury commit with-date --datetime "2025-01-01T12:00:00" --root my-folder

[NOTICE]: Ensure the date and time format is 'YYYY-MM-DDTHH:MM:SS'.
[NOTICE]: The system date and time will not be changed; only the commit date and time will be set.
[NOTICE]: Use with caution, as this may affect commit history and collaboration.
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                err := utils.SafeExecute("CommitWithDate", func() error </span><span class="cov0" title="0">{
                        if sealDateTime == "" </span><span class="cov0" title="0">{
                                return utils.NewValidationError(
                                        "Datetime parameter is required",
                                        nil,
                                        map[string]interface{}{
                                                "requiredFormat": "YYYY-MM-DDTHH:MM:SS",
                                                "example":        "2025-01-01T12:00:00",
                                        },
                                )
                        }</span>

                        // Validate date-time format
                        <span class="cov0" title="0">parsedTime, err := time.Parse("2006-01-02T15:04:05", sealDateTime)
                        if err != nil </span><span class="cov0" title="0">{
                                return utils.NewValidationError(
                                        "Invalid datetime format",
                                        err,
                                        map[string]interface{}{
                                                "providedValue":  sealDateTime,
                                                "requiredFormat": "YYYY-MM-DDTHH:MM:SS",
                                                "example":        "2025-01-01T12:00:00",
                                        },
                                )
                        }</span>

                        // Check if the date is in the future
                        <span class="cov0" title="0">now := time.Now()
                        if parsedTime.After(now) </span><span class="cov0" title="0">{
                                utils.Warning("The specified datetime is in the future. This may cause issues with Git history.")

                                // Ask for confirmation before proceeding with future date
                                details := []string{
                                        "You are attempting to create a commit with a future date: " + sealDateTime,
                                        "Current date and time: " + now.Format(time.RFC3339),
                                        "This may cause confusion in git history and affect collaboration.",
                                }

                                if !utils.ConfirmActionWithDetails("Commit with future date?", details, false) </span><span class="cov0" title="0">{
                                        return utils.NewUserError(
                                                "Operation cancelled by user",
                                                nil,
                                                map[string]interface{}{
                                                        "providedDate": sealDateTime,
                                                        "currentDate":  now.Format(time.RFC3339),
                                                },
                                        )
                                }</span>
                        }

                        // Format date-time for Git environment variables (ISO 8601 format)
                        <span class="cov0" title="0">formattedDateTime := parsedTime.Format(time.RFC3339)

                        // Set Git environment variables for the commit
                        env := append(os.Environ(),
                                "GIT_AUTHOR_DATE="+formattedDateTime,
                                "GIT_COMMITTER_DATE="+formattedDateTime,
                        )

                        // Execute commit logic
                        if sealAllFlag </span><span class="cov0" title="0">{
                                utils.Info("Committing all changes with custom timestamp...")
                                err := core.CommitAllRoots(env)
                                if err != nil </span><span class="cov0" title="0">{
                                        return utils.NewGitError(
                                                "Failed to commit all changes with custom timestamp",
                                                err,
                                                map[string]interface{}{
                                                        "operation": "CommitAllRoots",
                                                        "timestamp": formattedDateTime,
                                                },
                                        )
                                }</span>
                        } else<span class="cov0" title="0"> if folderName != "" </span><span class="cov0" title="0">{
                                // Validate the folder exists
                                if _, err := os.Stat(folderName); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        return utils.NewValidationError(
                                                "Root folder does not exist",
                                                err,
                                                map[string]interface{}{
                                                        "folderName": folderName,
                                                        "suggestion": "Check the folder path and try again",
                                                },
                                        )
                                }</span>

                                <span class="cov0" title="0">utils.Info("Committing changes in folder with custom timestamp: " + folderName)

                                // Use core.CommitOneRoot with custom environment variables for timestamp
                                err := core.CommitOneRoot(folderName, env)

                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return utils.NewValidationError(
                                        "You must specify either --all or --root flag",
                                        nil,
                                        map[string]interface{}{
                                                "availableFlags": []string{"--all", "--root"},
                                                "examples": []string{
                                                        "gitcury commit with-date --datetime \"2025-01-01T12:00:00\" --all",
                                                        "gitcury commit with-date --datetime \"2025-01-01T12:00:00\" --root my-folder",
                                                },
                                        },
                                )
                        }</span>

                        <span class="cov0" title="0">utils.Success("✅ Changes committed with the specified timestamp successfully.")
                        return nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        utils.Error(utils.ToUserFriendlyMessage(err))
                }</span>
        },
}

func init() <span class="cov0" title="0">{
        // Add flags for the with-date subcommand
        withDateCmd.Flags().StringVarP(&amp;sealDateTime, "datetime", "t", "", "Specify the commit date and time in 'YYYY-MM-DDTHH:MM:SS' format")
        withDateCmd.Flags().BoolVarP(&amp;sealAllFlag, "all", "a", false, "Commit all changes with autogenerated messages")
        withDateCmd.Flags().StringVarP(&amp;folderName, "root", "r", "", "Commit changes in the specified root folder with autogenerated messages")

        // Add the with-date subcommand to the seal command
        commitCmd.AddCommand(withDateCmd)

        // Add flags to the main seal command
        commitCmd.Flags().BoolVarP(&amp;sealAllFlag, "all", "a", false, "Commit all changes with autogenerated messages")
        commitCmd.Flags().StringVarP(&amp;folderName, "root", "r", "", "Commit changes in the specified root folder with autogenerated messages")

        // Add the seal command to the root command
        rootCmd.AddCommand(commitCmd)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// package cmd

// import (
//         "GitCury/config"
//         "GitCury/utils"
//         "encoding/json"
//         "strings"

//         "github.com/spf13/cobra"
// )

// var deleteConfig bool
// var configSetKey string
// var configSetValue string

// var configCmd = &amp;cobra.Command{
//         Use:   "config",
//         Short: "Manage GitCury configuration",
//         Long:  "Get and set configuration for GitCury including API keys, root folders, and other parameters.",
//         Run: func(cmd *cobra.Command, args []string) {
//                 if deleteConfig {
//                         config.Delete()
//                         utils.Info("Configuration deleted.")
//                         return
//                 }

//                 conf := config.GetAll()
//                 b, _ := json.MarshalIndent(conf, "", "  ")
//                 utils.Print("\n==================== GitCury Configuration ====================\n")
//                 utils.Print(string(b))
//                 utils.Print("\n==============================================================\n")
//         },
// }

// var configSetCmd = &amp;cobra.Command{
//         Use:   "set",
//         Short: "Set a configuration key-value pair",
//         Long: `
// The 'config set' command allows you to configure GitCury by setting a specific key-value pair.
// This command is essential for customizing the application's behavior and ensuring it operates as per your requirements.

// Usage:
//         gitcury config set --key &lt;key&gt; --value &lt;value&gt;

// Description:
//         This command updates the application's configuration by assigning the specified value to the given key.
//         It supports both simple key-value pairs and more complex configurations like lists of paths.

// Key Details:
//         - GEMINI_API_KEY (Required): The API key for the Gemini service, which is critical for generating AI-powered commit messages.
//         - root_folders (Optional): A comma-separated list of root folder paths where Git operations should be scoped. Example: "/path/to/folder1,/path/to/folder2".
//         - numFilesToCommit (Optional): The maximum number of files to include in a single commit operation. Default is 5.
//         - app_name (Optional): The name of the application. Default is "GitCury".
//         - version (Optional): The version of the application. Default is "1.0.0".
//         - log_level (Optional): The logging level for the application. Default is "info".
//         - editor (Optional): The text editor to use for editing commit messages. Default is "nano".
//         - output_file_path (Optional): The path to the output file where generated commit messages are stored. Default is "$HOME/.gitcury/output.json".

// Examples:
//         - Set a single configuration value:
//                         gitcury config set --key theme --value dark

//         - Set multiple root folders:
//                         gitcury config set --key root_folders --value /path/to/folder1,/path/to/folder2

// Important Notes:
//         - Both the --key and --value flags are mandatory. If either is missing, the command will not execute.
//         - The "root_folders" key is treated specially and expects a comma-separated list of folder paths, which will be stored as an array of strings.
//         - Ensure that the key you are setting is valid and recognized by the application to avoid unexpected behavior.
//         - Use this command to configure critical settings like API keys and operational parameters for GitCury.
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 if configSetKey == "" || configSetValue == "" {
//                         utils.Error("Both --key and --value flags are required.")
//                         return
//                 }

//                 // Check if the key is "root_folders" to handle it as an array of strings
//                 if configSetKey == "root_folders" {
//                         // Split the value by commas to create an array of strings
//                         values := strings.Split(configSetValue, ",")
//                         for i := range values {
//                                 values[i] = strings.TrimSpace(values[i]) // Trim spaces around each value
//                         }
//                         config.Set(configSetKey, values) // Save as an array of strings
//                         utils.Info("Configuration updated: " + configSetKey + " = " + utils.ToJSON(values))
//                 } else {
//                         // Handle other keys as a single string value
//                         config.Set(configSetKey, configSetValue)
//                         utils.Info("Configuration updated: " + configSetKey + " = " + configSetValue)
//                 }
//         },
// }

// var configRemoveKey string
// var configRemoveRoot string

// var configRemoveCmd = &amp;cobra.Command{
//         Use:   "remove",
//         Short: "Remove a configuration key or a specific root folder",
//         Long: `
// The 'config remove' command allows you to remove a configuration key or a specific root folder from the configuration.

// Usage:
//         gitcury config remove --key &lt;key&gt;
//         gitcury config remove --root &lt;root_folder&gt;

// Description:
//         - Use the --key flag to remove an entire configuration key and its value.
//         - Use the --root flag to remove a specific root folder from the "root_folders" configuration.

// Examples:
//         - Remove a configuration key:
//                         gitcury config remove --key theme

//         - Remove a specific root folder:
//                         gitcury config remove --root /path/to/folder1
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 if configRemoveKey != "" {
//                         // Remove the entire key from the configuration
//                         config.Remove(configRemoveKey)
//                         utils.Info("Configuration key removed: " + configRemoveKey)
//                 } else if configRemoveRoot != "" {
//                         // Remove a specific root folder from "root_folders"
//                         rootFolders, ok := config.Get("root_folders").([]string)
//                         if !ok {
//                                 utils.Error("'root_folders' is not configured or is not a list.")
//                                 return
//                         }

//                         // Filter out the root folder to be removed
//                         updatedFolders := []string{}
//                         for _, folder := range rootFolders {
//                                 if folder != configRemoveRoot {
//                                         updatedFolders = append(updatedFolders, folder)
//                                 }
//                         }

//                         // Update the configuration
//                         config.Set("root_folders", updatedFolders)
//                         utils.Info("Root folder removed: " + configRemoveRoot)
//                 } else {
//                         utils.Error("Either --key or --root flag must be provided.")
//                 }
//         },
// }

// func init() {
//         configSetCmd.Flags().StringVarP(&amp;configSetKey, "key", "k", "", "Configuration key to set")
//         configSetCmd.Flags().StringVarP(&amp;configSetValue, "value", "v", "", "Configuration value to set")

//         configRemoveCmd.Flags().StringVarP(&amp;configRemoveKey, "key", "k", "", "Configuration key to remove")
//         configRemoveCmd.Flags().StringVarP(&amp;configRemoveRoot, "root", "r", "", "Specific root folder to remove")

//         configCmd.Flags().BoolVarP(&amp;deleteConfig, "delete", "d", false, "Delete the entire configuration")
//         configCmd.AddCommand(configRemoveCmd)
//         configCmd.AddCommand(configSetCmd)

//         rootCmd.AddCommand(configCmd)
// }

// package cmd

// import (
//         "GitCury/config"
//         "GitCury/utils"
//         "encoding/json"
//         "strings"

//         "github.com/spf13/cobra"
// )

// var deleteConfig bool
// var configSetKey string
// var configSetValue string
// var configRemoveKey string
// var configRemoveRoot string

// var nexusCmd = &amp;cobra.Command{
//         Use:   "nexus",
//         Short: "Access the central configuration nexus",
//         Long: `
// ╔══════════════════════════════════════════════════════════╗
// ║                  "+ config.Aliases.Config +": CONFIGURATION CORE               ║
// ╚══════════════════════════════════════════════════════════╝

// [INITIATING]: The Nexus Protocol—manage critical system parameters.

// Capabilities:
// • 🔑 API authentication protocols
// • 📂 File system access points
// • 🧠 Neural network parameters
// • 🛠️ System memory allocation

// Configuration Keys:
// • GEMINI_API_KEY (Required): API key for Gemini service.
// • root_folders (Optional): Comma-separated list of root folder paths.
// • numFilesToCommit (Optional): Max number of files per commit (default: 5).
// • app_name (Optional): Application name (default: "GitCury").
// • version (Optional): Application version (default: "1.0.0").
// • log_level (Optional): Logging level (default: "info").
// • editor (Optional): Text editor for editing commit messages (default: "nano").
// • output_file_path (Optional): Path to output file (default: "$HOME/.gitcury/output.json").
// • retries (Optional): Number of retries for operations (default: 3).
// • timeout (Optional): Timeout duration for operations (default: 30 seconds).

// [NOTICE]: Unauthorized changes may destabilize the system.
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 if deleteConfig {
//                         config.Delete()
//                         utils.Success("[" + config.Aliases.Config + "]: 🗑️ Configuration nexus obliterated.")
//                         return
//                 }

//                 conf := config.GetAll()
//                 b, _ := json.MarshalIndent(conf, "", "  ")
//                 utils.Print("\n======== " + config.Aliases.Config + " CONFIGURATION STATUS ========\n")
//                 utils.Print(string(b))
//                 utils.Print("\n============================================\n")
//         },
// }

// var injectCmd = &amp;cobra.Command{
//         Use:   "inject",
//         Short: "💉 Inject key-value pairs into the nexus",
//         Long: `
// ╔══════════════════════════════════════════════════╗
// ║              INJECT: CONFIGURATION UPDATE        ║
// ╚══════════════════════════════════════════════════╝

// [INITIATING]: The Inject Protocol—update or add directives to the configuration nexus.

// Examples:
// • Inject a new directive:
//         gitcury inject --key GEMINI_API_KEY --value YOUR_API_KEY

// • Update root folders:
//         gitcury inject --key root_folders --value /path/to/folder1,/path/to/folder2
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 if configSetKey == "" || configSetValue == "" {
//                         utils.Error("[" + config.Aliases.Config + "]: ❌ Injection failed. Missing --key or --value.")
//                         return
//                 }

//                 if configSetKey == "root_folders" {
//                         values := strings.Split(configSetValue, ",")
//                         for i := range values {
//                                 values[i] = strings.TrimSpace(values[i])
//                         }
//                         config.Set(configSetKey, values)
//                         utils.Success("[" + config.Aliases.Config + "]: ✅ Directive injected: " + configSetKey + " = " + utils.ToJSON(values))
//                 } else {
//                         config.Set(configSetKey, configSetValue)
//                         utils.Success("[" + config.Aliases.Config + "]: ✅ Directive injected: " + configSetKey + " = " + configSetValue)
//                 }
//         },
// }

// var purgeCmd = &amp;cobra.Command{
//         Use:   "purge",
//         Short: "🗑️ Purge directives from the nexus",
//         Long: `
// ╔══════════════════════════════════════════════════╗
// ║              PURGE: CONFIGURATION CLEANUP        ║
// ╚══════════════════════════════════════════════════╝

// [INITIATING]: The Purge Protocol—remove directives or root folders from the nexus.

// Examples:
// • Purge a configuration key:
//         gitcury purge --key theme

// • Purge a specific root folder:
//         gitcury purge --root /path/to/folder1
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 if configRemoveKey != "" {
//                         config.Remove(configRemoveKey)
//                         utils.Success("[" + config.Aliases.Config + "]: 🗑️ Directive purged: " + configRemoveKey)
//                 } else if configRemoveRoot != "" {
//                         rootFolders, ok := config.Get("root_folders").([]string)
//                         if !ok {
//                                 utils.Error("[" + config.Aliases.Config + "]: ❌ Root folders directive missing or corrupted.")
//                                 return
//                         }

//                         updatedFolders := []string{}
//                         for _, folder := range rootFolders {
//                                 if folder != configRemoveRoot {
//                                         updatedFolders = append(updatedFolders, folder)
//                                 }
//                         }

//                         config.Set("root_folders", updatedFolders)
//                         utils.Success("[" + config.Aliases.Config + "]: 🗑️ Root folder purged: " + configRemoveRoot)
//                 } else {
//                         utils.Error("[" + config.Aliases.Config + "]: ❌ Specify either --key or --root for purge operation.")
//                 }
//         },
// }

// func init() {
//         injectCmd.Flags().StringVarP(&amp;configSetKey, "key", "k", "", "🔑 Directive key to inject")
//         injectCmd.Flags().StringVarP(&amp;configSetValue, "value", "v", "", "📄 Directive value to inject")

//         purgeCmd.Flags().StringVarP(&amp;configRemoveKey, "key", "k", "", "🔑 Directive key to purge")
//         purgeCmd.Flags().StringVarP(&amp;configRemoveRoot, "root", "r", "", "📂 Specific root folder to purge")

//         nexusCmd.Flags().BoolVarP(&amp;deleteConfig, "delete", "d", false, "🗑️ Obliterate all directives from the nexus")
//         nexusCmd.AddCommand(purgeCmd)
//         nexusCmd.AddCommand(injectCmd)

//         rootCmd.AddCommand(nexusCmd)
// }

package cmd

import (
        "GitCury/config"
        "GitCury/utils"
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "github.com/spf13/cobra"
)

var deleteConfig bool // Flag to reset configuration to defaults
var configSetKey string
var configSetValue string
var configRemoveKey string
var configRemoveRoot string

var configCmd = &amp;cobra.Command{
        Use:   "config",
        Short: "Manage GitCury configuration",
        Long: `
Manage GitCury configuration settings.

Aliases:
• ` + config.Aliases.Config + `

Configuration Keys:
• GEMINI_API_KEY (Required): API key for Gemini service
• root_folders (Optional): Comma-separated list of root folder paths
• numFilesToCommit (Optional): Max number of files per commit (default: 5)
• app_name (Optional): Application name (default: "GitCury")
• version (Optional): Application version (default: "1.0.0")
• log_level (Optional): Logging level (default: "info")
• editor (Optional): Text editor for editing commit messages (default: "nano")
• output_file_path (Optional): Path to output file (default: "$HOME/.gitcury/output.json")
• retries (Optional): Number of retries for operations (default: 3)
• timeout (Optional): Timeout duration for operations (default: 30 seconds)

Examples:
• View current configuration:
        gitcury config

• Set API key:
        gitcury config set --key GEMINI_API_KEY --value YOUR_API_KEY_HERE

• Update root folders:
        gitcury config set --key root_folders --value /path/to/folder1,/path/to/folder2
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if deleteConfig </span><span class="cov0" title="0">{
                        config.Delete()
                        utils.Success("Configuration reset successfully.")
                        return
                }</span>

                // Always show config, even if there are missing values
                <span class="cov0" title="0">conf := config.GetAll()

                // Ensure we have at least basic config structure
                if conf == nil || len(conf) == 0 </span><span class="cov0" title="0">{
                        conf = map[string]interface{}{
                                "app_name":         "GitCury",
                                "version":          "1.0.0",
                                "root_folders":     []string{"."},
                                "numFilesToCommit": 5,
                                "editor":           "nano",
                                "retries":          3,
                                "timeout":          30,
                                "logLevel":         "info",
                        }

                        // Save this basic config
                        for key, value := range conf </span><span class="cov0" title="0">{
                                config.Set(key, value)
                        }</span>

                        <span class="cov0" title="0">utils.Success("📝 Created basic configuration with default values")</span>
                }

                // Check if API key is missing and provide helpful guidance
                <span class="cov0" title="0">apiKey, hasApiKey := conf["GEMINI_API_KEY"]
                envKey := os.Getenv("GEMINI_API_KEY")

                if !hasApiKey || apiKey == "" </span><span class="cov0" title="0">{
                        if envKey == "" </span><span class="cov0" title="0">{
                                utils.Info("📋 Current Configuration (⚠️  API key missing)")
                                utils.Info("════════════════════════════════════════")
                        }</span> else<span class="cov0" title="0"> {
                                utils.Info("📋 Current Configuration (✅ API key from environment)")
                                utils.Info("════════════════════════════════════════")
                                conf["GEMINI_API_KEY"] = "[FROM ENVIRONMENT: " + envKey[:10] + "...]"
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Mask the API key for security
                        if keyStr, ok := apiKey.(string); ok &amp;&amp; len(keyStr) &gt; 10 </span><span class="cov0" title="0">{
                                conf["GEMINI_API_KEY"] = keyStr[:10] + "..." + " (configured)"
                        }</span>
                        <span class="cov0" title="0">utils.Info("📋 Current Configuration (✅ API key configured)")
                        utils.Info("════════════════════════════════════════")</span>
                }

                // Display config in a user-friendly format
                <span class="cov0" title="0">b, _ := json.MarshalIndent(conf, "", "  ")
                utils.Print(string(b))
                utils.Print("")

                // Provide helpful guidance if API key is missing
                if (!hasApiKey || apiKey == "") &amp;&amp; envKey == "" </span><span class="cov0" title="0">{
                        utils.Info("🔑 Next Steps:")
                        utils.Info("   To use GitCury's AI features, set your Gemini API key:")
                        utils.Info("")
                        utils.Info("   gitcury config set --key GEMINI_API_KEY --value YOUR_API_KEY_HERE")
                        utils.Info("")
                        utils.Info("📖 Get your free API key:")
                        utils.Info("   🔗 https://aistudio.google.com/app/apikey")
                        utils.Info("")
                        utils.Info("💡 Tip: You can also set the environment variable:")
                        utils.Info("   export GEMINI_API_KEY=your_key_here")
                        utils.Info("")
                }</span> else<span class="cov0" title="0"> {
                        utils.Success("✅ Configuration looks good! You're ready to use GitCury.")
                        utils.Info("")
                        utils.Info("💡 Try these commands:")
                        utils.Info("   gitcury getmsgs    # Generate AI commit messages")
                        utils.Info("   gitcury commit     # Commit changes")
                        utils.Info("   gitcury --help     # See all available commands")
                        utils.Info("")
                }</span>
        },
}

var setCmd = &amp;cobra.Command{
        Use:   "set",
        Short: "Set configuration values",
        Long: `
Set or update configuration values.

Examples:
• Set API key:
        gitcury config set --key GEMINI_API_KEY --value YOUR_API_KEY_HERE

• Update root folders:
        gitcury config set --key root_folders --value /path/to/folder1,/path/to/folder2
        
• Set numeric value:
        gitcury config set --key numFilesToCommit --value 10
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if configSetKey == "" || configSetValue == "" </span><span class="cov0" title="0">{
                        utils.Error("Both --key and --value are required.")
                        utils.Info("Example: gitcury config set --key GEMINI_API_KEY --value YOUR_API_KEY")
                        return
                }</span>

                // Special handling for root_folders
                <span class="cov0" title="0">if configSetKey == "root_folders" </span><span class="cov0" title="0">{
                        values := strings.Split(configSetValue, ",")
                        for i := range values </span><span class="cov0" title="0">{
                                values[i] = strings.TrimSpace(values[i])
                        }</span>
                        <span class="cov0" title="0">config.Set(configSetKey, values)
                        utils.Success("✅ Configuration updated: " + configSetKey + " = " + utils.ToJSON(values))</span>
                } else<span class="cov0" title="0"> if utils.IsNumeric(configSetValue) </span><span class="cov0" title="0">{
                        // Handle numeric values
                        intValue, err := utils.ParseInt(configSetValue)
                        if err == nil </span><span class="cov0" title="0">{
                                config.Set(configSetKey, intValue)
                                utils.Success("✅ Configuration updated: " + configSetKey + " = " + configSetValue)
                        }</span> else<span class="cov0" title="0"> {
                                // Fall back to string if conversion fails
                                config.Set(configSetKey, configSetValue)
                                utils.Success("✅ Configuration updated: " + configSetKey + " = " + configSetValue)
                        }</span>
                } else<span class="cov0" title="0"> {
                        config.Set(configSetKey, configSetValue)
                        utils.Success("✅ Configuration updated: " + configSetKey + " = " + configSetValue)
                }</span>

                // Provide extra guidance for API key
                <span class="cov0" title="0">if configSetKey == "GEMINI_API_KEY" </span><span class="cov0" title="0">{
                        utils.Success("🎉 API key configured! You can now use GitCury's AI features.")
                }</span>
        },
}

var removeCmd = &amp;cobra.Command{
        Use:   "remove",
        Short: "Remove configuration values",
        Long: `
Remove configuration keys or specific root folders.

Examples:
• Remove a configuration key:
        gitcury config remove --key theme

• Remove a specific root folder:
        gitcury config remove --root /path/to/folder1
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if configRemoveKey != "" </span><span class="cov0" title="0">{
                        config.Remove(configRemoveKey)
                        utils.Success("✅ Configuration key removed: " + configRemoveKey)
                }</span> else<span class="cov0" title="0"> if configRemoveRoot != "" </span><span class="cov0" title="0">{
                        rootFolders, ok := config.Get("root_folders").([]string)
                        if !ok </span><span class="cov0" title="0">{
                                utils.Error("Root folders configuration missing or has invalid format.")
                                return
                        }</span>

                        <span class="cov0" title="0">updatedFolders := []string{}
                        found := false
                        for _, folder := range rootFolders </span><span class="cov0" title="0">{
                                if folder != configRemoveRoot </span><span class="cov0" title="0">{
                                        updatedFolders = append(updatedFolders, folder)
                                }</span> else<span class="cov0" title="0"> {
                                        found = true
                                }</span>
                        }

                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                utils.Warning("Root folder not found in configuration: " + configRemoveRoot)
                                return
                        }</span>

                        <span class="cov0" title="0">config.Set("root_folders", updatedFolders)
                        utils.Success("✅ Root folder removed: " + configRemoveRoot)</span>
                } else<span class="cov0" title="0"> {
                        utils.Error("Specify either --key or --root for remove operation.")
                }</span>
        },
}

var clusteringCmd = &amp;cobra.Command{
        Use:   "clustering",
        Short: "Manage clustering configuration",
        Long: `
Manage clustering configuration for grouping files in commits.

Clustering Methods:
• directory: Group files by directory structure (fastest)
• pattern: Group files by file patterns and extensions  
• cached: Use cached embeddings for similarity clustering
• semantic: Full semantic analysis clustering (slowest)

Presets:
• speed: Directory-only clustering for maximum speed
• balanced: Smart multi-layered approach (default)
• quality: Semantic-first clustering for best results

Examples:
• View clustering configuration:
        gitcury config clustering

• Set clustering method:
        gitcury config clustering set --method directory

• Apply a preset:
        gitcury config clustering preset --name speed

• Configure similarity threshold:
        gitcury config clustering set --key similarity_threshold --value 0.7
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                clusteringConfig := config.GetClusteringConfig()

                utils.Info("🔀 Current Clustering Configuration")
                utils.Info("═══════════════════════════════════════")

                b, _ := json.MarshalIndent(clusteringConfig, "", "  ")
                utils.Print(string(b))
                utils.Print("")

                // Show active methods
                utils.Info("✅ Active Methods:")
                if clusteringConfig.Methods.Directory.Enabled </span><span class="cov0" title="0">{
                        utils.Info(fmt.Sprintf("   • Directory (weight: %.1f)", clusteringConfig.Methods.Directory.Weight))
                }</span>
                <span class="cov0" title="0">if clusteringConfig.Methods.Pattern.Enabled </span><span class="cov0" title="0">{
                        utils.Info(fmt.Sprintf("   • Pattern (weight: %.1f)", clusteringConfig.Methods.Pattern.Weight))
                }</span>
                <span class="cov0" title="0">if clusteringConfig.Methods.Cached.Enabled </span><span class="cov0" title="0">{
                        utils.Info(fmt.Sprintf("   • Cached (weight: %.1f)", clusteringConfig.Methods.Cached.Weight))
                }</span>
                <span class="cov0" title="0">if clusteringConfig.Methods.Semantic.Enabled </span><span class="cov0" title="0">{
                        utils.Info(fmt.Sprintf("   • Semantic (weight: %.1f)", clusteringConfig.Methods.Semantic.Weight))
                }</span>
                <span class="cov0" title="0">utils.Print("")

                utils.Info("💡 Use 'gitcury config clustering set --help' for configuration options")
                utils.Info("💡 Use 'gitcury config clustering preset --help' for quick presets")</span>
        },
}

var clusteringSetKey string
var clusteringSetValue string
var clusteringMethod string

var clusteringSetCmd = &amp;cobra.Command{
        Use:   "set",
        Short: "Set clustering configuration values",
        Long: `
Set specific clustering configuration values.

Available Keys:
• similarity_threshold: Global similarity threshold (0.0-1.0)
• max_processing_time: Maximum time in seconds for clustering
• adaptive_optimization: Enable/disable adaptive optimization (true/false)
• performance_mode: Performance preference (speed/balanced/quality)

Method-specific Keys:
• directory_enabled: Enable directory clustering (true/false)
• directory_weight: Weight for directory method (0.0-1.0)
• directory_confidence_threshold: Confidence threshold for directory method
• directory_similarity_threshold: Similarity threshold for directory method

• pattern_enabled: Enable pattern clustering (true/false)
• pattern_weight: Weight for pattern method (0.0-1.0)
• pattern_confidence_threshold: Confidence threshold for pattern method
• pattern_similarity_threshold: Similarity threshold for pattern method

• cached_enabled: Enable cached clustering (true/false)
• cached_weight: Weight for cached method (0.0-1.0)
• cached_confidence_threshold: Confidence threshold for cached method
• cached_similarity_threshold: Similarity threshold for cached method
• cached_delay_ms: Delay between cached operations in milliseconds

• semantic_enabled: Enable semantic clustering (true/false)
• semantic_weight: Weight for semantic method (0.0-1.0)
• semantic_confidence_threshold: Confidence threshold for semantic method
• semantic_similarity_threshold: Similarity threshold for semantic method
• semantic_rate_limit_delay: Rate limit delay for semantic operations

Examples:
• Set global similarity threshold:
        gitcury config clustering set --key similarity_threshold --value 0.7

• Enable only directory clustering:
        gitcury config clustering set --key directory_enabled --value true
        gitcury config clustering set --key pattern_enabled --value false
        gitcury config clustering set --key cached_enabled --value false
        gitcury config clustering set --key semantic_enabled --value false

• Set performance mode:
        gitcury config clustering set --key performance_mode --value speed
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if clusteringSetKey == "" || clusteringSetValue == "" </span><span class="cov0" title="0">{
                        utils.Error("Both --key and --value are required.")
                        utils.Info("Example: gitcury config clustering set --key similarity_threshold --value 0.7")
                        return
                }</span>

                <span class="cov0" title="0">err := config.SetClusteringConfigByKey(clusteringSetKey, clusteringSetValue)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Failed to set clustering configuration: " + err.Error())
                        return
                }</span>

                <span class="cov0" title="0">utils.Success("✅ Clustering configuration updated: " + clusteringSetKey + " = " + clusteringSetValue)

                // Provide context-specific guidance
                if strings.Contains(clusteringSetKey, "enabled") </span><span class="cov0" title="0">{
                        utils.Info("💡 Restart any running clustering operations to apply changes")
                }</span>
        },
}

var presetName string

var clusteringPresetCmd = &amp;cobra.Command{
        Use:   "preset",
        Short: "Apply clustering configuration presets",
        Long: `
Apply predefined clustering configuration presets.

Available Presets:

speed:
  • Directory clustering only
  • No fallback methods
  • Maximum performance
  • Best for large repositories

balanced (default):
  • Multi-layered approach
  • Directory → Pattern → Cached → Semantic
  • Good balance of speed and quality
  • Recommended for most use cases

quality:
  • Semantic clustering first
  • Higher similarity thresholds
  • Better grouping quality
  • Best for smaller repositories

Examples:
• Apply speed preset:
        gitcury config clustering preset --name speed

• Apply quality preset:
        gitcury config clustering preset --name quality

• Reset to balanced preset:
        gitcury config clustering preset --name balanced
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if presetName == "" </span><span class="cov0" title="0">{
                        utils.Error("Preset name is required.")
                        utils.Info("Available presets: speed, balanced, quality")
                        utils.Info("Example: gitcury config clustering preset --name speed")
                        return
                }</span>

                <span class="cov0" title="0">err := config.ApplyClusteringPreset(presetName)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Failed to apply preset: " + err.Error())
                        utils.Info("Available presets: speed, balanced, quality")
                        return
                }</span>

                <span class="cov0" title="0">utils.Success("✅ Applied clustering preset: " + presetName)

                switch presetName </span>{
                case "speed":<span class="cov0" title="0">
                        utils.Info("🚀 Speed preset applied - directory clustering only")
                        utils.Info("   • Fastest performance")
                        utils.Info("   • May create more commit groups")</span>
                case "quality":<span class="cov0" title="0">
                        utils.Info("🎯 Quality preset applied - semantic clustering prioritized")
                        utils.Info("   • Best grouping quality")
                        utils.Info("   • Slower but more intelligent clustering")</span>
                case "balanced":<span class="cov0" title="0">
                        utils.Info("⚖️  Balanced preset applied - multi-layered approach")
                        utils.Info("   • Good balance of speed and quality")
                        utils.Info("   • Recommended for most repositories")</span>
                }

                <span class="cov0" title="0">utils.Info("")
                utils.Info("💡 View updated configuration: gitcury config clustering")</span>
        },
}

func init() <span class="cov0" title="0">{
        setCmd.Flags().StringVarP(&amp;configSetKey, "key", "k", "", "Configuration key to set")
        setCmd.Flags().StringVarP(&amp;configSetValue, "value", "v", "", "Configuration value to set")

        removeCmd.Flags().StringVarP(&amp;configRemoveKey, "key", "k", "", "Configuration key to remove")
        removeCmd.Flags().StringVarP(&amp;configRemoveRoot, "root", "r", "", "Specific root folder to remove")

        // Clustering command flags
        clusteringSetCmd.Flags().StringVarP(&amp;clusteringSetKey, "key", "k", "", "Configuration key to set")
        clusteringSetCmd.Flags().StringVarP(&amp;clusteringSetValue, "value", "v", "", "Configuration value to set")
        clusteringSetCmd.Flags().StringVarP(&amp;clusteringMethod, "method", "m", "", "Clustering method to configure")

        clusteringPresetCmd.Flags().StringVarP(&amp;presetName, "name", "n", "", "Preset name to apply (speed, balanced, quality)")

        // Add clustering subcommands
        clusteringCmd.AddCommand(clusteringSetCmd)
        clusteringCmd.AddCommand(clusteringPresetCmd)

        // Avoid shorthand flag to prevent conflicts with other commands
        configCmd.Flags().BoolVar(&amp;deleteConfig, "reset", false, "Reset all configuration to defaults")
        configCmd.AddCommand(removeCmd)
        configCmd.AddCommand(setCmd)
        configCmd.AddCommand(clusteringCmd)

        rootCmd.AddCommand(configCmd)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// package cmd

// import (
//         "GitCury/config"
//         "GitCury/core"
//         "GitCury/output"
//         "GitCury/utils"
//         "bufio"
//         "fmt"
//         "os"
//         "strings"

//         "github.com/spf13/cobra"
// )

// var (
//         cascadeAll      bool
//         cascadeRoot     string
//         cascadeNumFiles int
// )

// var cascadeCmd = &amp;cobra.Command{
//         Use:   "cascade",
//         Short: "Trigger a complete neural git transformation sequence",
//         Long: `
// ╔══════════════════════════════════════════════════════════╗
// ║           "+ config.Aliases.Boom +": QUANTUM TRANSFORMATION CHAIN          ║
// ╚══════════════════════════════════════════════════════════╝

// [INITIATING]: The Cascade Protocol—complete neural git transformation sequence.

// This neural sequence executes an autonomous chain reaction:
// • 🧠 Neural pattern analysis of quantum state differentials
// • 🔄 Interactive confirmation of pattern recognition results
// • 🔒 Sealing of approved quantum state changes
// • 🌐 Neural transmission to remote nodes

// The cascade creates an optimal path through the entire git transformation cycle
// with minimal human intervention required.

// Examples:
// • Full system cascade:
//     gitcury cascade --all

// • Localized cascade:
//     gitcury cascade --root /path/to/folder

// [NOTICE]: Prepare for sequential protocol execution with confirmation checkpoints.
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 // Validation checks
//                 if !cascadeAll &amp;&amp; cascadeRoot == "" {
//                         utils.Error("[" + config.Aliases.Boom + ".FAIL]: ❗ You must specify either --all or --root flag.")
//                         return
//                 }

//                 // PHASE 1: Generate commit messages (similar to genesis)
//                 utils.Info("[" + config.Aliases.Boom + "]: 🧠 PHASE 1 - Initiating neural pattern analysis...")

//                 var err error
//                 if cascadeAll {
//                         err = core.GetAllMsgs(cascadeNumFiles)
//                 } else {
//                         err = core.GetMsgsForRootFolder(cascadeRoot, cascadeNumFiles)
//                 }

//                 if err != nil {
//                         utils.Error("[" + config.Aliases.Boom + ".FAIL]: ❌ Neural pattern analysis failed: " + err.Error())
//                         return
//                 }

//                 // PHASE 2: Display results and get confirmation
//                 utils.Success("[" + config.Aliases.Boom + "]: ✨ Neural patterns generated. Displaying quantum state analysis:")

//                 allOutput := output.GetAll()
//                 utils.Print(utils.ToJSON(allOutput))

//                 if len(allOutput.Folders) == 0 {
//                         utils.Error("[" + config.Aliases.Boom + ".FAIL]: ⚠️ No changes detected in quantum state.")
//                         return
//                 }

//                 // Ask for confirmation to proceed with commit
//                 utils.Info("[" + config.Aliases.Boom + "]: 🔄 PHASE 2 - Awaiting approval for quantum state sealing...")

//                 reader := bufio.NewReader(os.Stdin)
//                 fmt.Print("\n" + utils.BlackBg + utils.Green + "[" + config.Aliases.Boom + ".PROMPT]: Proceed with sealing these quantum states? (y/n): " + utils.Reset + " ")
//                 response, _ := reader.ReadString('\n')
//                 response = strings.TrimSpace(strings.ToLower(response))

//                 if response != "y" &amp;&amp; response != "yes" {
//                         utils.Warning("[" + config.Aliases.Boom + ".ABORT]: 🛑 Quantum state sealing aborted by user.")
//                         return
//                 }

//                 // PHASE 3: Commit changes (similar to seal)
//                 utils.Info("[" + config.Aliases.Boom + "]: 🔒 PHASE 3 - Initiating quantum state sealing...")

//                 if cascadeAll {
//                         err = core.CommitAllRoots()
//                 } else {
//                         err = core.CommitOneRoot(cascadeRoot)
//                 }

//                 if err != nil {
//                         utils.Error("[" + config.Aliases.Boom + ".FAIL]: ❌ Quantum state sealing failed: " + err.Error())
//                         return
//                 }

//                 utils.Success("[" + config.Aliases.Boom + "]: ✅ Quantum states successfully sealed.")

//                 // PHASE 4: Ask about pushing changes
//                 utils.Info("[" + config.Aliases.Boom + "]: 🌐 PHASE 4 - Preparing for neural transmission...")

//                 fmt.Print("\n" + utils.BlackBg + utils.Cyan + "[" + config.Aliases.Boom + ".PROMPT]: Transmit sealed states to remote node? (y/n): " + utils.Reset + " ")
//                 response, _ = reader.ReadString('\n')
//                 response = strings.TrimSpace(strings.ToLower(response))

//                 if response != "y" &amp;&amp; response != "yes" {
//                         utils.Success("[" + config.Aliases.Boom + "]: ✅ Cascade protocol completed. Neural transmission skipped.")
//                         return
//                 }

//                 // Get branch name
//                 fmt.Print("\n" + utils.BlackBg + utils.Cyan + "[" + config.Aliases.Boom + ".PROMPT]: Specify transmission vector (branch name) [default: main]: " + utils.Reset + " ")
//                 branchName, _ := reader.ReadString('\n')
//                 branchName = strings.TrimSpace(branchName)

//                 if branchName == "" {
//                         branchName = "main"
//                         utils.Info("[" + config.Aliases.Boom + "]: Using default transmission vector: main")
//                 }

//                 // PHASE 5: Push changes (similar to deploy)
//                 utils.Info("[" + config.Aliases.Boom + "]: 📡 PHASE 5 - Initiating neural transmission to vector: " + branchName)

//                 if cascadeAll {
//                         err = core.PushAllRoots(branchName)
//                 } else {
//                         err = core.PushOneRoot(cascadeRoot, branchName)
//                 }

//                 if err != nil {
//                         utils.Error("[" + config.Aliases.Boom + ".FAIL]: ❌ Neural transmission failed: " + err.Error())
//                         return
//                 }

//                 utils.Success("[" + config.Aliases.Boom + ".COMPLETE]: 🎉 Cascade protocol executed successfully. All phases completed.")
//         },
// }

// func init() {
//         cascadeCmd.Flags().BoolVarP(&amp;cascadeAll, "all", "a", false, "🌐 Execute cascade across all root folders")
//         cascadeCmd.Flags().StringVarP(&amp;cascadeRoot, "root", "r", "", "📂 Target a specific root folder for cascade execution")
//         cascadeCmd.Flags().IntVarP(&amp;cascadeNumFiles, "num", "n", 0, "🔢 Maximum number of files to process per folder")

//         rootCmd.AddCommand(cascadeCmd)
// }

package cmd

import (
        "GitCury/config"
        "GitCury/core"
        "GitCury/output"
        "GitCury/utils"
        "bufio"
        "fmt"
        "os"
        "strings"

        "github.com/spf13/cobra"
)

var (
        cascadeAll      bool
        cascadeRoot     string
        cascadeNumFiles int
)

var boomCmd = &amp;cobra.Command{
        Use:   "boom",
        Short: "Execute a complete git transformation sequence",
        Long: `
Execute a complete git transformation sequence.

Aliases:
• ` + config.Aliases.Boom + `

Options:
• --all : Execute boom across all root folders.
• --root &lt;folder&gt; : Target a specific root folder for boom execution.
• --num &lt;number&gt; : Maximum number of files to process per folder.

Examples:
• Full system boom:
        gitcury boom --all

• Localized boom:
        gitcury boom --root /path/to/folder
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if !cascadeAll &amp;&amp; cascadeRoot == "" </span><span class="cov0" title="0">{
                        utils.Error("Specify either --all or --root flag.")
                        return
                }</span>

                <span class="cov0" title="0">utils.Info("Starting analysis...")

                var err error
                if cascadeAll </span><span class="cov0" title="0">{
                        err = core.GetAllMsgs(cascadeNumFiles)
                }</span> else<span class="cov0" title="0"> {
                        err = core.GetMsgsForRootFolder(cascadeRoot, cascadeNumFiles)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Analysis failed: " + err.Error())
                        return
                }</span>

                <span class="cov0" title="0">allOutput := output.GetAll()
                utils.Print(utils.ToJSON(allOutput))

                if len(allOutput.Folders) == 0 </span><span class="cov0" title="0">{
                        utils.Error("No changes detected.")
                        return
                }</span>

                <span class="cov0" title="0">reader := bufio.NewReader(os.Stdin)
                fmt.Print("Proceed with committing changes? (y/n): ")
                response, _ := reader.ReadString('\n')
                response = strings.TrimSpace(strings.ToLower(response))

                if response != "y" &amp;&amp; response != "yes" </span><span class="cov0" title="0">{
                        utils.Warning("Operation aborted by user.")
                        return
                }</span>

                <span class="cov0" title="0">utils.Info("Committing changes...")

                if cascadeAll </span><span class="cov0" title="0">{
                        err = core.CommitAllRoots()
                }</span> else<span class="cov0" title="0"> {
                        err = core.CommitOneRoot(cascadeRoot)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Commit failed: " + err.Error())
                        return
                }</span>

                <span class="cov0" title="0">fmt.Print("Push changes to remote? (y/n): ")
                response, _ = reader.ReadString('\n')
                response = strings.TrimSpace(strings.ToLower(response))

                if response != "y" &amp;&amp; response != "yes" </span><span class="cov0" title="0">{
                        utils.Success("Operation completed. Push skipped.")
                        return
                }</span>

                <span class="cov0" title="0">fmt.Print("Specify branch [default: main]: ")
                branchName, _ := reader.ReadString('\n')
                branchName = strings.TrimSpace(branchName)
                if branchName == "" </span><span class="cov0" title="0">{
                        branchName = "main"
                }</span>

                <span class="cov0" title="0">utils.Info("Pushing to branch: " + branchName)

                if cascadeAll </span><span class="cov0" title="0">{
                        err = core.PushAllRoots(branchName)
                }</span> else<span class="cov0" title="0"> {
                        err = core.PushOneRoot(cascadeRoot, branchName)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        utils.Error("Push failed: " + err.Error())
                        return
                }</span>

                <span class="cov0" title="0">utils.Success("Operation completed successfully.")</span>
        },
}

func init() <span class="cov0" title="0">{
        boomCmd.Flags().BoolVarP(&amp;cascadeAll, "all", "a", false, "Execute boom across all root folders")
        boomCmd.Flags().StringVarP(&amp;cascadeRoot, "root", "r", "", "Target a specific root folder for boom execution")
        boomCmd.Flags().IntVarP(&amp;cascadeNumFiles, "num", "n", 0, "Maximum number of files to process per folder")

        rootCmd.AddCommand(boomCmd)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// package cmd

// import (
//         "GitCury/core"
//         "GitCury/output"
//         "GitCury/utils"

//         "github.com/spf13/cobra"
// )

// var (
//         numFiles       int
//         rootFolderName string
//         allFlag        bool
// )

// var getMsgsCmd = &amp;cobra.Command{
//         Use:   "getmsgs",
//         Short: "Generate commit messages for changed files",
//         Long: `
// This command generates commit messages for changed files.
// You can use the --all flag to generate messages for all changed files in all configured root folders,
// or use the --root flag to specify a particular root folder.
// For example:

//         getmsgs --all --num 5

// or

//         getmsgs --root my-folder --num 5
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 if allFlag {
//                         err := core.GetAllMsgs(numFiles)
//                         if err != nil {
//                                 utils.Error(err.Error())
//                                 return
//                         }

//                         allOutput := output.GetAll()
//                         utils.Info("Successfully generated commit messages for all changed files in all configured root folders.")

//                         utils.Print(utils.ToJSON(allOutput))
//                 } else if rootFolderName != "" {
//                         err := core.GetMsgsForRootFolder(rootFolderName, numFiles)
//                         if err != nil {
//                                 utils.Error(err.Error())
//                                 return
//                         }

//                         rootFolder := output.GetFolder(rootFolderName)
//                         if len(rootFolder.Files) == 0 {
//                                 utils.Error("No files to commit in the specified root folder.")
//                                 return
//                         }

//                         utils.Info("Successfully generated commit messages for changed files in the specified root folder.")
//                         utils.Print(utils.ToJSON(rootFolder))
//                 } else {
//                         utils.Error("You must specify either --all or --root flag.")
//                 }
//         },
// }

// func init() {

//         getMsgsCmd.Flags().IntVarP(&amp;numFiles, "num", "n", 0, "Number of files to commit per folder (overrides config)")
//         getMsgsCmd.Flags().StringVarP(&amp;rootFolderName, "root", "r", "", "Root folder to commit in (overrides config)")
//         getMsgsCmd.Flags().BoolVarP(&amp;allFlag, "all", "a", false, "Generate commit messages for all changed files in all configured root folders")

//         rootCmd.AddCommand(getMsgsCmd)
// }

// package cmd

// import (
//         "GitCury/core"
//         "GitCury/output"
//         "GitCury/utils"

//         "github.com/spf13/cobra"
// )

// var (
//         numFiles       int
//         rootFolderName string
//         allFlag        bool
// )

// var genesisCmd = &amp;cobra.Command{
//         Use:   "genesis",
//         Short: "Forge commit messages for altered files",
//         Long: `
// ╔══════════════════════════════════════════════════════════╗
// ║                  GENESIS: MESSAGE FORGER                 ║
// ╚══════════════════════════════════════════════════════════╝

// [INITIATING]: The Genesis Protocol—crafting commit messages with precision.

// Operational Modes:
// • --all : 🌐 Forge commit messages for all altered files across all root folders.
// • --root &lt;folder&gt; : 📂 Specify a root folder to localize commit message generation.

// Examples:
// • Forge for all folders:
//         gitcury genesis --all --num 5

// • Target a specific root folder:
//         gitcury genesis --root my-folder --num 5

// [NOTICE]: Ensure proper configuration of root folders to optimize message crafting.
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 if allFlag {
//                         utils.Info("[GENESIS]: 🌌 Forging messages for all root folders.")
//                         err := core.GetAllMsgs(numFiles)
//                         if err != nil {
//                                 utils.Error("[GENESIS.FAIL]: ❌ " + err.Error())
//                                 return
//                         }

//                         allOutput := output.GetAll()
//                         utils.Success("[GENESIS.SUCCESS]: ✨ Commit messages crafted for all root folders.")
//                         utils.Print(utils.ToJSON(allOutput))
//                 } else if rootFolderName != "" {
//                         utils.Info("[GENESIS]: 📂 Targeting root folder: " + rootFolderName)
//                         err := core.GetMsgsForRootFolder(rootFolderName, numFiles)
//                         if err != nil {
//                                 utils.Error("[GENESIS.FAIL]: ❌ " + err.Error())
//                                 return
//                         }

//                         rootFolder := output.GetFolder(rootFolderName)
//                         if len(rootFolder.Files) == 0 {
//                                 utils.Error("[GENESIS.FAIL]: ⚠️ No altered files detected in the specified root folder.")
//                                 return
//                         }

//                         utils.Success("[GENESIS.SUCCESS]: ✨ Commit messages crafted for root folder: " + rootFolderName)
//                         utils.Print(utils.ToJSON(rootFolder))
//                 } else {
//                         utils.Error("[GENESIS.FAIL]: ❗ Specify either --all or --root flag to proceed.")
//                 }
//         },
// }

// func init() {
//         genesisCmd.Flags().IntVarP(&amp;numFiles, "num", "n", 0, "🔢 Limit the number of files per commit (overrides config)")
//         genesisCmd.Flags().StringVarP(&amp;rootFolderName, "root", "r", "", "📂 Specify a root folder for localized message crafting")
//         genesisCmd.Flags().BoolVarP(&amp;allFlag, "all", "a", false, "🌐 Forge messages for all altered files across all root folders")

//         rootCmd.AddCommand(genesisCmd)
// }

package cmd

import (
        "GitCury/config"
        "GitCury/core"
        "GitCury/output"
        "GitCury/utils"

        "github.com/spf13/cobra"
)

var (
        numFiles           int
        rootFolderName     string
        allFlag            bool
        groupFlag          bool
        customInstructions string
)

var getMsgsCmd = &amp;cobra.Command{
        Use:   "getmsgs",
        Short: "Generate commit messages for changed files and grouping options",
        Long: `
Generate commit messages for changed files and grouping options.

Aliases:
• ` + config.Aliases.GetMsgs + `

Options:
• --all : Generate commit messages for all changed files in all root folders.
• --root &lt;folder&gt; : Generate commit messages for changed files in a specific root folder.
• --num &lt;number&gt; : Limit the number of files per commit (overrides config).
• --group : Group commit messages by file type.
• --help : Display this help message.

Examples:
• Generate messages for all folders:
        gitcury getmsgs --all --num 5

• Generate messages for a specific folder:
        gitcury getmsgs --root my-folder --num 5

• Generate messages for all folders with grouping:
        gitcury getmsgs --all --num 5 --group

• Generate messages for a specific folder with grouping:
        gitcury getmsgs --root my-folder --num 5 --group

• Generate messages with custom instructions:
        gitcury getmsgs --all --instructions "Don't add keywords like 'feat' or others in front of commit msgs and make humanize msgs"

[NOTICE]: Ensure proper configuration of root folders to optimize message generation.
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Handle custom instructions temporarily (not saved to config)
                var originalInstructions interface{}
                var hadInstructions bool
                if customInstructions != "" </span><span class="cov0" title="0">{
                        // Store original instructions if they exist
                        originalInstructions = config.Get("commit_instructions")
                        hadInstructions = originalInstructions != nil &amp;&amp; originalInstructions != ""

                        // Set custom instructions temporarily
                        config.Set("commit_instructions", customInstructions)

                        // Defer cleanup to ensure instructions are removed
                        defer func() </span><span class="cov0" title="0">{
                                if hadInstructions </span><span class="cov0" title="0">{
                                        config.Set("commit_instructions", originalInstructions)
                                }</span> else<span class="cov0" title="0"> {
                                        config.Remove("commit_instructions")
                                }</span>
                        }()
                }

                <span class="cov0" title="0">if allFlag </span><span class="cov0" title="0">{
                        utils.Info("Generating messages for all root folders...")
                        var err error

                        if groupFlag </span><span class="cov0" title="0">{
                                err = core.GroupAndGetAllMsgs(numFiles)
                        }</span> else<span class="cov0" title="0"> {
                                err = core.GetAllMsgs(numFiles)
                        }</span>

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                utils.Error("Error generating messages: " + err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">allOutput := output.GetAll()
                        utils.Success("✅ Commit messages generated for all root folders successfully.")
                        utils.Print(utils.ToJSON(allOutput))</span>
                } else<span class="cov0" title="0"> if rootFolderName != "" </span><span class="cov0" title="0">{
                        utils.Info("Generating messages for folder: " + rootFolderName)

                        var err error
                        if groupFlag </span><span class="cov0" title="0">{
                                err = core.GroupAndGetMsgsForRootFolder(rootFolderName, numFiles)
                        }</span> else<span class="cov0" title="0"> {
                                err = core.GetMsgsForRootFolder(rootFolderName, numFiles)
                        }</span>

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                utils.Error("Error generating messages: " + err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">rootFolder := output.GetFolder(rootFolderName)
                        if len(rootFolder.Files) == 0 </span><span class="cov0" title="0">{
                                utils.Error("No changed files detected in the specified root folder.")
                                return
                        }</span>

                        <span class="cov0" title="0">utils.Success("✅ Commit messages generated for root folder: " + rootFolderName + " successfully.")
                        utils.Print(utils.ToJSON(rootFolder))</span>
                } else<span class="cov0" title="0"> {
                        utils.Error("You must specify either --all or --root flag.")
                }</span>
        },
}

func init() <span class="cov0" title="0">{
        getMsgsCmd.Flags().IntVarP(&amp;numFiles, "num", "n", 0, "Limit the number of files per commit (overrides config)")
        getMsgsCmd.Flags().StringVarP(&amp;rootFolderName, "root", "r", "", "Specify a root folder for localized message generation")
        getMsgsCmd.Flags().BoolVarP(&amp;allFlag, "all", "a", false, "Generate messages for all changed files across all root folders")
        getMsgsCmd.Flags().BoolVarP(&amp;groupFlag, "group", "g", false, "Group commit messages by file type")
        getMsgsCmd.Flags().StringVarP(&amp;customInstructions, "instructions", "i", "", "Custom instructions for commit message generation (not saved to config)")

        rootCmd.AddCommand(getMsgsCmd)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// package cmd

// import (
//         "GitCury/config"
//         "GitCury/output"
//         "GitCury/utils"
//         "os"
//         "os/exec"
//         "strings"

//         "github.com/spf13/cobra"
// )

// var (
//         deleteFlag bool
//         logFlag    bool
//         editFlag   bool
// )

// var outputCmd = &amp;cobra.Command{
//         Use:   "output",
//         Short: "Generated messages output and their related cmds for gitcury",
//         Long: `
// The 'output' command provides options to display and manage the generated commit messages and their related commands for GitCury.
// You can use this command to view the generated commit messages and their associated commands in a structured format.
// For example:
//   gitcury output --log
// or
//   gitcury output --edit
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 if deleteFlag {
//                         output.Clear()
//                         utils.Info("Successfully deleted all generated commit messages and their related commands.")
//                         return
//                 }
//                 if logFlag {
//                         // Call the function to display logs
//                         output := output.GetAll()

//                         utils.Info("Successfully retrieved all generated commit messages and their related commands.")
//                         utils.Print(utils.ToJSON(output))
//                 } else if editFlag {
//                         editor, ok := config.Get("editor").(string)
//                         if !ok || editor == "" {
//                                 editor = os.Getenv("EDITOR")
//                                 if editor == "" {
//                                         editor = "nano" // Default to nano if no editor is set
//                                 }
//                         }

//                         outputFile, ok := config.Get("output_file_path").(string)
//                         if !ok || outputFile == "" {

//                                 outputFile = os.Getenv("HOME") + "/output.json" // Default to the user's home directory for a more reliable path
//                         } else {
//                                 outputFile = strings.TrimSpace(outputFile)
//                         }
//                         if _, err := os.Stat(outputFile); os.IsNotExist(err) {
//                                 utils.Error("Output file does not exist. Please generate the output first.")
//                                 return
//                         }

//                         cmd := exec.Command(editor, outputFile)
//                         cmd.Stdin = os.Stdin
//                         cmd.Stdout = os.Stdout
//                         cmd.Stderr = os.Stderr

//                         if err := cmd.Run(); err != nil {
//                                 utils.Error("Failed to open the editor: " + err.Error())
//                                 return
//                         }

//                         utils.Info("Successfully opened and edited the output file.")
//                 } else {
//                         cmd.Help()
//                 }
//         },
// }

// func init() {
//         outputCmd.Flags().BoolVarP(&amp;deleteFlag, "delete", "d", false, "Delete all generated commit messages and their related commands")
//         outputCmd.Flags().BoolVarP(&amp;logFlag, "log", "l", false, "Display all generated commit messages and their related commands")
//         outputCmd.Flags().BoolVarP(&amp;editFlag, "edit", "e", false, "Edit the output file with the configured editor")
//         rootCmd.AddCommand(outputCmd)
// }

package cmd

import (
        "GitCury/config"
        "GitCury/output"
        "GitCury/utils"
        "os"
        "os/exec"
        "strings"

        "github.com/spf13/cobra"
)

var (
        deleteFlag bool
        logFlag    bool
        editFlag   bool
)

var outputCmd = &amp;cobra.Command{
        Use:   "output",
        Short: "Manage generated commit messages",
        Long: `
Manage generated commit messages and related commands.

Alias:
• ` + config.Aliases.Output + `

Options:
• --log : View all generated messages.
• --edit : Edit the output file.
• --delete : Delete all generated messages.

Examples:
• View messages:
        gitcury output --log

• Edit messages:
        gitcury output --edit

• Delete messages:
        gitcury output --delete
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if deleteFlag </span><span class="cov0" title="0">{
                        output.Clear()
                        utils.Success("✅ All messages deleted.")
                        return
                }</span>
                <span class="cov0" title="0">if logFlag </span><span class="cov0" title="0">{
                        utils.Print(utils.ToJSON(output.GetAll()))
                }</span> else<span class="cov0" title="0"> if editFlag </span><span class="cov0" title="0">{
                        editor := resolveEditor()
                        outputFile := resolveOutputFile()

                        if _, err := os.Stat(outputFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                utils.Error("Output file not found. Generate messages first.")
                                return
                        }</span>

                        <span class="cov0" title="0">cmd := exec.Command(editor, outputFile)
                        cmd.Stdin = os.Stdin
                        cmd.Stdout = os.Stdout
                        cmd.Stderr = os.Stderr

                        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                                utils.Error("Failed to open editor: " + err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">utils.Success("✅ File edited successfully.")</span>
                } else<span class="cov0" title="0"> {
                        cmd.Help()
                }</span>
        },
}

func resolveEditor() string <span class="cov0" title="0">{
        editor := config.Get("editor").(string)
        if editor == "" </span><span class="cov0" title="0">{
                editor = "nano"
        }</span>
        <span class="cov0" title="0">return editor</span>
}

func resolveOutputFile() string <span class="cov0" title="0">{
        outputFile := config.Get("output_file_path").(string)
        return strings.TrimSpace(outputFile)
}</span>

func init() <span class="cov0" title="0">{
        outputCmd.Flags().BoolVarP(&amp;deleteFlag, "delete", "x", false, "Delete all messages")
        outputCmd.Flags().BoolVarP(&amp;logFlag, "log", "l", false, "View all messages")
        outputCmd.Flags().BoolVarP(&amp;editFlag, "edit", "e", false, "Edit the output file")
        rootCmd.AddCommand(outputCmd)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// package cmd

// import (
//         "GitCury/core"
//         "GitCury/utils"

//         "github.com/spf13/cobra"
// )

// var (
//         folder      string
//         pushAllFlag bool
//         branchName  string
// )

// var pushCmd = &amp;cobra.Command{
//         Use:   "push",
//         Short: "Push changes to remote repository",
//         Long: `
// This command pushes the committed changes to the remote repository.
// It requires that the files have been committed using the 'commit' command.
// For example:
//   gitcury push --all --branch main
// or
//   gitcury push --root my-folder --branch main`,
//         Run: func(cmd *cobra.Command, args []string) {
//                 if pushAllFlag {
//                         err := core.PushAllRoots(branchName)
//                         if err != nil {
//                                 utils.Error(err.Error())
//                                 return
//                         }
//                         utils.Info("Successfully pushed all changes to remote repository.")
//                 } else if folder != "" {
//                         err := core.PushOneRoot(folder, branchName)
//                         if err != nil {
//                                 utils.Error(err.Error())
//                                 return
//                         }
//                         utils.Info("Successfully pushed changes in the specified folder to remote repository.")
//                 } else {
//                         utils.Error("You must specify either --all or --root flag.")
//                 }
//         },
// }

// func init() {
//         pushCmd.Flags().BoolVarP(&amp;pushAllFlag, "all", "a", false, "Push all changes to remote repository")
//         pushCmd.Flags().StringVarP(&amp;folder, "root", "r", "", "Push changes in the specified root folder to remote repository")
//         pushCmd.Flags().StringVarP(&amp;branchName, "branch", "b", "", "Specify the branch to push to (default: current branch)")
//         rootCmd.AddCommand(pushCmd)
// }

// package cmd

// import (
//         "GitCury/core"
//         "GitCury/utils"

//         "github.com/spf13/cobra"
// )

// var (
//         targetFolder string
//         deployAll    bool
//         targetBranch string
// )

// var deployCmd = &amp;cobra.Command{
//         Use:   "deploy",
//         Short: "Transmit changes to the remote repository",
//         Long: `
// ╔══════════════════════════════════════════════════╗
// ║              DEPLOY: REMOTE TRANSMISSION         ║
// ╚══════════════════════════════════════════════════╝

// [INITIATING]: The Deploy Protocol—synchronizing your committed changes with the remote repository.

// Operational Modes:
// • --all : Transmit all changes across all root folders.
// • --root &lt;folder&gt; : Specify a root folder for localized transmission.

// Examples:
// • Transmit all changes:
//         gitcury deploy --all --branch main

// • Target a specific root folder:
//         gitcury deploy --root my-folder --branch dev

// [NOTICE]: Ensure all necessary commits are sealed using the 'seal' command before deployment.
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 if deployAll {
//                         utils.Info("[DEPLOY]: Initiating transmission for all root folders.")
//                         err := core.PushAllRoots(targetBranch)
//                         if err != nil {
//                                 utils.Error("[DEPLOY.FAIL]: ⚠️ Error transmitting all changes: " + err.Error())
//                                 return
//                         }
//                         utils.Success("[DEPLOY.SUCCESS]: 🌐 All changes successfully transmitted to the remote repository.")
//                 } else if targetFolder != "" {
//                         utils.Info("[DEPLOY]: Targeting root folder: " + targetFolder)
//                         err := core.PushOneRoot(targetFolder, targetBranch)
//                         if err != nil {
//                                 utils.Error("[DEPLOY.FAIL]: 🚨 Error transmitting changes for folder '" + targetFolder + "': " + err.Error())
//                                 return
//                         }
//                         utils.Success("[DEPLOY.SUCCESS]: 📂 Changes from folder '" + targetFolder + "' successfully transmitted to the remote repository.")
//                 } else {
//                         utils.Error("[DEPLOY.FAIL]: ❗ You must specify either --all or --root flag.")
//                 }
//         },
// }

// func init() {
//         deployCmd.Flags().BoolVarP(&amp;deployAll, "all", "a", false, "🌐 Transmit all changes to the remote repository")
//         deployCmd.Flags().StringVarP(&amp;targetFolder, "root", "r", "", "📂 Transmit changes from the specified folder to the remote repository")
//         deployCmd.Flags().StringVarP(&amp;targetBranch, "branch", "b", "", "🌿 Specify the branch to transmit to (default: current branch)")
//         rootCmd.AddCommand(deployCmd)
// }

package cmd

import (
        "GitCury/config"
        "GitCury/core"
        "GitCury/utils"

        "github.com/spf13/cobra"
)

var (
        targetFolder string
        deployAll    bool
        targetBranch string
)

var pushCmd = &amp;cobra.Command{
        Use:   "push",
        Short: "Push changes to the remote repository",
        Long: `
Push committed changes to the remote repository.

Aliases:
• ` + config.Aliases.Push + `

Options:
• --all : Push all changes across all root folders.
• --root &lt;folder&gt; : Push changes in a specific root folder.

Examples:
• Push all changes:
        gitcury push --all --branch main

• Push changes in a folder:
        gitcury push --root my-folder --branch dev
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                if deployAll </span><span class="cov0" title="0">{
                        utils.Info("Pushing all changes to the remote repository...")

                        err := core.PushAllRoots(targetBranch)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("Error pushing all changes: " + err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">utils.Success("✅ All changes pushed successfully.")</span>
                } else<span class="cov0" title="0"> if targetFolder != "" </span><span class="cov0" title="0">{
                        utils.Info("Pushing changes from folder: " + targetFolder)

                        err := core.PushOneRoot(targetFolder, targetBranch)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("Error pushing changes from folder '" + targetFolder + "': " + err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">utils.Success("✅ Changes from folder '" + targetFolder + "' pushed successfully.")</span>
                } else<span class="cov0" title="0"> {
                        utils.Error("You must specify either --all or --root flag.")
                }</span>
        },
}

func init() <span class="cov0" title="0">{
        pushCmd.Flags().BoolVarP(&amp;deployAll, "all", "a", false, "Push all changes to the remote repository")
        pushCmd.Flags().StringVarP(&amp;targetFolder, "root", "r", "", "Push changes from the specified folder to the remote repository")
        pushCmd.Flags().StringVarP(&amp;targetBranch, "branch", "b", "", "Specify the branch to push to (default: current branch)")
        rootCmd.AddCommand(pushCmd)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// package cmd

// import (
//         "GitCury/utils"
//         "os"

//         "github.com/spf13/cobra"
// )

// var rootCmd = &amp;cobra.Command{
//         Use:   "gitcury",
//         Short: "⚡ GitCury - The neural interface for Git",
//         Long: `
// ██████╗ ██╗████████╗ ██████╗██╗   ██╗██████╗ ██╗   ██╗
// ██╔════╝ ██║╚══██╔══╝██╔════╝██║   ██║██╔══██╗╚██╗ ██╔╝
// ██║  ███╗██║   ██║   ██║     ██║   ██║██████╔╝ ╚████╔╝
// ██║   ██║██║   ██║   ██║     ██║   ██║██╔══██╗  ╚██╔╝
// ╚██████╔╝██║   ██║   ╚██████╗╚██████╔╝██║  ██║   ██║
//  ╚═════╝ ╚═╝   ╚═╝    ╚═════╝ ╚═════╝ ╚═╝  ╚═╝   ╚═╝

// &gt;&gt; NEURAL GIT INTERFACE v1.0.0 &lt;&lt;

// Automated Neural Network-Based Git Operations:
// • Neural commit message generation through Gemini API
// • Multi-repository simulation architecture
// • Advanced operational parameters via config protocol
// • Quantum state manipulation of Git repositories

// [SYSTEM]: Connection established. All subsystems online.
// `,
// }

// func Execute() {
//         if err := rootCmd.Execute(); err != nil {
//                 utils.Error("Error executing command: " + err.Error())
//                 os.Exit(1)
//         }
// }

package cmd

import (
        "GitCury/config"
        "GitCury/utils"
        "fmt"
        "os"

        "github.com/spf13/cobra"
)

// Version information
var (
        versionInfo struct {
                Version string
                Commit  string
                Date    string
        }
)

// SetVersionInfo sets the version information for use in commands
func SetVersionInfo(version, commit, date string) <span class="cov0" title="0">{
        versionInfo.Version = version
        versionInfo.Commit = commit
        versionInfo.Date = date
}</span>

var rootCmd = &amp;cobra.Command{
        Use:   "gitcury",
        Short: "⚡ GitCury - Your AI-powered Git assistant",
        Long: `
██████╗ ██╗████████╗ ██████╗██╗   ██╗██████╗ ██╗   ██╗
██╔════╝ ██║╚══██╔══╝██╔════╝██║   ██║██╔══██╗╚██╗ ██╔╝
██║  ███╗██║   ██║   ██║     ██║   ██║██████╔╝ ╚████╔╝ 
██║   ██║██║   ██║   ██║     ██║   ██║██╔══██╗  ╚██╔╝  
╚██████╔╝██║   ██║   ╚██████╗╚██████╔╝██║  ██║   ██║   
 ╚═════╝ ╚═╝   ╚═╝    ╚═════╝ ╚═════╝ ╚═╝  ╚═╝   ╚═╝   
                                                                                                           
&gt;&gt; NEURAL GIT INTERFACE v1.0.0 &lt;&lt;

Simplify your Git workflow with AI:
• Smart commit message generation
• Manage multiple repositories effortlessly
• Advanced configuration options
• Streamline Git operations with ease

[SYSTEM]: Ready to assist. All systems operational.
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // If no subcommand is specified, show help
                cmd.Help()
        }</span>,
}

func Execute() <span class="cov0" title="0">{
        // Ensure config is loaded
        err := utils.SafeExecute("LoadConfig", func() error </span><span class="cov0" title="0">{
                return config.LoadConfig()
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                utils.Error("Failed to load configuration: " + err.Error())
                utils.Info("Falling back to default configuration")
                // Continue with defaults
        }</span>

        // Add a version flag to the root command
        <span class="cov0" title="0">rootCmd.PersistentFlags().BoolP("version", "V", false, "Print the version number of GitCury")

        // Add common flags
        rootCmd.PersistentFlags().BoolP("quiet", "q", false, "Minimize output, only show errors")
        rootCmd.PersistentFlags().BoolP("debug", "d", false, "Enable debug output")

        // Add a hook to handle flags before executing the command
        cobra.OnInitialize(func() </span><span class="cov0" title="0">{
                // Check if version flag is set
                versionFlag, _ := rootCmd.Flags().GetBool("version")
                if versionFlag </span><span class="cov0" title="0">{
                        fmt.Println("GitCury version 1.0.0")
                        os.Exit(0)
                }</span>

                // Handle quiet flag
                <span class="cov0" title="0">quietFlag, _ := rootCmd.Flags().GetBool("quiet")
                if quietFlag </span><span class="cov0" title="0">{
                        utils.SetLogLevel("error")
                }</span>

                // Handle debug flag
                <span class="cov0" title="0">debugFlag, _ := rootCmd.Flags().GetBool("debug")
                if debugFlag </span><span class="cov0" title="0">{
                        utils.SetLogLevel("debug")
                }</span>
        })

        // Remap aliases
        <span class="cov0" title="0">ReampAlias(rootCmd)

        // Override the default help template to include aliases and better formatting
        cobra.AddTemplateFunc("aliasList", func(cmd *cobra.Command) string </span><span class="cov0" title="0">{
                if len(cmd.Aliases) &gt; 0 </span><span class="cov0" title="0">{
                        return cmd.NameAndAliases()
                }</span>
                <span class="cov0" title="0">return ""</span>
        })

        <span class="cov0" title="0">rootCmd.SetHelpTemplate(`{{with (or .Long .Short)}}{{. | trimTrailingWhitespaces}}{{end}}

╔══════════════════════════════════════════════════════════════════════════════╗
║                             AVAILABLE COMMANDS                               ║
╚══════════════════════════════════════════════════════════════════════════════╝

{{if .HasAvailableSubCommands}}{{range .Commands}}{{if (or .IsAvailableCommand (eq .Name "help"))}}  {{rpad .Name 15}} {{rpad (aliasList .) 20}} {{.Short}}
{{end}}{{end}}{{end}}

╔══════════════════════════════════════════════════════════════════════════════╗
║                              COMMAND FLAGS                                   ║
╚══════════════════════════════════════════════════════════════════════════════╝

{{if .HasAvailableLocalFlags}}{{.LocalFlags.FlagUsages | trimTrailingWhitespaces}}{{end}}

{{if .HasAvailableInheritedFlags}}╔══════════════════════════════════════════════════════════════════════════════╗
║                              GLOBAL FLAGS                                    ║
╚══════════════════════════════════════════════════════════════════════════════╝

{{.InheritedFlags.FlagUsages | trimTrailingWhitespaces}}{{end}}

Use "{{.CommandPath}} [command] --help" for more information about a command.
For complete documentation, visit: https://github.com/lakshyajain-0291/GitCury
`)

        // Use custom error handling with user-friendly messages
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                // Convert error to user-friendly message
                utils.Error(utils.ToUserFriendlyMessage(err))
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// package cmd

// import (
//         "GitCury/config"
//         "GitCury/utils"
//         "os"
//         "strings"

//         "github.com/spf13/cobra"
// )

// var bootstrapCmd = &amp;cobra.Command{
//         Use:   "bootstrap",
//         Short: "Bootstrap GitCury with essential configurations and shell integrations",
//         Long: `
// ╔══════════════════════════════════════════════════════════╗
// ║                  BOOTSTRAP: SYSTEM INITIALIZER           ║
// ╚══════════════════════════════════════════════════════════╝

// [INITIATING]: The Bootstrap Protocol—setting up GitCury for optimal performance.

// Includes:
// • Generating essential configuration files.
// • Installing shell completion scripts for enhanced CLI experience.
// • Ensuring necessary directories and files are created.

// [NOTICE]: Ensure your shell environment is properly configured for seamless integration.
// `,
//         Run: func(cmd *cobra.Command, args []string) {
//                 // Step 1: Generate basic configuration
//                 utils.Info("[BOOTSTRAP]: Generating essential configuration...")
//                 config.LoadConfig()
//                 utils.Success("[BOOTSTRAP]: Configuration generated successfully.")

//                 configDir := config.Get("config_dir").(string)

//                 // Step 2: Install shell completion scripts
//                 utils.Info("[BOOTSTRAP]: Installing shell completion scripts...")
//                 shell := os.Getenv("SHELL")
//                 switch {
//                 case strings.Contains(shell, "bash"):
//                         err := rootCmd.GenBashCompletionFile(configDir + "/gitcury-completion.bash")
//                         if err == nil {
//                                 utils.Success("[BOOTSTRAP]: Bash completion script installed at ~/.gitcury/gitcury-completion.bash.")
//                                 utils.Info("[BOOTSTRAP]: Add 'source ~/.gitcury/gitcury-completion.bash' to your ~/.bashrc.")
//                         }
//                 case strings.Contains(shell, "zsh"):
//                         err := rootCmd.GenZshCompletionFile(configDir + "/gitcury-completion.zsh")
//                         if err == nil {
//                                 utils.Success("[BOOTSTRAP]: Zsh completion script installed at ~/.gitcury/gitcury-completion.zsh.")
//                                 utils.Info("[BOOTSTRAP]: Add 'source ~/.gitcury/gitcury-completion.zsh' to your ~/.zshrc.")
//                         }
//                 case strings.Contains(shell, "fish"):
//                         err := rootCmd.GenFishCompletionFile(configDir+"/completions/gitcury.fish", true)
//                         if err == nil {
//                                 utils.Success("[BOOTSTRAP]: Fish completion script installed at ~/.gitcury/completions/gitcury.fish.")
//                         }
//                 default:
//                         utils.Error("[BOOTSTRAP]: Shell not recognized. Please use 'gitcury completion' to manually set up.")
//                 }

//                 utils.Success("[BOOTSTRAP]: Setup completed successfully!")
//         },
// }

// func init() {
//         rootCmd.AddCommand(bootstrapCmd)
// }

package cmd

import (
        "GitCury/config"
        "GitCury/utils"
        "os"
        "strings"

        "github.com/spf13/cobra"
)

var setupCmd = &amp;cobra.Command{
        Use:   "setup",
        Short: "Setup GitCury with configurations and shell integrations",
        Long: `
Setup GitCury with essential configurations and shell integrations.

Alias:
• ` + config.Aliases.Setup + `

Includes:
• Generating configuration files.
• Installing shell completion scripts.

Examples:
• Run setup:
        gitcury setup

[NOTICE]: Ensure your shell environment is properly configured for integration.
`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                utils.Info("Setting up GitCury...")

                // Generate configuration
                config.LoadConfig()
                utils.Success("Configuration generated.")

                configDir := config.Get("config_dir").(string)

                // Install shell completion scripts
                utils.Info("Installing shell completion scripts...")
                shell := os.Getenv("SHELL")
                switch </span>{
                case strings.Contains(shell, "bash"):<span class="cov0" title="0">
                        err := rootCmd.GenBashCompletionFile(configDir + "/gitcury-completion.bash")
                        if err == nil </span><span class="cov0" title="0">{
                                utils.Success("Bash completion script installed.")
                                utils.Info("Add 'source ~/.gitcury/gitcury-completion.bash' to your ~/.bashrc.")
                        }</span>
                case strings.Contains(shell, "zsh"):<span class="cov0" title="0">
                        err := rootCmd.GenZshCompletionFile(configDir + "/gitcury-completion.zsh")
                        if err == nil </span><span class="cov0" title="0">{
                                utils.Success("Zsh completion script installed.")
                                utils.Info("Add 'source ~/.gitcury/gitcury-completion.zsh' to your ~/.zshrc.")
                        }</span>
                case strings.Contains(shell, "fish"):<span class="cov0" title="0">
                        err := rootCmd.GenFishCompletionFile(configDir+"/completions/gitcury.fish", true)
                        if err == nil </span><span class="cov0" title="0">{
                                utils.Success("Fish completion script installed.")
                        }</span>
                default:<span class="cov0" title="0">
                        utils.Error("Shell not recognized. Use 'gitcury completion' for manual setup.")</span>
                }

                <span class="cov0" title="0">utils.Success("Setup completed!")</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(setupCmd)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "fmt"
        "log"
        "strconv"
        "strings"
)

// ClusteringConfig holds all clustering-related configuration
type ClusteringConfig struct {
        DefaultMethod                 string             `json:"defaultMethod"`
        EnableFallbackMethods         bool               `json:"enableFallbackMethods"`
        MaxFilesForSemanticClustering int                `json:"maxFilesForSemanticClustering"`
        ConfidenceThresholds          map[string]float64 `json:"confidenceThresholds"`
        SimilarityThresholds          map[string]float64 `json:"similarityThresholds"`
        Methods                       ClusteringMethods  `json:"methods"`
        Performance                   PerformanceConfig  `json:"performance"`
}

// ClusteringMethods holds method-specific configurations
type ClusteringMethods struct {
        Directory DirectoryConfig `json:"directory"`
        Pattern   PatternConfig   `json:"pattern"`
        Cached    CachedConfig    `json:"cached"`
        Semantic  SemanticConfig  `json:"semantic"`
}

// DirectoryConfig holds directory-based clustering settings
type DirectoryConfig struct {
        Enabled bool    `json:"enabled"`
        Weight  float64 `json:"weight"`
}

// PatternConfig holds pattern-based clustering settings
type PatternConfig struct {
        Enabled bool    `json:"enabled"`
        Weight  float64 `json:"weight"`
}

// CachedConfig holds cached embedding clustering settings
type CachedConfig struct {
        Enabled          bool    `json:"enabled"`
        Weight           float64 `json:"weight"`
        MinCacheHitRatio float64 `json:"minCacheHitRatio"`
        MaxCacheAge      int     `json:"maxCacheAge"` // hours
}

// SemanticConfig holds semantic clustering settings
type SemanticConfig struct {
        Enabled                 bool    `json:"enabled"`
        Weight                  float64 `json:"weight"`
        RateLimitDelay          int     `json:"rateLimitDelay"` // milliseconds
        MaxConcurrentEmbeddings int     `json:"maxConcurrentEmbeddings"`
        EmbeddingTimeout        int     `json:"embeddingTimeout"` // seconds
}

// PerformanceConfig holds performance-related settings
type PerformanceConfig struct {
        PreferSpeed          bool `json:"preferSpeed"`
        MaxProcessingTime    int  `json:"maxProcessingTime"` // seconds
        EnableBenchmarking   bool `json:"enableBenchmarking"`
        AdaptiveOptimization bool `json:"adaptiveOptimization"`
}

// ClusteringMethod represents available clustering methods
type ClusteringMethod string

const (
        DirectoryMethod ClusteringMethod = "directory"
        PatternMethod   ClusteringMethod = "pattern"
        CachedMethod    ClusteringMethod = "cached"
        SemanticMethod  ClusteringMethod = "semantic"
        AutoMethod      ClusteringMethod = "auto" // Uses the smart multi-layered approach
)

// GetClusteringConfig retrieves the clustering configuration
func GetClusteringConfig() *ClusteringConfig <span class="cov0" title="0">{
        mu.RLock()
        defer mu.RUnlock()

        clusteringSettings, exists := settings["clustering"]
        if !exists </span><span class="cov0" title="0">{
                log.Println("[Config]: Clustering configuration not found, using defaults")
                return getDefaultClusteringConfig()
        }</span>

        <span class="cov0" title="0">clusteringMap, ok := clusteringSettings.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                log.Println("[Config]: Invalid clustering configuration f ormat, using defaults")
                return getDefaultClusteringConfig()
        }</span>

        <span class="cov0" title="0">config := &amp;ClusteringConfig{}

        // Parse basic settings
        if defaultMethod, ok := clusteringMap["defaultMethod"].(string); ok </span><span class="cov0" title="0">{
                config.DefaultMethod = defaultMethod
        }</span> else<span class="cov0" title="0"> {
                config.DefaultMethod = "directory"
        }</span>

        <span class="cov0" title="0">if enableFallback, ok := clusteringMap["enableFallbackMethods"].(bool); ok </span><span class="cov0" title="0">{
                config.EnableFallbackMethods = enableFallback
        }</span> else<span class="cov0" title="0"> {
                config.EnableFallbackMethods = true
        }</span>

        <span class="cov0" title="0">if maxFiles, ok := clusteringMap["maxFilesForSemanticClustering"].(float64); ok </span><span class="cov0" title="0">{
                config.MaxFilesForSemanticClustering = int(maxFiles)
        }</span> else<span class="cov0" title="0"> if maxFiles, ok := clusteringMap["maxFilesForSemanticClustering"].(int); ok </span><span class="cov0" title="0">{
                config.MaxFilesForSemanticClustering = maxFiles
        }</span> else<span class="cov0" title="0"> {
                config.MaxFilesForSemanticClustering = 10
        }</span>

        // Parse confidence thresholds
        <span class="cov0" title="0">config.ConfidenceThresholds = parseFloatMap(clusteringMap, "confidenceThresholds", map[string]float64{
                "directory": 0.8,
                "pattern":   0.7,
                "cached":    0.6,
                "semantic":  0.5,
        })

        // Parse similarity thresholds
        config.SimilarityThresholds = parseFloatMap(clusteringMap, "similarityThresholds", map[string]float64{
                "directory": 0.7,
                "pattern":   0.6,
                "cached":    0.5,
                "semantic":  0.4,
        })

        // Parse methods configuration
        if methodsMap, ok := clusteringMap["methods"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                config.Methods = parseMethodsConfig(methodsMap)
        }</span> else<span class="cov0" title="0"> {
                config.Methods = getDefaultMethodsConfig()
        }</span>

        // Parse performance configuration
        <span class="cov0" title="0">if perfMap, ok := clusteringMap["performance"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                config.Performance = parsePerformanceConfig(perfMap)
        }</span> else<span class="cov0" title="0"> {
                config.Performance = getDefaultPerformanceConfig()
        }</span>

        <span class="cov0" title="0">return config</span>
}

// SetClusteringConfig updates the clustering configuration
func SetClusteringConfig(config *ClusteringConfig) error <span class="cov0" title="0">{
        // Use global config mutex to prevent deadlocks
        // The global config system will handle the locking
        clusteringMap := map[string]interface{}{
                "defaultMethod":                 config.DefaultMethod,
                "enableFallbackMethods":         config.EnableFallbackMethods,
                "maxFilesForSemanticClustering": config.MaxFilesForSemanticClustering,
                "confidenceThresholds":          config.ConfidenceThresholds,
                "similarityThresholds":          config.SimilarityThresholds,
                "methods": map[string]interface{}{
                        "directory": map[string]interface{}{
                                "enabled": config.Methods.Directory.Enabled,
                                "weight":  config.Methods.Directory.Weight,
                        },
                        "pattern": map[string]interface{}{
                                "enabled": config.Methods.Pattern.Enabled,
                                "weight":  config.Methods.Pattern.Weight,
                        },
                        "cached": map[string]interface{}{
                                "enabled":          config.Methods.Cached.Enabled,
                                "weight":           config.Methods.Cached.Weight,
                                "minCacheHitRatio": config.Methods.Cached.MinCacheHitRatio,
                                "maxCacheAge":      config.Methods.Cached.MaxCacheAge,
                        },
                        "semantic": map[string]interface{}{
                                "enabled":                 config.Methods.Semantic.Enabled,
                                "weight":                  config.Methods.Semantic.Weight,
                                "rateLimitDelay":          config.Methods.Semantic.RateLimitDelay,
                                "maxConcurrentEmbeddings": config.Methods.Semantic.MaxConcurrentEmbeddings,
                                "embeddingTimeout":        config.Methods.Semantic.EmbeddingTimeout,
                        },
                },
                "performance": map[string]interface{}{
                        "preferSpeed":          config.Performance.PreferSpeed,
                        "maxProcessingTime":    config.Performance.MaxProcessingTime,
                        "enableBenchmarking":   config.Performance.EnableBenchmarking,
                        "adaptiveOptimization": config.Performance.AdaptiveOptimization,
                },
        }

        // Use the global config system to set and save
        Set("clustering", clusteringMap)

        log.Println("[Config]: Clustering configuration updated successfully")
        return nil
}</span>

// SetClusteringConfigByKey updates a specific clustering configuration value
func SetClusteringConfigByKey(key, value string) error <span class="cov0" title="0">{
        // Get current config (this will acquire and release a read lock)
        config := GetClusteringConfig()

        // Make a copy to avoid modifying the original while it might still be read-locked
        configCopy := *config

        switch key </span>{
        // Global settings
        case "similarity_threshold":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.SimilarityThresholds["directory"] = floatVal
                        configCopy.SimilarityThresholds["pattern"] = floatVal
                        configCopy.SimilarityThresholds["cached"] = floatVal
                        configCopy.SimilarityThresholds["semantic"] = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for similarity_threshold: %s", value)
                }</span>
        case "max_processing_time":<span class="cov0" title="0">
                if intVal, err := parseInt(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.Performance.MaxProcessingTime = intVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid integer value for max_processing_time: %s", value)
                }</span>
        case "adaptive_optimization":<span class="cov0" title="0">
                if boolVal, err := parseBool(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.Performance.AdaptiveOptimization = boolVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid boolean value for adaptive_optimization: %s", value)
                }</span>
        case "performance_mode":<span class="cov0" title="0">
                switch value </span>{
                case "speed":<span class="cov0" title="0">
                        configCopy.Performance.PreferSpeed = true
                        configCopy.Performance.MaxProcessingTime = 30</span>
                case "quality":<span class="cov0" title="0">
                        configCopy.Performance.PreferSpeed = false
                        configCopy.Performance.MaxProcessingTime = 120</span>
                case "balanced":<span class="cov0" title="0">
                        configCopy.Performance.PreferSpeed = true
                        configCopy.Performance.MaxProcessingTime = 60</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("invalid performance mode: %s (valid: speed, quality, balanced)", value)</span>
                }

        // Directory method settings
        case "directory_enabled":<span class="cov0" title="0">
                if boolVal, err := parseBool(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.Methods.Directory.Enabled = boolVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid boolean value for directory_enabled: %s", value)
                }</span>
        case "directory_weight":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.Methods.Directory.Weight = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for directory_weight: %s", value)
                }</span>
        case "directory_confidence_threshold":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.ConfidenceThresholds["directory"] = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for directory_confidence_threshold: %s", value)
                }</span>
        case "directory_similarity_threshold":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.SimilarityThresholds["directory"] = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for directory_similarity_threshold: %s", value)
                }</span>

        // Pattern method settings
        case "pattern_enabled":<span class="cov0" title="0">
                if boolVal, err := parseBool(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.Methods.Pattern.Enabled = boolVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid boolean value for pattern_enabled: %s", value)
                }</span>
        case "pattern_weight":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.Methods.Pattern.Weight = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for pattern_weight: %s", value)
                }</span>
        case "pattern_confidence_threshold":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.ConfidenceThresholds["pattern"] = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for pattern_confidence_threshold: %s", value)
                }</span>
        case "pattern_similarity_threshold":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.SimilarityThresholds["pattern"] = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for pattern_similarity_threshold: %s", value)
                }</span>

        // Cached method settings
        case "cached_enabled":<span class="cov0" title="0">
                if boolVal, err := parseBool(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.Methods.Cached.Enabled = boolVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid boolean value for cached_enabled: %s", value)
                }</span>
        case "cached_weight":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.Methods.Cached.Weight = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for cached_weight: %s", value)
                }</span>
        case "cached_confidence_threshold":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.ConfidenceThresholds["cached"] = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for cached_confidence_threshold: %s", value)
                }</span>
        case "cached_similarity_threshold":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.SimilarityThresholds["cached"] = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for cached_similarity_threshold: %s", value)
                }</span>
        case "cached_delay_ms":<span class="cov0" title="0">
                if _, err := parseInt(value); err == nil </span><span class="cov0" title="0">{
                        // Note: This could be added to CachedConfig if needed
                        log.Println("cached_delay_ms setting not yet implemented in configuration structure")
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid integer value for cached_delay_ms: %s", value)
                }</span>

        // Semantic method settings
        case "semantic_enabled":<span class="cov0" title="0">
                if boolVal, err := parseBool(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.Methods.Semantic.Enabled = boolVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid boolean value for semantic_enabled: %s", value)
                }</span>
        case "semantic_weight":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.Methods.Semantic.Weight = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for semantic_weight: %s", value)
                }</span>
        case "semantic_confidence_threshold":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.ConfidenceThresholds["semantic"] = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for semantic_confidence_threshold: %s", value)
                }</span>
        case "semantic_similarity_threshold":<span class="cov0" title="0">
                if floatVal, err := parseFloat(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.SimilarityThresholds["semantic"] = floatVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid float value for semantic_similarity_threshold: %s", value)
                }</span>
        case "semantic_rate_limit_delay":<span class="cov0" title="0">
                if intVal, err := parseInt(value); err == nil </span><span class="cov0" title="0">{
                        configCopy.Methods.Semantic.RateLimitDelay = intVal
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("invalid integer value for semantic_rate_limit_delay: %s", value)
                }</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown clustering configuration key: %s", key)</span>
        }

        // Now save the modified config (this will acquire and release a write lock)
        <span class="cov0" title="0">return SetClusteringConfig(&amp;configCopy)</span>
}

// ApplyClusteringPreset applies a predefined clustering configuration preset
func ApplyClusteringPreset(presetName string) error <span class="cov0" title="0">{
        var config *ClusteringConfig

        switch presetName </span>{
        case "speed":<span class="cov0" title="0">
                config = GetSpeedOptimizedConfig()</span>
        case "balanced":<span class="cov0" title="0">
                config = GetBalancedConfig()</span>
        case "quality":<span class="cov0" title="0">
                config = GetQualityOptimizedConfig()</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown preset: %s (valid presets: speed, balanced, quality)", presetName)</span>
        }

        <span class="cov0" title="0">return SetClusteringConfig(config)</span>
}

// Helper functions for parsing configuration

func parseFloatMap(source map[string]interface{}, key string, defaultMap map[string]float64) map[string]float64 <span class="cov0" title="0">{
        if thresholds, ok := source[key].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                result := make(map[string]float64)
                for k, v := range thresholds </span><span class="cov0" title="0">{
                        if floatVal, ok := v.(float64); ok </span><span class="cov0" title="0">{
                                result[k] = floatVal
                        }</span> else<span class="cov0" title="0"> if intVal, ok := v.(int); ok </span><span class="cov0" title="0">{
                                result[k] = float64(intVal)
                        }</span> else<span class="cov0" title="0"> {
                                // Use default if conversion fails
                                if defaultVal, exists := defaultMap[k]; exists </span><span class="cov0" title="0">{
                                        result[k] = defaultVal
                                }</span>
                        }
                }
                <span class="cov0" title="0">return result</span>
        }
        <span class="cov0" title="0">return defaultMap</span>
}

func parseMethodsConfig(methodsMap map[string]interface{}) ClusteringMethods <span class="cov0" title="0">{
        methods := ClusteringMethods{}

        // Parse directory config
        if dirMap, ok := methodsMap["directory"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                methods.Directory = DirectoryConfig{
                        Enabled: getBoolOrDefault(dirMap, "enabled", true),
                        Weight:  getFloatOrDefault(dirMap, "weight", 1.0),
                }
        }</span> else<span class="cov0" title="0"> {
                methods.Directory = DirectoryConfig{Enabled: true, Weight: 1.0}
        }</span>

        // Parse pattern config
        <span class="cov0" title="0">if patternMap, ok := methodsMap["pattern"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                methods.Pattern = PatternConfig{
                        Enabled: getBoolOrDefault(patternMap, "enabled", true),
                        Weight:  getFloatOrDefault(patternMap, "weight", 0.8),
                }
        }</span> else<span class="cov0" title="0"> {
                methods.Pattern = PatternConfig{Enabled: true, Weight: 0.8}
        }</span>

        // Parse cached config
        <span class="cov0" title="0">if cachedMap, ok := methodsMap["cached"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                methods.Cached = CachedConfig{
                        Enabled:          getBoolOrDefault(cachedMap, "enabled", true),
                        Weight:           getFloatOrDefault(cachedMap, "weight", 0.6),
                        MinCacheHitRatio: getFloatOrDefault(cachedMap, "minCacheHitRatio", 0.4),
                        MaxCacheAge:      getIntOrDefault(cachedMap, "maxCacheAge", 24),
                }
        }</span> else<span class="cov0" title="0"> {
                methods.Cached = CachedConfig{
                        Enabled: true, Weight: 0.6, MinCacheHitRatio: 0.4, MaxCacheAge: 24,
                }
        }</span>

        // Parse semantic config
        <span class="cov0" title="0">if semanticMap, ok := methodsMap["semantic"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                methods.Semantic = SemanticConfig{
                        Enabled:                 getBoolOrDefault(semanticMap, "enabled", true),
                        Weight:                  getFloatOrDefault(semanticMap, "weight", 0.4),
                        RateLimitDelay:          getIntOrDefault(semanticMap, "rateLimitDelay", 2000),
                        MaxConcurrentEmbeddings: getIntOrDefault(semanticMap, "maxConcurrentEmbeddings", 1),
                        EmbeddingTimeout:        getIntOrDefault(semanticMap, "embeddingTimeout", 30),
                }
        }</span> else<span class="cov0" title="0"> {
                methods.Semantic = SemanticConfig{
                        Enabled: true, Weight: 0.4, RateLimitDelay: 2000,
                        MaxConcurrentEmbeddings: 1, EmbeddingTimeout: 30,
                }
        }</span>

        <span class="cov0" title="0">return methods</span>
}

func parsePerformanceConfig(perfMap map[string]interface{}) PerformanceConfig <span class="cov0" title="0">{
        return PerformanceConfig{
                PreferSpeed:          getBoolOrDefault(perfMap, "preferSpeed", true),
                MaxProcessingTime:    getIntOrDefault(perfMap, "maxProcessingTime", 60),
                EnableBenchmarking:   getBoolOrDefault(perfMap, "enableBenchmarking", false),
                AdaptiveOptimization: getBoolOrDefault(perfMap, "adaptiveOptimization", true),
        }
}</span>

// Helper functions for type conversion with defaults

func getBoolOrDefault(m map[string]interface{}, key string, defaultVal bool) bool <span class="cov0" title="0">{
        if val, ok := m[key].(bool); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}

func getFloatOrDefault(m map[string]interface{}, key string, defaultVal float64) float64 <span class="cov0" title="0">{
        if val, ok := m[key].(float64); ok </span><span class="cov0" title="0">{
                return val
        }</span> else<span class="cov0" title="0"> if val, ok := m[key].(int); ok </span><span class="cov0" title="0">{
                return float64(val)
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}

func getIntOrDefault(m map[string]interface{}, key string, defaultVal int) int <span class="cov0" title="0">{
        if val, ok := m[key].(float64); ok </span><span class="cov0" title="0">{
                return int(val)
        }</span> else<span class="cov0" title="0"> if val, ok := m[key].(int); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}

// Default configuration builders

func getDefaultClusteringConfig() *ClusteringConfig <span class="cov0" title="0">{
        return &amp;ClusteringConfig{
                DefaultMethod:                 "directory",
                EnableFallbackMethods:         true,
                MaxFilesForSemanticClustering: 10,
                ConfidenceThresholds: map[string]float64{
                        "directory": 0.8,
                        "pattern":   0.7,
                        "cached":    0.6,
                        "semantic":  0.5,
                },
                SimilarityThresholds: map[string]float64{
                        "directory": 0.7,
                        "pattern":   0.6,
                        "cached":    0.5,
                        "semantic":  0.4,
                },
                Methods:     getDefaultMethodsConfig(),
                Performance: getDefaultPerformanceConfig(),
        }
}</span>

func getDefaultMethodsConfig() ClusteringMethods <span class="cov0" title="0">{
        return ClusteringMethods{
                Directory: DirectoryConfig{Enabled: true, Weight: 1.0},
                Pattern:   PatternConfig{Enabled: true, Weight: 0.8},
                Cached: CachedConfig{
                        Enabled: true, Weight: 0.6, MinCacheHitRatio: 0.4, MaxCacheAge: 24,
                },
                Semantic: SemanticConfig{
                        Enabled: true, Weight: 0.4, RateLimitDelay: 2000,
                        MaxConcurrentEmbeddings: 1, EmbeddingTimeout: 30,
                },
        }
}</span>

func getDefaultPerformanceConfig() PerformanceConfig <span class="cov0" title="0">{
        return PerformanceConfig{
                PreferSpeed:          true,
                MaxProcessingTime:    60,
                EnableBenchmarking:   false,
                AdaptiveOptimization: true,
        }
}</span>

// Configuration presets for different use cases

// GetSpeedOptimizedConfig returns configuration optimized for speed
func GetSpeedOptimizedConfig() *ClusteringConfig <span class="cov0" title="0">{
        config := getDefaultClusteringConfig()
        config.DefaultMethod = "directory"
        config.EnableFallbackMethods = false    // Only use the fastest method
        config.Methods.Semantic.Enabled = false // Disable slow semantic clustering
        config.Methods.Cached.Enabled = false   // Disable caching overhead
        config.Performance.PreferSpeed = true
        config.Performance.MaxProcessingTime = 30 // Shorter timeout
        return config
}</span>

// GetQualityOptimizedConfig returns configuration optimized for clustering quality
func GetQualityOptimizedConfig() *ClusteringConfig <span class="cov0" title="0">{
        config := getDefaultClusteringConfig()
        config.DefaultMethod = "semantic"
        config.EnableFallbackMethods = true
        config.MaxFilesForSemanticClustering = 20 // Allow more files for semantic analysis

        // Lower thresholds for more permissive clustering
        config.ConfidenceThresholds["directory"] = 0.9
        config.ConfidenceThresholds["pattern"] = 0.8
        config.ConfidenceThresholds["cached"] = 0.7
        config.ConfidenceThresholds["semantic"] = 0.6

        config.Methods.Semantic.Enabled = true
        config.Methods.Semantic.Weight = 1.0
        config.Methods.Semantic.RateLimitDelay = 1000 // Faster API calls if possible
        config.Performance.PreferSpeed = false
        config.Performance.MaxProcessingTime = 120 // Longer timeout for quality
        config.Performance.EnableBenchmarking = true
        return config
}</span>

// GetBalancedConfig returns a balanced configuration for speed and quality
func GetBalancedConfig() *ClusteringConfig <span class="cov0" title="0">{
        config := getDefaultClusteringConfig()
        config.DefaultMethod = "auto" // Use smart multi-layered approach
        config.EnableFallbackMethods = true
        config.MaxFilesForSemanticClustering = 10
        config.Performance.PreferSpeed = true
        config.Performance.AdaptiveOptimization = true
        return config
}</span>

// Helper functions for parsing string values
func parseFloat(s string) (float64, error) <span class="cov0" title="0">{
        // Try to parse as float
        return strconv.ParseFloat(s, 64)
}</span>

func parseInt(s string) (int, error) <span class="cov0" title="0">{
        return strconv.Atoi(s)
}</span>

func parseBool(s string) (bool, error) <span class="cov0" title="0">{
        switch strings.ToLower(strings.TrimSpace(s)) </span>{
        case "true", "yes", "1", "on", "enabled":<span class="cov0" title="0">
                return true, nil</span>
        case "false", "no", "0", "off", "disabled":<span class="cov0" title="0">
                return false, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("invalid boolean: %s", s)</span>
        }
}

// IsMethodEnabled checks if a specific clustering method is enabled
func IsMethodEnabled(method ClusteringMethod) bool <span class="cov0" title="0">{
        config := GetClusteringConfig()
        switch method </span>{
        case DirectoryMethod:<span class="cov0" title="0">
                return config.Methods.Directory.Enabled</span>
        case PatternMethod:<span class="cov0" title="0">
                return config.Methods.Pattern.Enabled</span>
        case CachedMethod:<span class="cov0" title="0">
                return config.Methods.Cached.Enabled</span>
        case SemanticMethod:<span class="cov0" title="0">
                return config.Methods.Semantic.Enabled</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetConfidenceThreshold returns the confidence threshold for a specific method
func GetConfidenceThreshold(method ClusteringMethod) float64 <span class="cov0" title="0">{
        config := GetClusteringConfig()
        if threshold, exists := config.ConfidenceThresholds[string(method)]; exists </span><span class="cov0" title="0">{
                return threshold
        }</span>
        <span class="cov0" title="0">return 0.5</span> // Default threshold
}

// GetSimilarityThreshold returns the similarity threshold for a specific method
func GetSimilarityThreshold(method ClusteringMethod) float64 <span class="cov0" title="0">{
        config := GetClusteringConfig()
        if threshold, exists := config.SimilarityThresholds[string(method)]; exists </span><span class="cov0" title="0">{
                return threshold
        }</span>
        <span class="cov0" title="0">return 0.7</span> // Default threshold
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package config

import (
        "GitCury/api"
        "GitCury/utils"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"
)

var (
        settings = make(map[string]interface{})
        mu       sync.RWMutex
)

type Alias struct {
        Commit  string `json:"commit"`
        Push    string `json:"push"`
        GetMsgs string `json:"getmsgs"`
        Output  string `json:"output"`
        Config  string `json:"config"`
        Setup   string `json:"setup"`
        Boom    string `json:"boom"`
}

var (
        Aliases        Alias
        DefaultAliases = Alias{
                Commit:  "seal",
                Push:    "deploy",
                GetMsgs: "genesis",
                Output:  "trace",
                Config:  "nexus",
                Setup:   "bootstrap",
                Boom:    "cascade",
        }
)

func init() <span class="cov0" title="0">{
        // Skip config loading during tests to avoid initialization issues
        if isTestMode() </span><span class="cov0" title="0">{
                // Set minimal defaults for testing
                Aliases = DefaultAliases
                return
        }</span>

        // Allow config commands to run even with missing critical config
        <span class="cov0" title="0">if isConfigCommand() </span><span class="cov0" title="0">{
                // Load config but don't exit on critical errors for config commands
                err := LoadConfigForConfigCommands()
                if err != nil </span><span class="cov0" title="0">{
                        // For config commands, just log warnings, don't exit
                        utils.Debug("[Config]: " + err.Error())
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">err := LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's a critical config error
                if configErr, ok := err.(*utils.StructuredError); ok &amp;&amp; configErr.Type == utils.ConfigError </span><span class="cov0" title="0">{
                        if stop, exists := configErr.Context["stop_execution"].(bool); exists &amp;&amp; stop </span><span class="cov0" title="0">{
                                // Exit immediately for critical missing configs
                                utils.Error("")
                                utils.Error("💥 GitCury cannot start due to missing critical configuration.")
                                utils.Error("   Please fix the configuration issues shown above and try again.")
                                utils.Error("")
                                os.Exit(1)
                        }</span>
                }
                // For non-critical errors, just log them
                <span class="cov0" title="0">utils.Warning("[Config]: " + err.Error())</span>
        }
}

// isTestMode detects if we're running in test mode
func isTestMode() bool <span class="cov0" title="0">{
        // Check for common test environment indicators
        for _, arg := range os.Args </span><span class="cov0" title="0">{
                if strings.Contains(arg, "test") || strings.Contains(arg, ".test") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        // Check if GITCURY_TEST_MODE environment variable is set
        <span class="cov0" title="0">return os.Getenv("GITCURY_TEST_MODE") == "true"</span>
}

// isConfigCommand detects if we're running a config command
func isConfigCommand() bool <span class="cov0" title="0">{
        // Improved detection for config commands
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if the command is the config command itself or its alias
        <span class="cov0" title="0">for i, arg := range os.Args </span><span class="cov0" title="0">{
                // Direct config command or its alias
                if arg == "config" || arg == DefaultAliases.Config || arg == "nexus" </span><span class="cov0" title="0">{
                        return true
                }</span>

                // Check for config subcommands
                <span class="cov0" title="0">if i &gt; 0 </span><span class="cov0" title="0">{
                        prevArg := os.Args[i-1]
                        if prevArg == "config" || prevArg == DefaultAliases.Config || prevArg == "nexus" </span><span class="cov0" title="0">{
                                // Any subcommand of config should be considered a config command
                                return true
                        }</span>
                }

                // Also check for flags that belong to config command
                <span class="cov0" title="0">if (arg == "--delete" || arg == "--reset") &amp;&amp; i &gt; 0 </span><span class="cov0" title="0">{
                        prevArg := os.Args[i-1]
                        if prevArg == "config" || prevArg == DefaultAliases.Config || prevArg == "nexus" </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// contains checks if a slice contains a string
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func LoadConfig() error <span class="cov0" title="0">{
        configFilePath := os.Getenv("HOME") + "/.gitcury/config.json"
        file, err := os.Open(configFilePath)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Prompt user about creating default config
                utils.Info("🔧 Configuration file not found at " + configFilePath)
                utils.Info("📝 Creating default configuration file with recommended settings...")

                // Set default settings if the file does not exist
                settings = map[string]interface{}{
                        "app_name":         "GitCury",
                        "version":          "1.0.0",
                        "root_folders":     []string{"."},
                        "config_dir":       os.Getenv("HOME") + "/.gitcury",
                        "output_file_path": os.Getenv("HOME") + "/.gitcury/output.json",
                        "editor":           "nano",
                        "aliases": map[string]string{
                                "getmsgs": DefaultAliases.GetMsgs,
                                "commit":  DefaultAliases.Commit,
                                "push":    DefaultAliases.Push,
                                "output":  DefaultAliases.Output,
                                "config":  DefaultAliases.Config,
                                "setup":   DefaultAliases.Setup,
                                "boom":    DefaultAliases.Boom,
                        },
                        "retries":       3,
                        "timeout":       30,
                        "maxConcurrent": 5,
                        "logLevel":      "info",
                        "clustering": map[string]interface{}{
                                "defaultMethod":                 "directory",
                                "enableFallbackMethods":         true,
                                "maxFilesForSemanticClustering": 10,
                                "confidenceThresholds": map[string]float64{
                                        "directory": 0.8,
                                        "pattern":   0.7,
                                        "cached":    0.6,
                                        "semantic":  0.5,
                                },
                                "similarityThresholds": map[string]float64{
                                        "directory": 0.7,
                                        "pattern":   0.6,
                                        "cached":    0.5,
                                        "semantic":  0.4,
                                },
                                "methods": map[string]interface{}{
                                        "directory": map[string]interface{}{
                                                "enabled": true,
                                                "weight":  1.0,
                                        },
                                        "pattern": map[string]interface{}{
                                                "enabled": true,
                                                "weight":  0.8,
                                        },
                                        "cached": map[string]interface{}{
                                                "enabled":          true,
                                                "weight":           0.6,
                                                "minCacheHitRatio": 0.4,
                                                "maxCacheAge":      24, // hours
                                        },
                                        "semantic": map[string]interface{}{
                                                "enabled":                 true,
                                                "weight":                  0.4,
                                                "rateLimitDelay":          2000, // milliseconds
                                                "maxConcurrentEmbeddings": 1,
                                                "embeddingTimeout":        30, // seconds
                                        },
                                },
                                "performance": map[string]interface{}{
                                        "preferSpeed":          true,
                                        "maxProcessingTime":    60, // seconds
                                        "enableBenchmarking":   false,
                                        "adaptiveOptimization": true,
                                },
                        },
                }

                // Save the default settings to the file
                if err := saveConfigToFile(configFilePath); err != nil </span><span class="cov0" title="0">{
                        utils.Error("[Config]: Failed to save default configuration: " + err.Error())
                        return utils.NewConfigError(
                                "Failed to save default configuration",
                                err,
                                map[string]interface{}{
                                        "configPath": configFilePath,
                                },
                        )
                }</span>

                <span class="cov0" title="0">utils.Success("✅ Default configuration file created at " + configFilePath)
                utils.Warning("⚠️  IMPORTANT: You need to set your GEMINI_API_KEY to use AI features!")
                utils.Info("🔑 To set your API key, run this command:")
                utils.Print("    gitcury config set --key GEMINI_API_KEY --value YOUR_API_KEY_HERE")
                utils.Info("📖 Get your API key from: https://aistudio.google.com/app/apikey")
                utils.Info("💡 You can also set the environment variable: export GEMINI_API_KEY=your_key_here")

                utils.Debug("[Config]: Config file not found. Using default settings and saving to file: \n" + utils.ToJSON(settings))

                // Set up aliases with default values
                Aliases = DefaultAliases
                return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                utils.Error("[Config]: Error opening configuration file: " + err.Error())
                return utils.NewConfigError(
                        "Error opening configuration file",
                        err,
                        map[string]interface{}{
                                "configPath": configFilePath,
                        },
                )
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Parse the config file
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;settings); err != nil </span><span class="cov0" title="0">{
                utils.Error("[Config]: Error parsing configuration file: " + err.Error())
                return utils.NewConfigError(
                        "Error parsing configuration file",
                        err,
                        map[string]interface{}{
                                "configPath": configFilePath,
                        },
                )
        }</span>

        // Validate required settings
        <span class="cov0" title="0">if err := validateConfig(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check critical configuration - no longer stops execution for config commands
        <span class="cov0" title="0">criticalMissing := checkCriticalConfig()
        if len(criticalMissing) &gt; 0 &amp;&amp; !isConfigCommand() </span><span class="cov0" title="0">{
                // Only stop execution for non-config commands when API key is missing
                if contains(criticalMissing, "GEMINI_API_KEY") </span><span class="cov0" title="0">{
                        utils.Error("")
                        utils.Error("💥 GitCury cannot start due to missing API key.")
                        utils.Error("   Please set your GEMINI_API_KEY as shown above and try again.")
                        utils.Error("")
                        return utils.NewConfigError(
                                "Critical configuration missing",
                                nil,
                                map[string]interface{}{
                                        "missing_fields": criticalMissing,
                                        "stop_execution": true,
                                },
                        )
                }</span>
        }

        // Set up aliases
        <span class="cov0" title="0">aliasesMap, ok := settings["aliases"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Warning("[Config]: No aliases configuration found. Using defaults.")
                Aliases = DefaultAliases
        }</span> else<span class="cov0" title="0"> {
                // Convert the map to our Alias struct
                commitAlias, _ := aliasesMap["commit"].(string)
                if commitAlias == "" </span><span class="cov0" title="0">{
                        commitAlias = DefaultAliases.Commit
                }</span>

                <span class="cov0" title="0">pushAlias, _ := aliasesMap["push"].(string)
                if pushAlias == "" </span><span class="cov0" title="0">{
                        pushAlias = DefaultAliases.Push
                }</span>

                <span class="cov0" title="0">getMsgsAlias, _ := aliasesMap["getmsgs"].(string)
                if getMsgsAlias == "" </span><span class="cov0" title="0">{
                        getMsgsAlias = DefaultAliases.GetMsgs
                }</span>

                <span class="cov0" title="0">outputAlias, _ := aliasesMap["output"].(string)
                if outputAlias == "" </span><span class="cov0" title="0">{
                        outputAlias = DefaultAliases.Output
                }</span>

                <span class="cov0" title="0">configAlias, _ := aliasesMap["config"].(string)
                if configAlias == "" </span><span class="cov0" title="0">{
                        configAlias = DefaultAliases.Config
                }</span>

                <span class="cov0" title="0">setupAlias, _ := aliasesMap["setup"].(string)
                if setupAlias == "" </span><span class="cov0" title="0">{
                        setupAlias = DefaultAliases.Setup
                }</span>

                <span class="cov0" title="0">boomAlias, _ := aliasesMap["boom"].(string)
                if boomAlias == "" </span><span class="cov0" title="0">{
                        boomAlias = DefaultAliases.Boom
                }</span>

                <span class="cov0" title="0">Aliases = Alias{
                        Commit:  commitAlias,
                        Push:    pushAlias,
                        GetMsgs: getMsgsAlias,
                        Output:  outputAlias,
                        Config:  configAlias,
                        Setup:   setupAlias,
                        Boom:    boomAlias,
                }</span>
        }

        // Set log level if available
        <span class="cov0" title="0">logLevel, ok := settings["logLevel"].(string)
        if ok &amp;&amp; logLevel != "" </span><span class="cov0" title="0">{
                utils.SetLogLevel(logLevel)
        }</span>

        // Initialize API configuration
        <span class="cov0" title="0">api.LoadConfig(settings)

        utils.Debug("[Config]: Configuration loaded successfully: \n" + utils.ToJSON(settings))
        utils.Debug("[Config]: Aliases loaded successfully: \n" + utils.ToJSON(Aliases))

        return nil</span>
}

// LoadConfigForConfigCommands loads config specifically for config commands - minimal warnings and no critical errors
func LoadConfigForConfigCommands() error <span class="cov0" title="0">{
        configFilePath := os.Getenv("HOME") + "/.gitcury/config.json"
        utils.Debug("[Config]: Loading config for config commands from " + configFilePath)

        // Ensure config directory exists
        configDir := filepath.Dir(configFilePath)
        if err := os.MkdirAll(configDir, 0755); err != nil </span><span class="cov0" title="0">{
                utils.Debug("[Config]: Error creating config directory: " + err.Error())
                // Continue with in-memory config
        }</span>

        <span class="cov0" title="0">file, err := os.Open(configFilePath)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Create default config without warnings for config commands
                utils.Debug("[Config]: Config file not found, creating basic defaults")
                settings = map[string]interface{}{
                        "app_name":         "GitCury",
                        "version":          "1.0.0",
                        "root_folders":     []string{"."},
                        "config_dir":       os.Getenv("HOME") + "/.gitcury",
                        "output_file_path": os.Getenv("HOME") + "/.gitcury/output.json",
                        "editor":           "nano",
                        "aliases": map[string]interface{}{
                                "getmsgs": DefaultAliases.GetMsgs,
                                "commit":  DefaultAliases.Commit,
                                "push":    DefaultAliases.Push,
                                "output":  DefaultAliases.Output,
                                "config":  DefaultAliases.Config,
                                "setup":   DefaultAliases.Setup,
                                "boom":    DefaultAliases.Boom,
                        },
                        "retries":       3,
                        "timeout":       30,
                        "maxConcurrent": 5,
                        "logLevel":      "info",
                        "clustering": map[string]interface{}{
                                "defaultMethod":                 "directory",
                                "enableFallbackMethods":         true,
                                "maxFilesForSemanticClustering": 10,
                                "confidenceThresholds": map[string]interface{}{
                                        "directory": 0.8,
                                        "pattern":   0.7,
                                        "cached":    0.6,
                                        "semantic":  0.5,
                                },
                                "similarityThresholds": map[string]interface{}{
                                        "directory": 0.7,
                                        "pattern":   0.6,
                                        "cached":    0.5,
                                        "semantic":  0.4,
                                },
                                "methods": map[string]interface{}{
                                        "directory": map[string]interface{}{
                                                "enabled": true,
                                                "weight":  1.0,
                                        },
                                        "pattern": map[string]interface{}{
                                                "enabled": true,
                                                "weight":  0.8,
                                        },
                                        "cached": map[string]interface{}{
                                                "enabled":          true,
                                                "weight":           0.6,
                                                "minCacheHitRatio": 0.4,
                                                "maxCacheAge":      24, // hours
                                        },
                                        "semantic": map[string]interface{}{
                                                "enabled":                 true,
                                                "weight":                  0.4,
                                                "rateLimitDelay":          2000, // milliseconds
                                                "maxConcurrentEmbeddings": 1,
                                                "embeddingTimeout":        30, // seconds
                                        },
                                },
                                "performance": map[string]interface{}{
                                        "preferSpeed":          true,
                                        "maxProcessingTime":    60, // seconds
                                        "enableBenchmarking":   false,
                                        "adaptiveOptimization": true,
                                },
                        },
                }

                // Save the default settings silently
                if err := saveConfigToFile(configFilePath); err != nil </span><span class="cov0" title="0">{
                        utils.Debug("[Config]: Could not save default configuration: " + err.Error())
                        // Continue with in-memory config
                }</span> else<span class="cov0" title="0"> {
                        utils.Debug("[Config]: Created default config for config commands")
                }</span>

                // Set up aliases with default values
                <span class="cov0" title="0">Aliases = DefaultAliases
                return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                utils.Debug("[Config]: Could not open config file: " + err.Error() + " - using defaults")
                // Set minimal defaults even if file read fails
                settings = map[string]interface{}{
                        "app_name":     "GitCury",
                        "version":      "1.0.0",
                        "root_folders": []string{"."},
                        "editor":       "nano",
                        "logLevel":     "info",
                        "retries":      3,
                        "timeout":      30,
                }
                Aliases = DefaultAliases
                return nil
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Parse the config file
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;settings); err != nil </span><span class="cov0" title="0">{
                utils.Debug("[Config]: Could not parse config file: " + err.Error() + " - using defaults")
                // Set minimal defaults even if parsing fails
                settings = map[string]interface{}{
                        "app_name":     "GitCury",
                        "version":      "1.0.0",
                        "root_folders": []string{"."},
                        "editor":       "nano",
                        "logLevel":     "info",
                }
                Aliases = DefaultAliases
                return nil
        }</span>

        // Minimal validation - just ensure basic fields exist
        <span class="cov0" title="0">if _, exists := settings["app_name"]; !exists </span><span class="cov0" title="0">{
                settings["app_name"] = "GitCury"
        }</span>
        <span class="cov0" title="0">if _, exists := settings["version"]; !exists </span><span class="cov0" title="0">{
                settings["version"] = "1.0.0"
        }</span>
        <span class="cov0" title="0">if _, exists := settings["root_folders"]; !exists </span><span class="cov0" title="0">{
                settings["root_folders"] = []string{"."}
        }</span>

        // Set up aliases quietly
        <span class="cov0" title="0">aliasesMap, ok := settings["aliases"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                Aliases = DefaultAliases
        }</span> else<span class="cov0" title="0"> {
                // Convert the map to our Alias struct with defaults
                Aliases = Alias{
                        Commit:  getStringOrDefault(aliasesMap, "commit", DefaultAliases.Commit),
                        Push:    getStringOrDefault(aliasesMap, "push", DefaultAliases.Push),
                        GetMsgs: getStringOrDefault(aliasesMap, "getmsgs", DefaultAliases.GetMsgs),
                        Output:  getStringOrDefault(aliasesMap, "output", DefaultAliases.Output),
                        Config:  getStringOrDefault(aliasesMap, "config", DefaultAliases.Config),
                        Setup:   getStringOrDefault(aliasesMap, "setup", DefaultAliases.Setup),
                        Boom:    getStringOrDefault(aliasesMap, "boom", DefaultAliases.Boom),
                }
        }</span>

        // Set log level if available, but don't complain if not
        <span class="cov0" title="0">if logLevel, ok := settings["logLevel"].(string); ok &amp;&amp; logLevel != "" </span><span class="cov0" title="0">{
                utils.SetLogLevel(logLevel)
        }</span>

        <span class="cov0" title="0">utils.Debug("[Config]: Configuration loaded for config commands")
        return nil</span>
}

// getStringOrDefault is a helper function to safely get string values from a map
func getStringOrDefault(m map[string]interface{}, key, defaultValue string) string <span class="cov0" title="0">{
        if val, ok := m[key].(string); ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// checkCriticalConfig checks for critical configuration values and provides helpful guidance
func checkCriticalConfig() []string <span class="cov0" title="0">{
        var criticalMissing []string
        var hasApiKey bool
        var configChanged bool

        // Check for GEMINI_API_KEY - this is critical for main functionality
        geminiKey, exists := settings["GEMINI_API_KEY"]
        if !exists || geminiKey == "" </span><span class="cov0" title="0">{
                // Try to get from environment
                envKey := os.Getenv("GEMINI_API_KEY")
                if envKey == "" </span><span class="cov0" title="0">{
                        criticalMissing = append(criticalMissing, "GEMINI_API_KEY")
                        hasApiKey = false
                }</span> else<span class="cov0" title="0"> {
                        utils.Debug("[Config]: Using GEMINI_API_KEY from environment variables")
                        settings["GEMINI_API_KEY"] = envKey
                        hasApiKey = true
                        configChanged = true
                }</span>
        } else<span class="cov0" title="0"> {
                hasApiKey = true
        }</span>

        // Check for root_folders - auto-set reasonable defaults
        <span class="cov0" title="0">rootFolders, exists := settings["root_folders"]
        if !exists </span><span class="cov0" title="0">{
                utils.Debug("[Config]: Setting default root_folders to current directory")
                settings["root_folders"] = []string{"."}
                configChanged = true
        }</span> else<span class="cov0" title="0"> {
                // Check if root_folders is empty or invalid
                if folders, ok := rootFolders.([]interface{}); ok </span><span class="cov0" title="0">{
                        if len(folders) == 0 </span><span class="cov0" title="0">{
                                utils.Debug("[Config]: Empty root_folders detected, setting to current directory")
                                settings["root_folders"] = []string{"."}
                                configChanged = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        utils.Debug("[Config]: Invalid root_folders format detected, setting to current directory")
                        settings["root_folders"] = []string{"."}
                        configChanged = true
                }</span>
        }

        // Auto-set other important defaults
        <span class="cov0" title="0">if _, exists := settings["numFilesToCommit"]; !exists </span><span class="cov0" title="0">{
                utils.Debug("[Config]: Setting default numFilesToCommit to 5")
                settings["numFilesToCommit"] = 5
                configChanged = true
        }</span>

        <span class="cov0" title="0">if _, exists := settings["editor"]; !exists </span><span class="cov0" title="0">{
                utils.Debug("[Config]: Setting default editor to nano")
                settings["editor"] = "nano"
                configChanged = true
        }</span>

        <span class="cov0" title="0">if _, exists := settings["retries"]; !exists </span><span class="cov0" title="0">{
                utils.Debug("[Config]: Setting default retries to 3")
                settings["retries"] = 3
                configChanged = true
        }</span>

        <span class="cov0" title="0">if _, exists := settings["timeout"]; !exists </span><span class="cov0" title="0">{
                utils.Debug("[Config]: Setting default timeout to 30")
                settings["timeout"] = 30
                configChanged = true
        }</span>

        <span class="cov0" title="0">if _, exists := settings["logLevel"]; !exists </span><span class="cov0" title="0">{
                utils.Debug("[Config]: Setting default logLevel to info")
                settings["logLevel"] = "info"
                configChanged = true
        }</span>

        // Auto-set clustering configuration defaults
        <span class="cov0" title="0">if _, exists := settings["clustering"]; !exists </span><span class="cov0" title="0">{
                utils.Debug("[Config]: Setting default clustering configuration")
                settings["clustering"] = map[string]interface{}{
                        "defaultMethod":                 "directory",
                        "enableFallbackMethods":         true,
                        "maxFilesForSemanticClustering": 10,
                        "confidenceThresholds": map[string]interface{}{
                                "directory": 0.8,
                                "pattern":   0.7,
                                "cached":    0.6,
                                "semantic":  0.5,
                        },
                        "similarityThresholds": map[string]interface{}{
                                "directory": 0.7,
                                "pattern":   0.6,
                                "cached":    0.5,
                                "semantic":  0.4,
                        },
                        "methods": map[string]interface{}{
                                "directory": map[string]interface{}{
                                        "enabled": true,
                                        "weight":  1.0,
                                },
                                "pattern": map[string]interface{}{
                                        "enabled": true,
                                        "weight":  0.8,
                                },
                                "cached": map[string]interface{}{
                                        "enabled":          true,
                                        "weight":           0.6,
                                        "minCacheHitRatio": 0.4,
                                        "maxCacheAge":      24, // hours
                                },
                                "semantic": map[string]interface{}{
                                        "enabled":                 true,
                                        "weight":                  0.4,
                                        "rateLimitDelay":          2000, // milliseconds
                                        "maxConcurrentEmbeddings": 1,
                                        "embeddingTimeout":        30, // seconds
                                },
                        },
                        "performance": map[string]interface{}{
                                "preferSpeed":          true,
                                "maxProcessingTime":    60, // seconds
                                "enableBenchmarking":   false,
                                "adaptiveOptimization": true,
                        },
                }
                configChanged = true
        }</span>

        // Save config if defaults were auto-set
        <span class="cov0" title="0">if configChanged </span><span class="cov0" title="0">{
                configFilePath := os.Getenv("HOME") + "/.gitcury/config.json"
                if err := saveConfigToFile(configFilePath); err != nil </span><span class="cov0" title="0">{
                        utils.Debug("[Config]: Warning: Failed to save auto-set defaults: " + err.Error())
                }</span> else<span class="cov0" title="0"> {
                        utils.Debug("[Config]: Auto-set defaults saved to config file")
                }</span>
        }

        // Only show API key guidance if missing and if this is not a config command
        <span class="cov0" title="0">if !hasApiKey &amp;&amp; !isConfigCommand() </span><span class="cov0" title="0">{
                utils.Info("")
                utils.Info("🔑 API Key Setup Required")
                utils.Info("   GitCury needs a Gemini API key for AI-powered features.")
                utils.Info("")
                utils.Info("📝 Quick setup:")
                utils.Info("   gitcury config set --key GEMINI_API_KEY --value YOUR_API_KEY_HERE")
                utils.Info("")
                utils.Info("🌍 Or set environment variable:")
                utils.Info("   export GEMINI_API_KEY=YOUR_API_KEY_HERE")
                utils.Info("")
                utils.Info("📖 Get your free API key:")
                utils.Info("   🔗 https://aistudio.google.com/app/apikey")
                utils.Info("")
        }</span>

        <span class="cov0" title="0">return criticalMissing</span>
}

// validateConfig ensures that required configuration values are present and valid
func validateConfig() error <span class="cov0" title="0">{
        // Check for required configuration fields
        requiredFields := []string{"app_name", "version", "root_folders"}
        missingFields := []string{}

        for _, field := range requiredFields </span><span class="cov0" title="0">{
                if _, exists := settings[field]; !exists </span><span class="cov0" title="0">{
                        missingFields = append(missingFields, field)
                }</span>
        }

        <span class="cov0" title="0">if len(missingFields) &gt; 0 </span><span class="cov0" title="0">{
                utils.Warning("[Config]: Missing required configuration fields: " + fmt.Sprint(missingFields))
                // Add default values for missing fields
                if _, exists := settings["app_name"]; !exists </span><span class="cov0" title="0">{
                        settings["app_name"] = "GitCury"
                }</span>
                <span class="cov0" title="0">if _, exists := settings["version"]; !exists </span><span class="cov0" title="0">{
                        settings["version"] = "1.0.0"
                }</span>
                <span class="cov0" title="0">if _, exists := settings["root_folders"]; !exists </span><span class="cov0" title="0">{
                        settings["root_folders"] = []string{"."}
                }</span>
        }

        // Validate root_folders
        <span class="cov0" title="0">rootFolders, ok := settings["root_folders"].([]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Warning("[Config]: Invalid root_folders configuration. Must be an array.")
                settings["root_folders"] = []string{"."}
        }</span> else<span class="cov0" title="0"> if len(rootFolders) == 0 </span><span class="cov0" title="0">{
                utils.Warning("[Config]: Empty root_folders configuration. Adding current directory.")
                settings["root_folders"] = []string{"."}
        }</span>

        // Ensure output_file_path is set
        <span class="cov0" title="0">if _, exists := settings["output_file_path"]; !exists </span><span class="cov0" title="0">{
                settings["output_file_path"] = os.Getenv("HOME") + "/.gitcury/output.json"
        }</span>

        // Ensure config_dir is set
        <span class="cov0" title="0">if _, exists := settings["config_dir"]; !exists </span><span class="cov0" title="0">{
                settings["config_dir"] = os.Getenv("HOME") + "/.gitcury"
        }</span>

        // Check for API key - this is critical for most functionality
        <span class="cov0" title="0">if geminiKey, exists := settings["GEMINI_API_KEY"]; !exists || geminiKey == "" </span><span class="cov0" title="0">{
                // Try to get from environment
                envKey := os.Getenv("GEMINI_API_KEY")
                if envKey != "" </span><span class="cov0" title="0">{
                        utils.Debug("[Config]: Using GEMINI_API_KEY from environment variables")
                        settings["GEMINI_API_KEY"] = envKey
                }</span> else<span class="cov0" title="0"> {
                        utils.Warning("[Config]: GEMINI_API_KEY not found in config or environment. Some features may not work correctly.")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func saveConfigToFile(configFilePath string) error <span class="cov0" title="0">{
        // Ensure the directory exists
        dir := filepath.Dir(configFilePath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">file, err := os.OpenFile(configFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        encoder := json.NewEncoder(file)
        return encoder.Encode(settings)</span>
}

func Set(key string, value any) <span class="cov0" title="0">{
        mu.Lock()
        defer mu.Unlock()
        settings[key] = value

        utils.Debug("[" + Aliases.Config + "]: 💾 Saving updated configuration...")

        configFilePath := os.Getenv("HOME") + "/.gitcury/config.json"

        dir := os.Getenv("HOME") + "/.gitcury"
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ⚠️ Error creating config directory: " + err.Error())
                return
        }</span>

        <span class="cov0" title="0">file, err := os.OpenFile(configFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ⚠️ Error saving configuration: " + err.Error())
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        encoder := json.NewEncoder(file)
        if err := encoder.Encode(settings); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ⚠️ Error encoding configuration: " + err.Error())
        }</span>
}

func Get(key string) interface{} <span class="cov0" title="0">{
        mu.RLock()
        defer mu.RUnlock()
        utils.Debug("[" + Aliases.Config + "]: 🔍 Retrieving configuration key: " + key + " with value: " + utils.ToJSON(settings[key]))
        return settings[key]
}</span>

func GetAll() map[string]interface{} <span class="cov0" title="0">{
        mu.RLock()
        defer mu.RUnlock()
        copy := make(map[string]interface{})
        for key, value := range settings </span><span class="cov0" title="0">{
                copy[key] = value
        }</span>
        <span class="cov0" title="0">return copy</span>
}

func Remove(key string) <span class="cov0" title="0">{
        mu.Lock()
        defer mu.Unlock()
        delete(settings, key)

        // Save synchronously to ensure the change is persisted immediately
        configFilePath := os.Getenv("HOME") + "/.gitcury/config.json"

        file, err := os.OpenFile(configFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ⚠️ Error saving configuration after removal: " + err.Error())
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        encoder := json.NewEncoder(file)
        if err := encoder.Encode(settings); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ⚠️ Error saving configuration after removal: " + err.Error())
        }</span>
}

func Delete() <span class="cov0" title="0">{
        utils.Debug("[" + Aliases.Config + "]: 🗑️ Deleting configuration file...")
        mu.Lock()
        defer mu.Unlock()
        configFilePath := os.Getenv("HOME") + "/.gitcury/config.json"
        if err := os.Remove(configFilePath); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + Aliases.Config + "]: ⚠️ Error deleting configuration file: " + err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package config

import (
        "GitCury/utils"
)

// ResetConfig clears all configuration settings - used for testing only
func ResetConfig() <span class="cov0" title="0">{
        mu.Lock()
        defer mu.Unlock()
        settings = make(map[string]interface{})
        utils.Debug("[Config]: 🔄 Configuration reset for testing")
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package core

import (
        "GitCury/git"
        "GitCury/interfaces"
        "GitCury/output"
        "GitCury/utils"
        "fmt"
        "strings"
        "time"
)

// GitRunnerInstance allows dependency injection for testing
var GitRunnerInstance interfaces.GitRunner

// init initializes the default Git runner
func init() <span class="cov0" title="0">{
        if GitRunnerInstance == nil </span><span class="cov0" title="0">{
                GitRunnerInstance = &amp;git.DefaultGitRunner{}
        }</span>
}

// SetGitRunner allows injecting a custom GitRunner (used in tests)
func SetGitRunner(runner interfaces.GitRunner) <span class="cov0" title="0">{
        GitRunnerInstance = runner
}</span>

func CommitAllRoots(env ...[]string) error <span class="cov0" title="0">{
        rootFolders := output.GetAll().Folders
        if len(rootFolders) == 0 </span><span class="cov0" title="0">{
                utils.Warning("No root folders with changes to commit")
                return nil
        }</span>

        // Determine optimal worker count based on available folders
        <span class="cov0" title="0">workerCount := 3
        if len(rootFolders) &lt; workerCount </span><span class="cov0" title="0">{
                workerCount = len(rootFolders)
        }</span>

        // Create worker pool for parallel execution with limited concurrency
        <span class="cov0" title="0">pool := utils.NewWorkerPool(workerCount)

        // Submit commit tasks for each root folder
        for _, rootFolder := range rootFolders </span><span class="cov0" title="0">{
                folder := rootFolder // Create local copy to avoid closure issues
                taskName := "CommitRoot:" + folder.Name

                pool.Submit(taskName, 2*time.Minute, func() error </span><span class="cov0" title="0">{
                        if len(folder.Files) == 0 </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">err := GitRunnerInstance.ProgressCommitBatch(outputToInterface(folder), env...)
                        if err != nil </span><span class="cov0" title="0">{
                                // Extract file information if available in the error
                                fileInfo := folder.Name
                                if structErr, ok := err.(*utils.StructuredError); ok &amp;&amp; structErr.ProcessedFile != "" </span><span class="cov0" title="0">{
                                        fileInfo = structErr.ProcessedFile
                                }</span>

                                <span class="cov0" title="0">utils.Error("Failed to commit batch for folder '"+folder.Name+"' - "+err.Error(), fileInfo)
                                return utils.NewGitError(
                                        "Failed to commit changes in folder",
                                        err,
                                        map[string]interface{}{
                                                "folder":    folder.Name,
                                                "fileCount": len(folder.Files),
                                        },
                                        fileInfo,
                                )</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                })
        }

        // Wait for all commit tasks to complete
        <span class="cov0" title="0">errors := pool.Wait()

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                errorDetails := make([]string, 0, len(errors))
                filesList := make([]string, 0, len(errors))

                for _, err := range errors </span><span class="cov0" title="0">{
                        errorDetails = append(errorDetails, err.Error())

                        // Extract file information if available
                        if structErr, ok := err.(*utils.StructuredError); ok &amp;&amp; structErr.ProcessedFile != "" </span><span class="cov0" title="0">{
                                filesList = append(filesList, structErr.ProcessedFile)
                        }</span>
                }

                <span class="cov0" title="0">filesInfo := "multiple_folders"
                if len(filesList) &gt; 0 </span><span class="cov0" title="0">{
                        filesInfo = strings.Join(filesList, ", ")
                }</span>

                <span class="cov0" title="0">utils.Error("Batch commit completed with "+fmt.Sprint(len(errors))+" errors", filesInfo)

                return utils.NewGitError(
                        fmt.Sprintf("%d errors occurred during batch commit", len(errors)),
                        fmt.Errorf("multiple commit errors"),
                        map[string]interface{}{
                                "errorCount": len(errors),
                                "errors":     errorDetails,
                        },
                        filesInfo,
                )</span>
        }

        <span class="cov0" title="0">output.Clear()
        utils.Success("✅ Batch commit completed successfully. Output cleared.")
        return nil</span>
}

func CommitOneRoot(rootFolderName string, env ...[]string) error <span class="cov0" title="0">{
        rootFolder := output.GetFolder(rootFolderName)
        if len(rootFolder.Files) == 0 </span><span class="cov0" title="0">{
                utils.Error("Root folder '"+rootFolderName+"' not found or contains no files.", rootFolderName)
                return utils.NewValidationError(
                        "Root folder not found or has no files",
                        nil,
                        map[string]interface{}{
                                "folderName": rootFolderName,
                        },
                        rootFolderName,
                )
        }</span>

        <span class="cov0" title="0">err := GitRunnerInstance.ProgressCommitBatch(outputToInterface(rootFolder), env...)
        if err != nil </span><span class="cov0" title="0">{
                // Extract file information if available in the error
                fileInfo := rootFolderName
                if structErr, ok := err.(*utils.StructuredError); ok &amp;&amp; structErr.ProcessedFile != "" </span><span class="cov0" title="0">{
                        fileInfo = structErr.ProcessedFile
                }</span>

                <span class="cov0" title="0">utils.Error("Failed to commit batch for folder '"+rootFolderName+"' - "+err.Error(), fileInfo)
                return utils.NewGitError(
                        "Failed to commit batch for folder",
                        err,
                        map[string]interface{}{
                                "folder": rootFolderName,
                        },
                        fileInfo,
                )</span>
        }

        <span class="cov0" title="0">utils.Success("✅ Batch commit completed successfully for root folder: " + rootFolderName)
        return nil</span>
}

// Conversion functions between output and interface types
func outputToInterface(folder output.Folder) interfaces.Folder <span class="cov0" title="0">{
        var files []interfaces.FileEntry
        for _, file := range folder.Files </span><span class="cov0" title="0">{
                files = append(files, interfaces.FileEntry{
                        Name:    file.Name,
                        Message: file.Message,
                })
        }</span>
        <span class="cov0" title="0">return interfaces.Folder{
                Name:  folder.Name,
                Files: files,
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package core

import (
        "GitCury/config"
        "GitCury/output"
        "GitCury/utils"
        "fmt"
        "strconv"
        "sync"
)

func GetAllMsgs(numFiles ...int) error <span class="cov0" title="0">{
        defaultNumFiles := 10 // Default value
        if len(numFiles) == 0 || numFiles[0] &lt;= 0 </span><span class="cov0" title="0">{
                numFiles[0] = defaultNumFiles
        }</span>

        // Start creative loader for message generation
        <span class="cov0" title="0">utils.StartCreativeLoader("Analyzing repository changes", utils.GitAnimation)
        utils.UpdateCreativeLoaderPhase("analyzing")

        utils.Debug("Preparing commit messages for " + strconv.Itoa(numFiles[0]) + " files per folder.")

        // Update loader phase
        utils.UpdateCreativeLoaderPhase("processing")
        utils.UpdateCreativeLoaderMessage("Processing root folders")

        rootFolders, ok := config.Get("root_folders").([]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.StopCreativeLoader()
                utils.Error("Invalid or missing root_folders configuration.")
                return fmt.Errorf("invalid or missing root_folders configuration")
        }</span>

        <span class="cov0" title="0">var rootFolderWg sync.WaitGroup
        var mu sync.Mutex
        var errors []string
        totalFolders := len(rootFolders)
        processedFolders := 0

        for _, rootFolder := range rootFolders </span><span class="cov0" title="0">{
                rootFolderStr, ok := rootFolder.(string)
                if !ok </span><span class="cov0" title="0">{
                        utils.Error("Invalid root folder type.")
                        continue</span>
                }

                <span class="cov0" title="0">rootFolderWg.Add(1)
                go func(folder string) </span><span class="cov0" title="0">{
                        defer rootFolderWg.Done()

                        utils.Debug("Processing root folder: " + folder)
                        utils.UpdateCreativeLoaderMessage(fmt.Sprintf("Processing folder: %s", folder))

                        changedFiles, err := GitRunnerInstance.GetChangedFiles([]string{folder}, 5)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("Failed to retrieve changed files for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                                return
                        }</span>

                        // Extract file paths from folders
                        <span class="cov0" title="0">var allChangedFiles []string
                        for _, folderData := range changedFiles </span><span class="cov0" title="0">{
                                for _, fileEntry := range folderData.Files </span><span class="cov0" title="0">{
                                        allChangedFiles = append(allChangedFiles, fileEntry.Name)
                                }</span>
                        }

                        <span class="cov0" title="0">if len(allChangedFiles) == 0 </span><span class="cov0" title="0">{
                                utils.Debug("No changed files found in folder: " + folder)
                                mu.Lock()
                                processedFolders++
                                utils.UpdateCreativeLoaderMessage(fmt.Sprintf("Processed %d/%d folders", processedFolders, totalFolders))
                                mu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">if len(allChangedFiles) &gt; numFiles[0] </span><span class="cov0" title="0">{
                                allChangedFiles = allChangedFiles[:numFiles[0]]
                        }</span>

                        <span class="cov0" title="0">utils.Debug("Total files to process in folder '" + folder + "': " + strconv.Itoa(len(allChangedFiles)))
                        utils.UpdateCreativeLoaderPhase("generating")
                        utils.UpdateCreativeLoaderMessage(fmt.Sprintf("Generating messages for %d files in %s", len(allChangedFiles), folder))

                        err = GitRunnerInstance.BatchProcessGetMessages(allChangedFiles, folder)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("Batch processing failed for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                        }</span>

                        <span class="cov0" title="0">mu.Lock()
                        processedFolders++
                        utils.UpdateCreativeLoaderMessage(fmt.Sprintf("Processed %d/%d folders", processedFolders, totalFolders))
                        mu.Unlock()</span>
                }(rootFolderStr)
        }

        // Update loader to show waiting for completion
        <span class="cov0" title="0">utils.UpdateCreativeLoaderPhase("finalizing")
        utils.UpdateCreativeLoaderMessage("Waiting for all folders to complete")

        rootFolderWg.Wait()

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                utils.StopCreativeLoader()
                utils.ShowCompletionMessage("Batch processing completed with errors", false)
                utils.Error("Batch processing completed with errors.")
                utils.Debug("Errors encountered: " + fmt.Sprint(errors))
                return fmt.Errorf("one or more errors occurred while preparing commit messages")
        }</span>

        // Stop loader and show success
        <span class="cov0" title="0">utils.StopCreativeLoader()
        utils.ShowCompletionMessage("Commit message generation completed successfully for all folders", true)
        utils.Success("Commit message generation completed successfully for all folders.")

        output.SaveToFile()
        return nil</span>
}

func GetMsgsForRootFolder(folder string, numFiles ...int) error <span class="cov0" title="0">{
        if folder == "" </span><span class="cov0" title="0">{
                utils.Error("Root folder is empty.")
                return fmt.Errorf("root folder is empty")
        }</span>

        // Start creative loader for single folder processing
        <span class="cov0" title="0">utils.StartCreativeLoader(fmt.Sprintf("Analyzing folder: %s", folder), utils.ProcessingAnimation)
        utils.UpdateCreativeLoaderPhase("analyzing")

        numFilesToCommit := 10 // Default value
        if len(numFiles) &gt; 0 &amp;&amp; numFiles[0] &gt; 0 </span><span class="cov0" title="0">{
                utils.Debug("Using provided number of files to commit: " + strconv.Itoa(numFiles[0]))
                numFilesToCommit = numFiles[0]
        }</span> else<span class="cov0" title="0"> {
                if configValue := config.Get("numFilesToCommit"); configValue != "" </span><span class="cov0" title="0">{
                        if configValueFloat, ok := configValue.(float64); ok </span><span class="cov0" title="0">{
                                utils.Debug("Using config value for numFilesToCommit: " + strconv.FormatFloat(configValueFloat, 'f', -1, 64))
                                numFilesToCommit = int(configValueFloat)
                        }</span> else<span class="cov0" title="0"> if configValueStr, ok := configValue.(string); ok </span><span class="cov0" title="0">{
                                if parsedValue, err := strconv.Atoi(configValueStr); err == nil </span><span class="cov0" title="0">{
                                        utils.Debug("Using config value for numFilesToCommit from string: " + configValueStr)
                                        numFilesToCommit = parsedValue
                                }</span> else<span class="cov0" title="0"> {
                                        utils.Error("Invalid string value for numFilesToCommit: " + configValueStr)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">utils.Debug("Preparing commit messages for " + strconv.Itoa(numFilesToCommit) + " files in folder: " + folder)

        utils.UpdateCreativeLoaderPhase("processing")
        utils.UpdateCreativeLoaderMessage("Scanning for changed files")

        changedFiles, err := GitRunnerInstance.GetAllChangedFiles(folder)
        if err != nil </span><span class="cov0" title="0">{
                utils.StopCreativeLoader()
                utils.Error("Failed to retrieve changed files for folder '" + folder + "' - " + err.Error())
                return fmt.Errorf("failed to get changed files: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                utils.StopCreativeLoader()
                utils.ShowCompletionMessage(fmt.Sprintf("No changed files found in folder: %s", folder), true)
                utils.Debug("No changed files found in folder: " + folder)
                return nil
        }</span>

        <span class="cov0" title="0">if len(changedFiles) &gt; numFilesToCommit </span><span class="cov0" title="0">{
                changedFiles = changedFiles[:numFilesToCommit]
        }</span>

        <span class="cov0" title="0">utils.Debug("Total files to process in folder '" + folder + "': " + strconv.Itoa(len(changedFiles)))

        utils.UpdateCreativeLoaderPhase("generating")
        utils.UpdateCreativeLoaderMessage(fmt.Sprintf("Generating messages for %d files", len(changedFiles)))

        err = GitRunnerInstance.BatchProcessGetMessages(changedFiles, folder)
        if err != nil </span><span class="cov0" title="0">{
                utils.StopCreativeLoader()
                utils.ShowCompletionMessage("Batch processing failed", false)
                utils.Error("Batch processing failed for folder '" + folder + "' - " + err.Error())
                return fmt.Errorf("batch processing failed: %s", err.Error())
        }</span>

        // Stop loader and show success
        <span class="cov0" title="0">utils.StopCreativeLoader()
        utils.ShowCompletionMessage(fmt.Sprintf("Commit message generation completed for folder: %s", folder), true)
        utils.Success("Commit message generation completed successfully for folder: " + folder)
        utils.Debug("All output: " + fmt.Sprint(output.GetAll()))

        output.SaveToFile()
        return nil</span>
}

func GroupAndGetAllMsgs(numFiles ...int) error <span class="cov0" title="0">{
        // Start creative loader for grouped processing
        utils.StartCreativeLoader("Analyzing repository for grouped processing", utils.BrailleAnimation)
        utils.UpdateCreativeLoaderPhase("clustering")

        utils.Debug("Preparing grouped commit messages with embeddings for " + strconv.Itoa(numFiles[0]) + " files per folder.")

        rootFolders, ok := config.Get("root_folders").([]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.StopCreativeLoader()
                utils.Error("Invalid or missing root_folders configuration.")
                return fmt.Errorf("invalid or missing root_folders configuration")
        }</span>

        <span class="cov0" title="0">clusters := 10 // Default value
        if len(numFiles) &gt; 0 &amp;&amp; numFiles[0] &gt; 0 </span><span class="cov0" title="0">{
                utils.Debug("Using provided number of files to commit: " + strconv.Itoa(numFiles[0]))
                clusters = numFiles[0]
        }</span> else<span class="cov0" title="0"> {
                if configValue := config.Get("numFilesToCommit"); configValue != "" </span><span class="cov0" title="0">{
                        if configValueFloat, ok := configValue.(float64); ok </span><span class="cov0" title="0">{
                                utils.Debug("Using config value for numFilesToCommit: " + strconv.FormatFloat(configValueFloat, 'f', -1, 64))
                                clusters = int(configValueFloat)
                        }</span> else<span class="cov0" title="0"> if configValueStr, ok := configValue.(string); ok </span><span class="cov0" title="0">{
                                if parsedValue, err := strconv.Atoi(configValueStr); err == nil </span><span class="cov0" title="0">{
                                        utils.Debug("Using config value for numFilesToCommit from string: " + configValueStr)
                                        clusters = parsedValue
                                }</span> else<span class="cov0" title="0"> {
                                        utils.Error("Invalid string value for numFilesToCommit: " + configValueStr)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">var rootFolderWg sync.WaitGroup
        var mu sync.Mutex
        var errors []string

        for _, rootFolder := range rootFolders </span><span class="cov0" title="0">{
                rootFolderStr, ok := rootFolder.(string)
                if !ok </span><span class="cov0" title="0">{
                        utils.Error("Invalid root folder type.")
                        continue</span>
                }

                <span class="cov0" title="0">rootFolderWg.Add(1)
                go func(folder string) </span><span class="cov0" title="0">{
                        defer rootFolderWg.Done()

                        utils.Debug("Grouped (embedding-based) processing for folder: " + folder)
                        utils.UpdateCreativeLoaderMessage(fmt.Sprintf("Clustering files in folder: %s", folder))

                        changedFiles, err := GitRunnerInstance.GetAllChangedFiles(folder)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("Failed to retrieve changed files for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                                utils.Debug("No changed files found in folder: " + folder)
                                return
                        }</span>

                        <span class="cov0" title="0">utils.Debug("Total files to process with embeddings in folder '" + folder + "': " + strconv.Itoa(len(changedFiles)))
                        utils.UpdateCreativeLoaderPhase("generating")
                        utils.UpdateCreativeLoaderMessage(fmt.Sprintf("Generating grouped messages for %d files", len(changedFiles)))

                        err = GitRunnerInstance.BatchProcessWithEmbeddings(changedFiles, folder, clusters)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("Embedding-based batch processing failed for folder '" + folder + "' - " + err.Error())
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, Error: %s", folder, err.Error()))
                                mu.Unlock()
                        }</span>
                }(rootFolderStr)
        }

        <span class="cov0" title="0">utils.UpdateCreativeLoaderPhase("finalizing")
        utils.UpdateCreativeLoaderMessage("Completing grouped processing")

        rootFolderWg.Wait()

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                utils.StopCreativeLoader()
                utils.ShowCompletionMessage("Grouped processing completed with errors", false)
                utils.Error("Grouped embedding-based batch processing completed with errors.")
                utils.Debug("Errors encountered: " + fmt.Sprint(errors))
                return fmt.Errorf("one or more errors occurred during grouped commit message generation with embeddings")
        }</span>

        // Stop loader and show success
        <span class="cov0" title="0">utils.StopCreativeLoader()
        utils.ShowCompletionMessage("Grouped commit message generation completed successfully for all folders", true)
        utils.Success("Grouped commit message generation with embeddings completed successfully for all folders.")
        output.SaveToFile()
        return nil</span>
}

func GroupAndGetMsgsForRootFolder(folder string, numFiles ...int) error <span class="cov0" title="0">{
        if folder == "" </span><span class="cov0" title="0">{
                utils.Error("Root folder is empty.")
                return fmt.Errorf("root folder is empty")
        }</span>

        // Start creative loader for grouped single folder processing
        <span class="cov0" title="0">utils.StartCreativeLoader(fmt.Sprintf("Clustering files in folder: %s", folder), utils.BrailleAnimation)
        utils.UpdateCreativeLoaderPhase("clustering")

        clusters := 10 // Default value
        if len(numFiles) &gt; 0 &amp;&amp; numFiles[0] &gt; 0 </span><span class="cov0" title="0">{
                utils.Debug("Using provided number of files to commit: " + strconv.Itoa(numFiles[0]))
                clusters = numFiles[0]
        }</span> else<span class="cov0" title="0"> {
                if configValue := config.Get("numFilesToCommit"); configValue != "" </span><span class="cov0" title="0">{
                        if configValueFloat, ok := configValue.(float64); ok </span><span class="cov0" title="0">{
                                utils.Debug("Using config value for numFilesToCommit: " + strconv.FormatFloat(configValueFloat, 'f', -1, 64))
                                clusters = int(configValueFloat)
                        }</span> else<span class="cov0" title="0"> if configValueStr, ok := configValue.(string); ok </span><span class="cov0" title="0">{
                                if parsedValue, err := strconv.Atoi(configValueStr); err == nil </span><span class="cov0" title="0">{
                                        utils.Debug("Using config value for numFilesToCommit from string: " + configValueStr)
                                        clusters = parsedValue
                                }</span> else<span class="cov0" title="0"> {
                                        utils.Error("Invalid string value for numFilesToCommit: " + configValueStr)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">utils.Debug("Preparing commit messages for " + strconv.Itoa(clusters) + " files in folder: " + folder)

        utils.UpdateCreativeLoaderPhase("processing")
        utils.UpdateCreativeLoaderMessage("Scanning for changed files")

        changedFiles, err := GitRunnerInstance.GetAllChangedFiles(folder)
        if err != nil </span><span class="cov0" title="0">{
                utils.StopCreativeLoader()
                utils.Error("Failed to retrieve changed files for folder '" + folder + "' - " + err.Error())
                return fmt.Errorf("failed to get changed files: %s", err.Error())
        }</span>

        <span class="cov0" title="0">if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                utils.StopCreativeLoader()
                utils.ShowCompletionMessage(fmt.Sprintf("No changed files found in folder: %s", folder), true)
                utils.Debug("No changed files found in folder: " + folder)
                return nil
        }</span>

        <span class="cov0" title="0">utils.Debug("Total files to process in folder '" + folder + "': " + strconv.Itoa(len(changedFiles)))
        utils.UpdateCreativeLoaderPhase("generating")
        utils.UpdateCreativeLoaderMessage(fmt.Sprintf("Generating grouped messages for %d files", len(changedFiles)))

        err = GitRunnerInstance.BatchProcessWithEmbeddings(changedFiles, folder, clusters)
        if err != nil </span><span class="cov0" title="0">{
                utils.StopCreativeLoader()
                utils.ShowCompletionMessage("Grouped batch processing failed", false)
                utils.Error("Batch processing failed for folder '" + folder + "' - " + err.Error())
                return fmt.Errorf("batch processing failed: %s", err.Error())
        }</span>

        // Stop loader and show success
        <span class="cov0" title="0">utils.StopCreativeLoader()
        utils.ShowCompletionMessage(fmt.Sprintf("Grouped commit message generation completed for folder: %s", folder), true)
        utils.Success("Commit message generation completed successfully for folder: " + folder)
        utils.Debug("All output: " + fmt.Sprint(output.GetAll()))

        output.SaveToFile()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package core

import (
        "GitCury/config"
        "GitCury/utils"
        "fmt"
        "sync"
)

func PushAllRoots(branchName string) error <span class="cov0" title="0">{
        rootFolders, ok := config.Get("root_folders").([]interface{})
        if !ok </span><span class="cov0" title="0">{
                utils.Error("❌ Invalid or missing root_folders configuration", "config")
                return utils.NewValidationError(
                        "Invalid or missing root_folders configuration",
                        nil,
                        map[string]interface{}{
                                "configKey": "root_folders",
                        },
                        "config",
                )
        }</span>

        <span class="cov0" title="0">var rootFolderWg sync.WaitGroup
        var mu sync.Mutex
        var errors []string

        for _, rootFolder := range rootFolders </span><span class="cov0" title="0">{
                rootFolderStr, ok := rootFolder.(string)
                if !ok </span><span class="cov0" title="0">{
                        utils.Error("⚠️ Invalid root folder type", "config")
                        continue</span>
                }

                <span class="cov0" title="0">rootFolderWg.Add(1)

                go func(folder string) </span><span class="cov0" title="0">{
                        defer rootFolderWg.Done()
                        utils.Debug("📂 Root folder to push: " + folder)

                        err := GitRunnerInstance.ProgressPushBranch(folder, branchName)
                        if err != nil </span><span class="cov0" title="0">{
                                // Extract file information if available in the error
                                fileInfo := folder
                                if structErr, ok := err.(*utils.StructuredError); ok &amp;&amp; structErr.ProcessedFile != "" </span><span class="cov0" title="0">{
                                        fileInfo = structErr.ProcessedFile
                                }</span>

                                <span class="cov0" title="0">utils.Error("❌ Failed to push branch for folder '"+folder+"' - "+err.Error(), fileInfo)
                                mu.Lock()
                                errors = append(errors, fmt.Sprintf("Folder: %s, File: %s, Error: %s", folder, fileInfo, err.Error()))
                                mu.Unlock()
                                return</span>
                        }
                        <span class="cov0" title="0">utils.Success("✅ Successfully pushed branch for folder: " + folder)</span>
                }(rootFolderStr)
        }

        <span class="cov0" title="0">rootFolderWg.Wait()

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                filesInfo := "multiple_folders"
                utils.Error("❌ Errors occurred during push operation", filesInfo)
                return utils.NewGitError(
                        "One or more errors occurred while pushing branches",
                        fmt.Errorf("multiple push errors"),
                        map[string]interface{}{
                                "errors": errors,
                        },
                        filesInfo,
                )
        }</span>

        <span class="cov0" title="0">utils.Success("🌐 Push operation for all roots completed successfully")
        return nil</span>
}

func PushOneRoot(rootFolderName, branchName string) error <span class="cov0" title="0">{
        utils.Debug("📂 Targeting root folder for push: " + rootFolderName)

        err := GitRunnerInstance.ProgressPushBranch(rootFolderName, branchName)
        if err != nil </span><span class="cov0" title="0">{
                // Extract file information if available in the error
                fileInfo := rootFolderName
                if structErr, ok := err.(*utils.StructuredError); ok &amp;&amp; structErr.ProcessedFile != "" </span><span class="cov0" title="0">{
                        fileInfo = structErr.ProcessedFile
                }</span>

                <span class="cov0" title="0">utils.Error("❌ Failed to push branch for folder '"+rootFolderName+"' - "+err.Error(), fileInfo)
                return utils.NewGitError(
                        "Failed to push branch for folder",
                        err,
                        map[string]interface{}{
                                "folder": rootFolderName,
                                "branch": branchName,
                        },
                        fileInfo,
                )</span>
        }

        <span class="cov0" title="0">utils.Success("✅ Push operation for root folder '" + rootFolderName + "' completed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package di

import "GitCury/interfaces"

// GeminiRunnerInstance allows dependency injection for testing
var GeminiRunnerInstance interfaces.GeminiRunner

// SetGeminiRunner allows injecting a custom GeminiRunner (used in tests)
func SetGeminiRunner(runner interfaces.GeminiRunner) <span class="cov0" title="0">{
        GeminiRunnerInstance = runner
}</span>

// GetGeminiRunner returns the current Gemini runner instance
func GetGeminiRunner() interfaces.GeminiRunner <span class="cov0" title="0">{
        return GeminiRunnerInstance
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package embeddings

import (
        "GitCury/config"
        "GitCury/utils"
        "context"
        "fmt"
        "math"
        "math/rand"
        "os"
        "strings"
        "time"

        "google.golang.org/genai"
)

// Circuit breaker for rate limiting
var (
        lastFailureTime         time.Time
        consecutiveFailures     int
        circuitBreakerThreshold = 3
        circuitBreakerTimeout   = 5 * time.Minute
)

// checkCircuitBreaker returns true if we should skip the request due to circuit breaker
func checkCircuitBreaker() bool <span class="cov0" title="0">{
        if consecutiveFailures &gt;= circuitBreakerThreshold </span><span class="cov0" title="0">{
                if time.Since(lastFailureTime) &lt; circuitBreakerTimeout </span><span class="cov0" title="0">{
                        utils.Warning("[EMBEDDINGS]: Circuit breaker active - skipping request to prevent further rate limiting")
                        return true
                }</span>
                // Reset circuit breaker after timeout
                <span class="cov0" title="0">consecutiveFailures = 0</span>
        }
        <span class="cov0" title="0">return false</span>
}

func GenerateEmbedding(text string) ([]float32, error) <span class="cov0" title="0">{
        // Check circuit breaker first
        if checkCircuitBreaker() </span><span class="cov0" title="0">{
                return nil, utils.NewAPIError(
                        "Circuit breaker active due to repeated rate limit errors",
                        nil,
                        map[string]interface{}{
                                "consecutiveFailures": consecutiveFailures,
                                "nextRetryAfter":      time.Until(lastFailureTime.Add(circuitBreakerTimeout)).String(),
                        },
                )
        }</span>

        // Get the API key from config or environment
        <span class="cov0" title="0">apiKeyInterface := config.Get("GEMINI_API_KEY")
        apiKey, ok := apiKeyInterface.(string)
        if !ok || apiKey == "" </span><span class="cov0" title="0">{
                apiKey = os.Getenv("GEMINI_API_KEY")
                if apiKey == "" </span><span class="cov0" title="0">{
                        return nil, utils.NewConfigError(
                                "Google API key not found",
                                nil,
                                map[string]interface{}{
                                        "configKey": "GEMINI_API_KEY",
                                        "envVar":    "GEMINI_API_KEY",
                                },
                        )
                }</span>
        }

        // Create a context with timeout for the entire operation
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 600*time.Second)
        defer cancel()

        var embedding *genai.ContentEmbedding

        // Initialize the client outside the retry loop for better performance
        client, err := genai.NewClient(ctx, &amp;genai.ClientConfig{
                APIKey:  apiKey,
                Backend: genai.BackendGeminiAPI,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, utils.NewAPIError(
                        "Error creating Gemini client",
                        err,
                        map[string]interface{}{
                                "apiProvider": "Google Gemini",
                        },
                )
        }</span>

        // Prepare the content once for all retries
        <span class="cov0" title="0">contents := []*genai.Content{
                genai.NewContentFromText(text, genai.RoleUser),
        }

        // Define the operation to retry
        embedOperation := func() error </span><span class="cov0" title="0">{
                result, err := client.Models.EmbedContent(ctx,
                        "text-embedding-004",
                        contents,
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        // Check for rate limit errors and update circuit breaker
                        if strings.Contains(err.Error(), "429") || strings.Contains(err.Error(), "quota") </span><span class="cov0" title="0">{
                                consecutiveFailures++
                                lastFailureTime = time.Now()
                                utils.Warning("[EMBEDDINGS]: Rate limit detected, updating circuit breaker")
                        }</span>
                        <span class="cov0" title="0">return utils.NewAPIError(
                                "Error getting embeddings from Gemini API",
                                err,
                                map[string]interface{}{
                                        "modelName":  "text-embedding-004",
                                        "textLength": len(text),
                                },
                        )</span>
                }

                // Reset circuit breaker on success
                <span class="cov0" title="0">consecutiveFailures = 0

                if len(result.Embeddings) == 0 || result.Embeddings[0] == nil </span><span class="cov0" title="0">{
                        return utils.NewAPIError(
                                "Received empty embedding response from API",
                                nil,
                                map[string]interface{}{
                                        "modelName": "text-embedding-004",
                                },
                        )
                }</span>

                <span class="cov0" title="0">embedding = result.Embeddings[0]
                return nil</span>
        }

        // Use the retry mechanism with a more conservative configuration for rate limit issues
        <span class="cov0" title="0">retryConfig := utils.RetryConfig{
                MaxRetries:   3,                // Reduced from 10
                InitialDelay: 5 * time.Second,  // Reduced from 30
                MaxDelay:     30 * time.Second, // Reduced from 120
                Factor:       2.0,
        }

        err = utils.WithRetry(ctx, "GetEmbeddings", retryConfig, embedOperation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err // Already wrapped with context by WithRetry
        }</span>

        <span class="cov0" title="0">flatEmbeddings := embedding.Values

        if len(flatEmbeddings) == 0 </span><span class="cov0" title="0">{
                return nil, utils.NewAPIError(
                        "Received empty embedding vector from API",
                        nil,
                        map[string]interface{}{
                                "modelName":      "text-embedding-004",
                                "responseStatus": "empty vector",
                        },
                )
        }</span>

        <span class="cov0" title="0">return flatEmbeddings, nil</span>
}

func KMeans(data [][]float32, k int, maxIter int) ([]int, error) <span class="cov0" title="0">{
        if k &lt;= 0 || len(data) == 0 </span><span class="cov0" title="0">{
                return nil, utils.NewValidationError(
                        "Invalid parameters for KMeans clustering",
                        nil,
                        map[string]interface{}{
                                "k":             k,
                                "dataPoints":    len(data),
                                "maxIterations": maxIter,
                        },
                )
        }</span>
        <span class="cov0" title="0">if len(data) &lt; k </span><span class="cov0" title="0">{
                return nil, utils.NewValidationError(
                        "Number of clusters cannot exceed data points",
                        nil,
                        map[string]interface{}{
                                "k":          k,
                                "dataPoints": len(data),
                        },
                )
        }</span>

        <span class="cov0" title="0">n := len(data)
        dim := len(data[0])
        labels := make([]int, n)
        centroids := make([][]float32, k)

        rng := rand.New(rand.NewSource(time.Now().UnixNano()))
        perm := rng.Perm(n)
        for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                centroids[i] = make([]float32, dim)
                copy(centroids[i], data[perm[i]])
        }</span>

        <span class="cov0" title="0">for iter := 0; iter &lt; maxIter; iter++ </span><span class="cov0" title="0">{
                for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        labels[i] = closestCentroid(data[i], centroids)
                }</span>

                <span class="cov0" title="0">newCentroids := make([][]float32, k)
                counts := make([]int, k)

                for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                        newCentroids[i] = make([]float32, dim)
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        label := labels[i]
                        counts[label]++
                        for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                                newCentroids[label][j] += data[i][j]
                        }</span>
                }

                <span class="cov0" title="0">for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                        if counts[i] == 0 </span><span class="cov0" title="0">{
                                newCentroids[i] = make([]float32, dim)
                                copy(newCentroids[i], data[rng.Intn(n)])
                        }</span> else<span class="cov0" title="0"> {
                                for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                                        newCentroids[i][j] /= float32(counts[i])
                                }</span>
                        }
                }

                <span class="cov0" title="0">centroids = newCentroids</span>
        }

        <span class="cov0" title="0">return labels, nil</span>
}

func closestCentroid(point []float32, centroids [][]float32) int <span class="cov0" title="0">{
        minDist := float64(math.MaxFloat64)
        minIndex := 0

        for i, c := range centroids </span><span class="cov0" title="0">{
                dist := float64(0.0)
                for j := range point </span><span class="cov0" title="0">{
                        d := float64(point[j] - c[j])
                        dist += d * d
                }</span>
                <span class="cov0" title="0">if dist &lt; minDist </span><span class="cov0" title="0">{
                        minDist = dist
                        minIndex = i
                }</span>
        }
        <span class="cov0" title="0">return minIndex</span>
}

// GetFileDiff gets the diff for a file using git commands
func GetFileDiff(filePath string) (string, error) <span class="cov0" title="0">{
        // This is a simplified version for testing
        // In real implementation, this would use git commands
        return "mock diff for " + filePath, nil
}</span>

// GenerateCommitMessage generates a commit message for the given file path
func GenerateCommitMessage(filePath string) (string, error) <span class="cov0" title="0">{
        // This is a simplified version for testing
        // In real implementation, this would use AI to generate commit messages
        return "feat: update " + filePath, nil
}</span>

// CosineSimilarity calculates the cosine similarity between two vectors
func CosineSimilarity(vec1, vec2 []float32) float32 <span class="cov0" title="0">{
        if len(vec1) != len(vec2) </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">var dotProduct, normA, normB float64

        for i := range vec1 </span><span class="cov0" title="0">{
                dotProduct += float64(vec1[i] * vec2[i])
                normA += float64(vec1[i] * vec1[i])
                normB += float64(vec2[i] * vec2[i])
        }</span>

        <span class="cov0" title="0">if normA == 0.0 || normB == 0.0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">return float32(dotProduct / (math.Sqrt(normA) * math.Sqrt(normB)))</span>
}

// K-means++ initialization for better centroid selection
func kMeansPlusPlus(data [][]float32, k int) [][]float32 <span class="cov0" title="0">{
        n := len(data)
        dim := len(data[0])
        centroids := make([][]float32, k)
        rng := rand.New(rand.NewSource(time.Now().UnixNano()))

        // Choose first centroid randomly
        centroids[0] = make([]float32, dim)
        copy(centroids[0], data[rng.Intn(n)])

        // Choose remaining centroids based on distance probability
        for i := 1; i &lt; k; i++ </span><span class="cov0" title="0">{
                distances := make([]float64, n)
                totalDistance := 0.0

                // Calculate minimum distance to existing centroids for each point
                for j := 0; j &lt; n; j++ </span><span class="cov0" title="0">{
                        minDist := math.MaxFloat64
                        for c := 0; c &lt; i; c++ </span><span class="cov0" title="0">{
                                dist := euclideanDistance(data[j], centroids[c])
                                if dist &lt; minDist </span><span class="cov0" title="0">{
                                        minDist = dist
                                }</span>
                        }
                        <span class="cov0" title="0">distances[j] = minDist * minDist // Square the distance for probability
                        totalDistance += distances[j]</span>
                }

                // Choose next centroid with probability proportional to squared distance
                <span class="cov0" title="0">if totalDistance &gt; 0 </span><span class="cov0" title="0">{
                        target := rng.Float64() * totalDistance
                        cumulative := 0.0

                        for j := 0; j &lt; n; j++ </span><span class="cov0" title="0">{
                                cumulative += distances[j]
                                if cumulative &gt;= target </span><span class="cov0" title="0">{
                                        centroids[i] = make([]float32, dim)
                                        copy(centroids[i], data[j])
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        // Fallback to random selection if all distances are zero
                        centroids[i] = make([]float32, dim)
                        copy(centroids[i], data[rng.Intn(n)])
                }</span>
        }

        <span class="cov0" title="0">return centroids</span>
}

// Euclidean distance helper function
func euclideanDistance(a, b []float32) float64 <span class="cov0" title="0">{
        var sum float64
        for i := 0; i &lt; len(a); i++ </span><span class="cov0" title="0">{
                diff := float64(a[i] - b[i])
                sum += diff * diff
        }</span>
        <span class="cov0" title="0">return math.Sqrt(sum)</span>
}

// Enhanced K-means with K-means++ initialization and convergence detection
func KMeansOptimized(data [][]float32, k int, maxIter int) ([]int, error) <span class="cov0" title="0">{
        if k &lt;= 0 || len(data) == 0 </span><span class="cov0" title="0">{
                return nil, utils.NewValidationError(
                        "Invalid parameters for KMeans clustering",
                        nil,
                        map[string]interface{}{
                                "k":             k,
                                "dataPoints":    len(data),
                                "maxIterations": maxIter,
                        },
                )
        }</span>
        <span class="cov0" title="0">if len(data) &lt; k </span><span class="cov0" title="0">{
                return nil, utils.NewValidationError(
                        "Number of clusters cannot exceed data points",
                        nil,
                        map[string]interface{}{
                                "k":          k,
                                "dataPoints": len(data),
                        },
                )
        }</span>

        <span class="cov0" title="0">n := len(data)
        dim := len(data[0])
        labels := make([]int, n)

        // Use K-means++ initialization for better starting centroids
        centroids := kMeansPlusPlus(data, k)

        convergenceThreshold := 0.001
        var prevCentroids [][]float32

        for iter := 0; iter &lt; maxIter; iter++ </span><span class="cov0" title="0">{
                // Assign points to closest centroids
                for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        labels[i] = closestCentroid(data[i], centroids)
                }</span>

                // Save previous centroids for convergence check
                <span class="cov0" title="0">prevCentroids = make([][]float32, k)
                for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                        prevCentroids[i] = make([]float32, dim)
                        copy(prevCentroids[i], centroids[i])
                }</span>

                // Update centroids
                <span class="cov0" title="0">newCentroids := make([][]float32, k)
                counts := make([]int, k)

                for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                        newCentroids[i] = make([]float32, dim)
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        label := labels[i]
                        counts[label]++
                        for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                                newCentroids[label][j] += data[i][j]
                        }</span>
                }

                // Handle empty clusters and normalize
                <span class="cov0" title="0">rng := rand.New(rand.NewSource(time.Now().UnixNano()))
                for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                        if counts[i] == 0 </span><span class="cov0" title="0">{
                                newCentroids[i] = make([]float32, dim)
                                copy(newCentroids[i], data[rng.Intn(n)])
                        }</span> else<span class="cov0" title="0"> {
                                for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                                        newCentroids[i][j] /= float32(counts[i])
                                }</span>
                        }
                }

                <span class="cov0" title="0">centroids = newCentroids

                // Check for convergence
                if iter &gt; 0 </span><span class="cov0" title="0">{
                        converged := true
                        for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                                if euclideanDistance(centroids[i], prevCentroids[i]) &gt; convergenceThreshold </span><span class="cov0" title="0">{
                                        converged = false
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if converged </span><span class="cov0" title="0">{
                                utils.Debug(fmt.Sprintf("[EMBEDDINGS]: K-means converged after %d iterations", iter+1))
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return labels, nil</span>
}

// Hierarchical clustering using agglomerative approach
func HierarchicalClustering(data [][]float32, maxClusters int, threshold float32) ([]int, error) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil, utils.NewValidationError(
                        "Cannot perform hierarchical clustering on empty data",
                        nil,
                        map[string]interface{}{
                                "dataPoints": 0,
                        },
                )
        }</span>

        <span class="cov0" title="0">n := len(data)

        // Initialize each point as its own cluster
        clusters := make([][]int, n)
        labels := make([]int, n)
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                clusters[i] = []int{i}
                labels[i] = i
        }</span>

        // Calculate initial distance matrix
        <span class="cov0" title="0">distances := make([][]float32, n)
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                distances[i] = make([]float32, n)
                for j := i + 1; j &lt; n; j++ </span><span class="cov0" title="0">{
                        dist := float32(euclideanDistance(data[i], data[j]))
                        distances[i][j] = dist
                        distances[j][i] = dist
                }</span>
        }

        <span class="cov0" title="0">numClusters := n
        clusterID := n

        // Merge clusters until we reach the desired number or threshold
        for numClusters &gt; maxClusters </span><span class="cov0" title="0">{
                // Find the two closest clusters
                minDist := float32(math.MaxFloat32)
                var mergeI, mergeJ int = -1, -1

                for i := 0; i &lt; len(clusters); i++ </span><span class="cov0" title="0">{
                        if len(clusters[i]) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">for j := i + 1; j &lt; len(clusters); j++ </span><span class="cov0" title="0">{
                                if len(clusters[j]) == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // Calculate minimum distance between clusters (single linkage)
                                <span class="cov0" title="0">clusterDist := float32(math.MaxFloat32)
                                for _, pi := range clusters[i] </span><span class="cov0" title="0">{
                                        for _, pj := range clusters[j] </span><span class="cov0" title="0">{
                                                if distances[pi][pj] &lt; clusterDist </span><span class="cov0" title="0">{
                                                        clusterDist = distances[pi][pj]
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">if clusterDist &lt; minDist &amp;&amp; clusterDist &lt;= threshold </span><span class="cov0" title="0">{
                                        minDist = clusterDist
                                        mergeI, mergeJ = i, j
                                }</span>
                        }
                }

                // If no clusters are close enough to merge, break
                <span class="cov0" title="0">if mergeI == -1 || mergeJ == -1 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Merge clusters
                <span class="cov0" title="0">clusters[mergeI] = append(clusters[mergeI], clusters[mergeJ]...)
                clusters[mergeJ] = nil // Mark as empty

                // Update labels
                for _, pointIdx := range clusters[mergeI] </span><span class="cov0" title="0">{
                        labels[pointIdx] = clusterID
                }</span>

                <span class="cov0" title="0">numClusters--
                clusterID++</span>
        }

        // Renumber labels to be consecutive
        <span class="cov0" title="0">labelMap := make(map[int]int)
        newLabel := 0
        finalLabels := make([]int, n)

        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                if _, exists := labelMap[labels[i]]; !exists </span><span class="cov0" title="0">{
                        labelMap[labels[i]] = newLabel
                        newLabel++
                }</span>
                <span class="cov0" title="0">finalLabels[i] = labelMap[labels[i]]</span>
        }

        <span class="cov0" title="0">utils.Debug(fmt.Sprintf("[EMBEDDINGS]: Hierarchical clustering: %d points -&gt; %d clusters", n, newLabel))
        return finalLabels, nil</span>
}

// Adaptive clustering that chooses between K-means and hierarchical based on data characteristics
func AdaptiveClustering(data [][]float32, targetClusters int, maxIter int) ([]int, error) <span class="cov0" title="0">{
        if len(data) &lt; 10 </span><span class="cov0" title="0">{
                // For small datasets, use hierarchical clustering
                return HierarchicalClustering(data, targetClusters, 0.5)
        }</span>

        // Calculate data variance to determine clustering approach
        <span class="cov0" title="0">variance := calculateDataVariance(data)

        // If variance is low (data is tightly clustered), use hierarchical
        // If variance is high (data is spread out), use K-means
        if variance &lt; 0.1 </span><span class="cov0" title="0">{
                utils.Debug("[EMBEDDINGS]: Using hierarchical clustering for low-variance data")
                return HierarchicalClustering(data, targetClusters, 0.3)
        }</span> else<span class="cov0" title="0"> {
                utils.Debug("[EMBEDDINGS]: Using optimized K-means for high-variance data")
                return KMeansOptimized(data, targetClusters, maxIter)
        }</span>
}

// Calculate data variance helper function
func calculateDataVariance(data [][]float32) float64 <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">n := len(data)
        dim := len(data[0])

        // Calculate mean
        mean := make([]float64, dim)
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                        mean[j] += float64(data[i][j])
                }</span>
        }
        <span class="cov0" title="0">for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                mean[j] /= float64(n)
        }</span>

        // Calculate variance
        <span class="cov0" title="0">var totalVariance float64
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                        diff := float64(data[i][j]) - mean[j]
                        totalVariance += diff * diff
                }</span>
        }

        <span class="cov0" title="0">return totalVariance / float64(n*dim)</span>
}

// ClusteringMetrics holds performance metrics for clustering operations
type ClusteringMetrics struct {
        Algorithm      string        `json:"algorithm"`
        DataPoints     int           `json:"dataPoints"`
        TargetClusters int           `json:"targetClusters"`
        ActualClusters int           `json:"actualClusters"`
        Duration       time.Duration `json:"duration"`
        Iterations     int           `json:"iterations,omitempty"`
        Silhouette     float64       `json:"silhouetteScore,omitempty"`
        Inertia        float64       `json:"inertia,omitempty"`
}

// Global metrics collection
var clusteringMetrics []ClusteringMetrics

// CalculateSilhouetteScore calculates the silhouette score for clustering quality assessment
func CalculateSilhouetteScore(data [][]float32, labels []int) float64 <span class="cov0" title="0">{
        n := len(data)
        if n &lt; 2 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">silhouetteScores := make([]float64, n)

        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                // Calculate a(i) - average distance to points in same cluster
                sameClusterDist := 0.0
                sameClusterCount := 0

                // Calculate b(i) - minimum average distance to points in other clusters
                otherClusterDists := make(map[int][]float64)

                for j := 0; j &lt; n; j++ </span><span class="cov0" title="0">{
                        if i == j </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">dist := euclideanDistance(data[i], data[j])

                        if labels[i] == labels[j] </span><span class="cov0" title="0">{
                                sameClusterDist += dist
                                sameClusterCount++
                        }</span> else<span class="cov0" title="0"> {
                                if _, exists := otherClusterDists[labels[j]]; !exists </span><span class="cov0" title="0">{
                                        otherClusterDists[labels[j]] = []float64{}
                                }</span>
                                <span class="cov0" title="0">otherClusterDists[labels[j]] = append(otherClusterDists[labels[j]], dist)</span>
                        }
                }

                <span class="cov0" title="0">a := 0.0
                if sameClusterCount &gt; 0 </span><span class="cov0" title="0">{
                        a = sameClusterDist / float64(sameClusterCount)
                }</span>

                <span class="cov0" title="0">b := math.MaxFloat64
                for _, dists := range otherClusterDists </span><span class="cov0" title="0">{
                        avgDist := 0.0
                        for _, d := range dists </span><span class="cov0" title="0">{
                                avgDist += d
                        }</span>
                        <span class="cov0" title="0">avgDist /= float64(len(dists))
                        if avgDist &lt; b </span><span class="cov0" title="0">{
                                b = avgDist
                        }</span>
                }

                <span class="cov0" title="0">if b == math.MaxFloat64 </span><span class="cov0" title="0">{
                        silhouetteScores[i] = 0
                }</span> else<span class="cov0" title="0"> {
                        silhouetteScores[i] = (b - a) / math.Max(a, b)
                }</span>
        }

        // Calculate average silhouette score
        <span class="cov0" title="0">avgSilhouette := 0.0
        for _, score := range silhouetteScores </span><span class="cov0" title="0">{
                avgSilhouette += score
        }</span>
        <span class="cov0" title="0">return avgSilhouette / float64(n)</span>
}

// CalculateInertia calculates the within-cluster sum of squares
func CalculateInertia(data [][]float32, labels []int) float64 <span class="cov0" title="0">{
        // Calculate centroids
        clusterMap := make(map[int][]int)
        for i, label := range labels </span><span class="cov0" title="0">{
                clusterMap[label] = append(clusterMap[label], i)
        }</span>

        <span class="cov0" title="0">centroids := make(map[int][]float32)
        for label, indices := range clusterMap </span><span class="cov0" title="0">{
                dim := len(data[0])
                centroid := make([]float32, dim)

                for _, idx := range indices </span><span class="cov0" title="0">{
                        for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                                centroid[j] += data[idx][j]
                        }</span>
                }

                <span class="cov0" title="0">for j := 0; j &lt; dim; j++ </span><span class="cov0" title="0">{
                        centroid[j] /= float32(len(indices))
                }</span>

                <span class="cov0" title="0">centroids[label] = centroid</span>
        }

        // Calculate inertia
        <span class="cov0" title="0">var inertia float64
        for i, point := range data </span><span class="cov0" title="0">{
                centroid := centroids[labels[i]]
                dist := euclideanDistance(point, centroid)
                inertia += dist * dist
        }</span>

        <span class="cov0" title="0">return inertia</span>
}

// KMeansWithMetrics performs K-means clustering with performance monitoring
func KMeansWithMetrics(data [][]float32, k int, maxIter int) ([]int, ClusteringMetrics, error) <span class="cov0" title="0">{
        startTime := time.Now()
        labels, err := KMeansOptimized(data, k, maxIter)
        duration := time.Since(startTime)

        metrics := ClusteringMetrics{
                Algorithm:      "KMeans++",
                DataPoints:     len(data),
                TargetClusters: k,
                Duration:       duration,
                Iterations:     maxIter, // We could track actual iterations in KMeansOptimized
        }

        if err == nil &amp;&amp; len(labels) &gt; 0 </span><span class="cov0" title="0">{
                // Count actual clusters
                clusterSet := make(map[int]bool)
                for _, label := range labels </span><span class="cov0" title="0">{
                        clusterSet[label] = true
                }</span>
                <span class="cov0" title="0">metrics.ActualClusters = len(clusterSet)

                // Calculate quality metrics
                metrics.Silhouette = CalculateSilhouetteScore(data, labels)
                metrics.Inertia = CalculateInertia(data, labels)</span>
        }

        // Store metrics
        <span class="cov0" title="0">clusteringMetrics = append(clusteringMetrics, metrics)

        utils.Debug(fmt.Sprintf("[EMBEDDINGS]: K-means metrics - Duration: %v, Silhouette: %.3f, Inertia: %.3f",
                duration, metrics.Silhouette, metrics.Inertia))

        return labels, metrics, err</span>
}

// HierarchicalWithMetrics performs hierarchical clustering with performance monitoring
func HierarchicalWithMetrics(data [][]float32, maxClusters int, threshold float32) ([]int, ClusteringMetrics, error) <span class="cov0" title="0">{
        startTime := time.Now()
        labels, err := HierarchicalClustering(data, maxClusters, threshold)
        duration := time.Since(startTime)

        metrics := ClusteringMetrics{
                Algorithm:      "Hierarchical",
                DataPoints:     len(data),
                TargetClusters: maxClusters,
                Duration:       duration,
        }

        if err == nil &amp;&amp; len(labels) &gt; 0 </span><span class="cov0" title="0">{
                // Count actual clusters
                clusterSet := make(map[int]bool)
                for _, label := range labels </span><span class="cov0" title="0">{
                        clusterSet[label] = true
                }</span>
                <span class="cov0" title="0">metrics.ActualClusters = len(clusterSet)

                // Calculate quality metrics
                metrics.Silhouette = CalculateSilhouetteScore(data, labels)
                metrics.Inertia = CalculateInertia(data, labels)</span>
        }

        // Store metrics
        <span class="cov0" title="0">clusteringMetrics = append(clusteringMetrics, metrics)

        utils.Debug(fmt.Sprintf("[EMBEDDINGS]: Hierarchical metrics - Duration: %v, Silhouette: %.3f, Clusters: %d",
                duration, metrics.Silhouette, metrics.ActualClusters))

        return labels, metrics, err</span>
}

// GetClusteringMetrics returns all collected clustering metrics
func GetClusteringMetrics() []ClusteringMetrics <span class="cov0" title="0">{
        return clusteringMetrics
}</span>

// ResetMetrics clears all collected metrics
func ResetMetrics() <span class="cov0" title="0">{
        clusteringMetrics = []ClusteringMetrics{}
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package git

import (
        "GitCury/config"
        "GitCury/embeddings"
        "GitCury/utils"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "math"
        "os"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "time"
)

// FileCluster represents a group of related files
type FileCluster struct {
        Files       []string  `json:"files"`
        Similarity  float64   `json:"similarity"`
        ClusterType string    `json:"clusterType"`
        Created     time.Time `json:"created"`
}

// EmbeddingCache stores file embeddings to avoid regenerating them
type EmbeddingCache struct {
        RootFolder  string                    `json:"rootFolder"`
        Embeddings  map[string]FileCacheEntry `json:"embeddings"`
        LastUpdated time.Time                 `json:"lastUpdated"`
}

// FileCacheEntry stores file embedding with metadata
type FileCacheEntry struct {
        FilePath    string    `json:"filePath"`
        Embedding   []float32 `json:"embedding"`
        ContentHash string    `json:"contentHash"`
        LastUpdated time.Time `json:"lastUpdated"`
}

// Enhanced caching structures for better performance
type CacheStats struct {
        TotalRequests  int       `json:"totalRequests"`
        CacheHits      int       `json:"cacheHits"`
        CacheMisses    int       `json:"cacheMisses"`
        HitRatio       float64   `json:"hitRatio"`
        LastCleanup    time.Time `json:"lastCleanup"`
        CacheSizeBytes int64     `json:"cacheSizeBytes"`
        EvictedEntries int       `json:"evictedEntries"`
}

type CacheConfig struct {
        MaxSize         int           `json:"maxSize"`         // Maximum number of entries
        MaxSizeBytes    int64         `json:"maxSizeBytes"`    // Maximum cache size in bytes
        TTL             time.Duration `json:"ttl"`             // Time to live for entries
        CleanupInterval time.Duration `json:"cleanupInterval"` // How often to clean expired entries
}

type LRUNode struct {
        Key   string
        Entry *FileCacheEntry
        Prev  *LRUNode
        Next  *LRUNode
}

type LRUCache struct {
        capacity int
        size     int
        cache    map[string]*LRUNode
        head     *LRUNode
        tail     *LRUNode
}

// Enhanced EmbeddingCache with LRU and statistics
type EnhancedEmbeddingCache struct {
        *EmbeddingCache
        Stats      CacheStats           `json:"stats"`
        Config     CacheConfig          `json:"config"`
        LRU        *LRUCache            `json:"-"` // Don't serialize LRU structure
        LastAccess map[string]time.Time `json:"lastAccess"`
}

// SimilarityMethod defines the method used for calculating similarity
type SimilarityMethod int

const (
        CosineSimilarity SimilarityMethod = iota
        JaccardSimilarity
        ManhattanSimilarity
        WeightedSemanticSimilarity
        HybridSimilarity
)

// String returns the string representation of SimilarityMethod
func (sm SimilarityMethod) String() string <span class="cov0" title="0">{
        switch sm </span>{
        case CosineSimilarity:<span class="cov0" title="0">
                return "cosine"</span>
        case JaccardSimilarity:<span class="cov0" title="0">
                return "jaccard"</span>
        case ManhattanSimilarity:<span class="cov0" title="0">
                return "manhattan"</span>
        case WeightedSemanticSimilarity:<span class="cov0" title="0">
                return "weighted_semantic"</span>
        case HybridSimilarity:<span class="cov0" title="0">
                return "hybrid"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// SmartClusterFiles groups files using multi-layered approach with configurable methods
// When targetClusters is 0 or negative, it uses threshold-based clustering without limits
func SmartClusterFiles(changedFiles []string, rootFolder string, targetClusters int) ([][]string, error) <span class="cov0" title="0">{
        if len(changedFiles) == 0 </span><span class="cov0" title="0">{
                return [][]string{}, nil
        }</span>

        <span class="cov0" title="0">if len(changedFiles) == 1 </span><span class="cov0" title="0">{
                return [][]string{changedFiles}, nil
        }</span>

        // Get clustering configuration
        <span class="cov0" title="0">clusteringConfig := config.GetClusteringConfig()

        // Determine if we should use threshold-based clustering (no cluster limit)
        useThresholdClustering := targetClusters &lt;= 0

        utils.Debug(fmt.Sprintf("[GIT.CLUSTER]: Starting configurable clustering for %d files, method: %s, threshold-based: %v",
                len(changedFiles), clusteringConfig.DefaultMethod, useThresholdClustering))

        // Enable benchmarking if configured
        if clusteringConfig.Performance.EnableBenchmarking </span><span class="cov0" title="0">{
                EnableBenchmarking()
                defer DisableBenchmarking()
        }</span>

        // Check if specific method is requested (not auto)
        <span class="cov0" title="0">if clusteringConfig.DefaultMethod != "auto" &amp;&amp; !clusteringConfig.EnableFallbackMethods </span><span class="cov0" title="0">{
                return executeSpecificMethod(changedFiles, rootFolder, targetClusters, clusteringConfig.DefaultMethod, useThresholdClustering)
        }</span>

        // Use multi-layered approach (auto method or with fallbacks enabled)

        // Layer 1: Directory-based clustering
        <span class="cov0" title="0">if config.IsMethodEnabled(config.DirectoryMethod) </span><span class="cov0" title="0">{
                dirClusters, dirConfidence := directoryBasedClustering(changedFiles, rootFolder, targetClusters)
                dirThreshold := config.GetConfidenceThreshold(config.DirectoryMethod)
                dirSimilarity := config.GetSimilarityThreshold(config.DirectoryMethod)

                if dirConfidence &gt;= dirThreshold &amp;&amp; (!useThresholdClustering || validateClustersByThreshold(dirClusters, rootFolder, dirSimilarity)) </span><span class="cov0" title="0">{
                        utils.Debug("[GIT.CLUSTER]: Directory-based clustering successful with configured thresholds")
                        return dirClusters, nil
                }</span>
        }

        // Layer 2: Pattern-based clustering
        <span class="cov0" title="0">if config.IsMethodEnabled(config.PatternMethod) </span><span class="cov0" title="0">{
                patternClusters, patternConfidence := patternBasedClustering(changedFiles, targetClusters)
                patternThreshold := config.GetConfidenceThreshold(config.PatternMethod)
                patternSimilarity := config.GetSimilarityThreshold(config.PatternMethod)

                if patternConfidence &gt;= patternThreshold &amp;&amp; (!useThresholdClustering || validateClustersByThreshold(patternClusters, rootFolder, patternSimilarity)) </span><span class="cov0" title="0">{
                        utils.Debug("[GIT.CLUSTER]: Pattern-based clustering successful with configured thresholds")
                        return patternClusters, nil
                }</span>
        }

        // Layer 3: Cached embedding clustering
        <span class="cov0" title="0">if config.IsMethodEnabled(config.CachedMethod) </span><span class="cov0" title="0">{
                cachedClusters, cachedConfidence, cacheHitRatio := cachedEmbeddingClustering(changedFiles, rootFolder, targetClusters)
                cachedThreshold := config.GetConfidenceThreshold(config.CachedMethod)
                cachedSimilarity := config.GetSimilarityThreshold(config.CachedMethod)
                minCacheHitRatio := clusteringConfig.Methods.Cached.MinCacheHitRatio

                if cachedConfidence &gt;= cachedThreshold &amp;&amp; cacheHitRatio &gt;= minCacheHitRatio &amp;&amp; (!useThresholdClustering || validateClustersByThreshold(cachedClusters, rootFolder, cachedSimilarity)) </span><span class="cov0" title="0">{
                        utils.Debug("[GIT.CLUSTER]: Cached embedding clustering successful with configured parameters")
                        return cachedClusters, nil
                }</span>
        }

        // Layer 4: Smart sampling for large file sets
        <span class="cov0" title="0">if config.IsMethodEnabled(config.SemanticMethod) &amp;&amp; len(changedFiles) &gt; clusteringConfig.MaxFilesForSemanticClustering </span><span class="cov0" title="0">{
                return smartSamplingClustering(changedFiles, rootFolder, targetClusters, useThresholdClustering)
        }</span>

        // Layer 5: Full semantic clustering (fallback)
        <span class="cov0" title="0">if config.IsMethodEnabled(config.SemanticMethod) </span><span class="cov0" title="0">{
                return fullSemanticClustering(changedFiles, rootFolder, targetClusters, useThresholdClustering)
        }</span>

        // If all methods are disabled, fall back to single file clusters
        <span class="cov0" title="0">utils.Warning("[GIT.CLUSTER]: All clustering methods disabled, using single file clusters")
        return createSingleFileClusters(changedFiles), nil</span>
}

// validateClustersByThreshold checks if clusters meet similarity threshold requirements
func validateClustersByThreshold(clusters [][]string, rootFolder string, threshold float64) bool <span class="cov0" title="0">{
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                if len(cluster) &lt;= 1 </span><span class="cov0" title="0">{
                        continue</span> // Single file clusters are always valid
                }

                // Calculate average similarity within cluster
                <span class="cov0" title="0">avgSimilarity := calculateClusterSimilarity(cluster, rootFolder)
                if avgSimilarity &lt; threshold </span><span class="cov0" title="0">{
                        utils.Debug(fmt.Sprintf("[GIT.CLUSTER]: Cluster failed threshold validation: %.2f &lt; %.2f", avgSimilarity, threshold))
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// calculateClusterSimilarity calculates average similarity within a cluster
func calculateClusterSimilarity(files []string, rootFolder string) float64 <span class="cov0" title="0">{
        if len(files) &lt;= 1 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        // Use file extension and directory similarity as proxy
        <span class="cov0" title="0">extSimilarity := calculateExtensionSimilarity(files)
        dirSimilarity := calculateDirectorySimilarity(files, rootFolder)

        return (extSimilarity + dirSimilarity) / 2.0</span>
}

// calculateExtensionSimilarity calculates similarity based on file extensions
func calculateExtensionSimilarity(files []string) float64 <span class="cov0" title="0">{
        if len(files) &lt;= 1 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov0" title="0">extMap := make(map[string]int)
        for _, file := range files </span><span class="cov0" title="0">{
                ext := strings.ToLower(filepath.Ext(file))
                extMap[ext]++
        }</span>

        // Find the most common extension
        <span class="cov0" title="0">maxCount := 0
        for _, count := range extMap </span><span class="cov0" title="0">{
                if count &gt; maxCount </span><span class="cov0" title="0">{
                        maxCount = count
                }</span>
        }

        <span class="cov0" title="0">return float64(maxCount) / float64(len(files))</span>
}

// calculateDirectorySimilarity calculates similarity based on directory structure
func calculateDirectorySimilarity(files []string, rootFolder string) float64 <span class="cov0" title="0">{
        if len(files) &lt;= 1 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov0" title="0">dirs := make(map[string]int)
        for _, file := range files </span><span class="cov0" title="0">{
                relPath, _ := filepath.Rel(rootFolder, file)
                dir := filepath.Dir(relPath)
                dirs[dir]++
        }</span>

        // Find the most common directory
        <span class="cov0" title="0">maxCount := 0
        for _, count := range dirs </span><span class="cov0" title="0">{
                if count &gt; maxCount </span><span class="cov0" title="0">{
                        maxCount = count
                }</span>
        }

        <span class="cov0" title="0">return float64(maxCount) / float64(len(files))</span>
}

// directoryBasedClustering groups files by directory structure
func directoryBasedClustering(files []string, rootFolder string, targetClusters int) ([][]string, float64) <span class="cov0" title="0">{
        dirGroups := make(map[string][]string)

        for _, file := range files </span><span class="cov0" title="0">{
                relPath, err := filepath.Rel(rootFolder, file)
                if err != nil </span><span class="cov0" title="0">{
                        relPath = file
                }</span>

                <span class="cov0" title="0">dir := filepath.Dir(relPath)
                // Group by immediate parent directory
                dirGroups[dir] = append(dirGroups[dir], file)</span>
        }

        <span class="cov0" title="0">clusters := make([][]string, 0, len(dirGroups))
        for _, group := range dirGroups </span><span class="cov0" title="0">{
                clusters = append(clusters, group)
        }</span>

        // Sort clusters by size (largest first)
        <span class="cov0" title="0">sort.Slice(clusters, func(i, j int) bool </span><span class="cov0" title="0">{
                return len(clusters[i]) &gt; len(clusters[j])
        }</span>)

        // If we have a target cluster count and it's less than what we have, merge smallest clusters
        <span class="cov0" title="0">if targetClusters &gt; 0 &amp;&amp; len(clusters) &gt; targetClusters </span><span class="cov0" title="0">{
                clusters = mergeClusters(clusters, targetClusters)
        }</span>

        // Calculate confidence based on how well files are grouped by directory
        <span class="cov0" title="0">confidence := calculateDirectoryGroupingConfidence(files, clusters, rootFolder)

        utils.Debug(fmt.Sprintf("[GIT.CLUSTER]: Directory-based clustering: %d files -&gt; %d clusters, confidence: %.2f",
                len(files), len(clusters), confidence))

        return clusters, confidence</span>
}

// patternBasedClustering groups files by patterns and relationships
func patternBasedClustering(files []string, targetClusters int) ([][]string, float64) <span class="cov0" title="0">{
        // Group by file extensions
        extGroups := make(map[string][]string)
        for _, file := range files </span><span class="cov0" title="0">{
                ext := strings.ToLower(filepath.Ext(file))
                if ext == "" </span><span class="cov0" title="0">{
                        ext = "no-extension"
                }</span>
                <span class="cov0" title="0">extGroups[ext] = append(extGroups[ext], file)</span>
        }

        // Find test-implementation relationships
        <span class="cov0" title="0">testImplRelations := findTestImplementationRelations(files)

        // Create clusters based on patterns
        clusters := make([][]string, 0)
        processed := make(map[string]bool)

        // First, handle test-implementation pairs
        for testFile, implFile := range testImplRelations </span><span class="cov0" title="0">{
                if !processed[testFile] &amp;&amp; !processed[implFile] </span><span class="cov0" title="0">{
                        cluster := []string{testFile, implFile}
                        clusters = append(clusters, cluster)
                        processed[testFile] = true
                        processed[implFile] = true
                }</span>
        }

        // Then group remaining files by extension
        <span class="cov0" title="0">for _, group := range extGroups </span><span class="cov0" title="0">{
                unprocessed := make([]string, 0)
                for _, file := range group </span><span class="cov0" title="0">{
                        if !processed[file] </span><span class="cov0" title="0">{
                                unprocessed = append(unprocessed, file)
                        }</span>
                }

                <span class="cov0" title="0">if len(unprocessed) &gt; 0 </span><span class="cov0" title="0">{
                        ext := ""
                        if len(group) &gt; 0 </span><span class="cov0" title="0">{
                                ext = strings.ToLower(filepath.Ext(group[0]))
                        }</span>
                        <span class="cov0" title="0">if len(unprocessed) &lt;= 3 || ext == ".md" || ext == ".txt" </span><span class="cov0" title="0">{
                                // Keep small groups together, and documentation files together
                                clusters = append(clusters, unprocessed)
                        }</span> else<span class="cov0" title="0"> {
                                // Split large groups into smaller clusters
                                for len(unprocessed) &gt; 0 </span><span class="cov0" title="0">{
                                        chunkSize := int(math.Min(3, float64(len(unprocessed))))
                                        chunk := unprocessed[:chunkSize]
                                        unprocessed = unprocessed[chunkSize:]
                                        clusters = append(clusters, chunk)
                                }</span>
                        }
                }
        }

        // Merge clusters if we have too many for the target
        <span class="cov0" title="0">if targetClusters &gt; 0 &amp;&amp; len(clusters) &gt; targetClusters </span><span class="cov0" title="0">{
                clusters = mergeClusters(clusters, targetClusters)
        }</span>

        <span class="cov0" title="0">confidence := calculatePatternConfidence(files, clusters)

        utils.Debug(fmt.Sprintf("[GIT.CLUSTER]: Pattern-based clustering: %d files -&gt; %d clusters, confidence: %.2f",
                len(files), len(clusters), confidence))

        return clusters, confidence</span>
}

// findTestImplementationRelations finds test files and their corresponding implementation files
func findTestImplementationRelations(files []string) map[string]string <span class="cov0" title="0">{
        relations := make(map[string]string)

        testFiles := make([]string, 0)
        implFiles := make([]string, 0)

        testPatterns := []*regexp.Regexp{
                regexp.MustCompile(`.*_test\.(go|js|ts|py|java|cpp|c)$`),
                regexp.MustCompile(`.*/test/.*\.(go|js|ts|py|java|cpp|c)$`),
                regexp.MustCompile(`.*/tests/.*\.(go|js|ts|py|java|cpp|c)$`),
                regexp.MustCompile(`.*\.test\.(js|ts)$`),
                regexp.MustCompile(`.*\.spec\.(js|ts)$`),
        }

        for _, file := range files </span><span class="cov0" title="0">{
                isTest := false
                for _, pattern := range testPatterns </span><span class="cov0" title="0">{
                        if pattern.MatchString(strings.ToLower(file)) </span><span class="cov0" title="0">{
                                testFiles = append(testFiles, file)
                                isTest = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isTest </span><span class="cov0" title="0">{
                        implFiles = append(implFiles, file)
                }</span>
        }

        // Try to match test files with implementation files
        <span class="cov0" title="0">for _, testFile := range testFiles </span><span class="cov0" title="0">{
                baseName := filepath.Base(testFile)
                testDir := filepath.Dir(testFile)

                // Remove test suffixes to find the implementation file
                implName := strings.ReplaceAll(baseName, "_test.", ".")
                implName = strings.ReplaceAll(implName, ".test.", ".")
                implName = strings.ReplaceAll(implName, ".spec.", ".")

                // Look for corresponding implementation file
                for _, implFile := range implFiles </span><span class="cov0" title="0">{
                        implBaseName := filepath.Base(implFile)
                        implDir := filepath.Dir(implFile)

                        // Check if names match and directories are related
                        if implBaseName == implName || strings.Contains(testDir, implDir) || strings.Contains(implDir, testDir) </span><span class="cov0" title="0">{
                                relations[testFile] = implFile
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return relations</span>
}

// cachedEmbeddingClustering uses enhanced cached embeddings when available
func cachedEmbeddingClustering(files []string, rootFolder string, targetClusters int) ([][]string, float64, float64) <span class="cov0" title="0">{
        enhancedCache := NewEnhancedEmbeddingCache(rootFolder)
        fileEmbeddings := make(map[string][]float32)
        cacheHits := 0

        // Check enhanced cache for existing embeddings
        for _, file := range files </span><span class="cov0" title="0">{
                if cached, exists := enhancedCache.GetEmbedding(file); exists </span><span class="cov0" title="0">{
                        fileEmbeddings[file] = cached.Embedding
                        cacheHits++
                }</span>
        }

        <span class="cov0" title="0">cacheHitRatio := float64(cacheHits) / float64(len(files))
        stats := enhancedCache.GetStats()

        utils.Debug(fmt.Sprintf("[CACHE]: Enhanced cache stats - Hit ratio: %.3f, Total requests: %d, Cache size: %d bytes",
                stats.HitRatio, stats.TotalRequests, stats.CacheSizeBytes))

        // If we don't have enough cached embeddings, return early
        if cacheHitRatio &lt; 0.3 </span><span class="cov0" title="0">{
                enhancedCache.Save()
                return createSingleFileClusters(files), 0.0, cacheHitRatio
        }</span>

        // Generate embeddings for missing files with intelligent batching and rate limiting
        <span class="cov0" title="0">clusteringConfig := config.GetClusteringConfig()
        maxNewEmbeddings := calculateOptimalBatchSize(len(files), cacheHitRatio)
        newEmbeddings := 0
        recentMisses := len(files) - cacheHits
        rateLimitDelay := time.Duration(clusteringConfig.Methods.Semantic.RateLimitDelay) * time.Millisecond

        for _, file := range files </span><span class="cov0" title="0">{
                if _, exists := fileEmbeddings[file]; !exists &amp;&amp; newEmbeddings &lt; maxNewEmbeddings </span><span class="cov0" title="0">{
                        diff, err := embeddings.GetFileDiff(file)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Warning(fmt.Sprintf("[GIT.CLUSTER]: Could not get diff for file: %s - %v", file, err))
                                continue</span>
                        }

                        // Use optimized diff size based on file type
                        <span class="cov0" title="0">optimalSize := getOptimalDiffSize(file)
                        if len(diff) &gt; optimalSize </span><span class="cov0" title="0">{
                                diff = diff[:optimalSize] + "... [truncated]"
                        }</span>

                        <span class="cov0" title="0">embedding, err := embeddings.GenerateEmbedding(diff)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Warning(fmt.Sprintf("[GIT.CLUSTER]: Could not generate embedding for file: %s - %v", file, err))
                                continue</span>
                        }

                        <span class="cov0" title="0">fileEmbeddings[file] = embedding
                        enhancedCache.PutEmbedding(file, embedding)
                        newEmbeddings++

                        // Use configurable adaptive delay
                        delay := time.Duration(recentMisses*100) * time.Millisecond
                        if delay &lt; rateLimitDelay </span><span class="cov0" title="0">{
                                delay = rateLimitDelay
                        }</span>
                        <span class="cov0" title="0">if delay &gt; 0 </span><span class="cov0" title="0">{
                                time.Sleep(delay)
                        }</span>
                }
        }

        // Perform clustering using available embeddings
        <span class="cov0" title="0">if len(fileEmbeddings) &lt; 2 </span><span class="cov0" title="0">{
                enhancedCache.Save()
                return createSingleFileClusters(files), 0.0, cacheHitRatio
        }</span>

        <span class="cov0" title="0">clusters := performEmbeddingBasedClustering(fileEmbeddings, targetClusters)
        confidence := calculateEmbeddingClusterConfidence(clusters, fileEmbeddings)

        // Save enhanced cache with automatic cleanup
        enhancedCache.Save()

        finalStats := enhancedCache.GetStats()
        utils.Debug(fmt.Sprintf("[GIT.CLUSTER]: Enhanced cached embedding clustering: %d files -&gt; %d clusters, cache hit ratio: %.2f, confidence: %.2f, final cache hit ratio: %.3f",
                len(files), len(clusters), cacheHitRatio, confidence, finalStats.HitRatio))

        return clusters, confidence, cacheHitRatio</span>
}

// smartSamplingClustering handles large file sets by sampling representative files
func smartSamplingClustering(files []string, rootFolder string, targetClusters int, useThresholdClustering bool) ([][]string, error) <span class="cov0" title="0">{
        utils.Debug(fmt.Sprintf("[GIT.CLUSTER]: Using smart sampling for %d files", len(files)))

        // Sample representative files (max 8 to prevent API overload)
        sampleSize := int(math.Min(8, float64(len(files))/2))
        representatives := selectRepresentativeFiles(files, sampleSize)

        // Cluster representatives using embeddings
        reprClusters, err := fullSemanticClustering(representatives, rootFolder, -1, true) // Always use threshold for sampling
        if err != nil </span><span class="cov0" title="0">{
                return fallbackToPatterClustering(files, targetClusters), nil
        }</span>

        // Assign remaining files to clusters based on similarity
        <span class="cov0" title="0">finalClusters := assignFilesToClusters(files, reprClusters, rootFolder)

        // Validate clusters meet threshold requirements if using threshold clustering
        if useThresholdClustering </span><span class="cov0" title="0">{
                finalClusters = filterClustersByThreshold(finalClusters, rootFolder, 0.4)
        }</span>

        <span class="cov0" title="0">utils.Debug(fmt.Sprintf("[GIT.CLUSTER]: Smart sampling clustering: %d files -&gt; %d clusters",
                len(files), len(finalClusters)))

        return finalClusters, nil</span>
}

// fullSemanticClustering performs complete semantic analysis
func fullSemanticClustering(files []string, rootFolder string, targetClusters int, useThresholdClustering bool) ([][]string, error) <span class="cov0" title="0">{
        utils.Debug(fmt.Sprintf("[GIT.CLUSTER]: Performing full semantic clustering for %d files", len(files)))

        // Get clustering configuration for rate limiting
        clusteringConfig := config.GetClusteringConfig()
        rateLimitDelay := time.Duration(clusteringConfig.Methods.Semantic.RateLimitDelay) * time.Millisecond

        fileEmbeddings := make(map[string][]float32)

        // Generate embeddings for all files with configurable rate limiting
        for i, file := range files </span><span class="cov0" title="0">{
                // Rate limiting: add configurable delay between requests
                if i &gt; 0 </span><span class="cov0" title="0">{
                        time.Sleep(rateLimitDelay)
                }</span>

                <span class="cov0" title="0">diff, err := GetFileDiff(file, rootFolder)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Warning(fmt.Sprintf("[GIT.CLUSTER]: Could not get diff for file: %s - %v", file, err))
                        continue</span>
                }

                // Limit diff size
                <span class="cov0" title="0">if len(diff) &gt; 10000 </span><span class="cov0" title="0">{
                        diff = diff[:10000] + "... [truncated]"
                }</span>

                <span class="cov0" title="0">embedding, err := embeddings.GenerateEmbedding(diff)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Warning(fmt.Sprintf("[GIT.CLUSTER]: Could not generate embedding for file: %s - %v", file, err))
                        continue</span>
                }

                <span class="cov0" title="0">fileEmbeddings[file] = embedding</span>
        }

        <span class="cov0" title="0">if len(fileEmbeddings) &lt; 2 </span><span class="cov0" title="0">{
                return createSingleFileClusters(files), nil
        }</span>

        // Perform clustering using configured similarity threshold
        <span class="cov0" title="0">var clusters [][]string
        if useThresholdClustering </span><span class="cov0" title="0">{
                semanticThreshold := config.GetSimilarityThreshold(config.SemanticMethod)
                clusters = performThresholdBasedClustering(fileEmbeddings, semanticThreshold)
        }</span> else<span class="cov0" title="0"> {
                clusters = performEmbeddingBasedClustering(fileEmbeddings, targetClusters)
        }</span>

        <span class="cov0" title="0">utils.Debug(fmt.Sprintf("[GIT.CLUSTER]: Full semantic clustering: %d files -&gt; %d clusters",
                len(files), len(clusters)))

        return clusters, nil</span>
}

// executeSpecificMethod runs a single specific clustering method
func executeSpecificMethod(files []string, rootFolder string, targetClusters int, methodName string, useThresholdClustering bool) ([][]string, error) <span class="cov0" title="0">{
        utils.Debug(fmt.Sprintf("[GIT.CLUSTER]: Executing specific method: %s", methodName))

        switch methodName </span>{
        case "directory":<span class="cov0" title="0">
                if !config.IsMethodEnabled(config.DirectoryMethod) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("directory clustering method is disabled")
                }</span>
                <span class="cov0" title="0">clusters, _ := directoryBasedClustering(files, rootFolder, targetClusters)
                return clusters, nil</span>

        case "pattern":<span class="cov0" title="0">
                if !config.IsMethodEnabled(config.PatternMethod) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("pattern clustering method is disabled")
                }</span>
                <span class="cov0" title="0">clusters, _ := patternBasedClustering(files, targetClusters)
                return clusters, nil</span>

        case "cached":<span class="cov0" title="0">
                if !config.IsMethodEnabled(config.CachedMethod) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cached clustering method is disabled")
                }</span>
                <span class="cov0" title="0">clusters, _, _ := cachedEmbeddingClustering(files, rootFolder, targetClusters)
                return clusters, nil</span>

        case "semantic":<span class="cov0" title="0">
                if !config.IsMethodEnabled(config.SemanticMethod) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("semantic clustering method is disabled")
                }</span>
                <span class="cov0" title="0">return fullSemanticClustering(files, rootFolder, targetClusters, useThresholdClustering)</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown clustering method: %s", methodName)</span>
        }
}

// performThresholdBasedClustering clusters files based on similarity threshold instead of target count
func performThresholdBasedClustering(fileEmbeddings map[string][]float32, threshold float64) [][]string <span class="cov0" title="0">{
        files := make([]string, 0, len(fileEmbeddings))
        embeddingVectors := make([][]float32, 0, len(fileEmbeddings))

        for file, embedding := range fileEmbeddings </span><span class="cov0" title="0">{
                files = append(files, file)
                embeddingVectors = append(embeddingVectors, embedding)
        }</span>

        <span class="cov0" title="0">if len(files) &lt;= 1 </span><span class="cov0" title="0">{
                return createSingleFileClusters(files)
        }</span>

        // Use hierarchical clustering with threshold for better quality
        <span class="cov0" title="0">labels, metrics, err := embeddings.HierarchicalWithMetrics(embeddingVectors, len(files), float32(threshold))
        if err != nil </span><span class="cov0" title="0">{
                utils.Warning(fmt.Sprintf("[GIT.CLUSTER]: Hierarchical clustering failed: %v", err))
                // Fallback to original similarity-based approach
                return performOriginalThresholdClustering(fileEmbeddings, threshold)
        }</span>

        <span class="cov0" title="0">utils.Debug(fmt.Sprintf("[GIT.CLUSTER]: Threshold clustering metrics - Silhouette: %.3f, Clusters: %d",
                metrics.Silhouette, metrics.ActualClusters))

        // Group files by cluster labels
        clusterMap := make(map[int][]string)
        for i, label := range labels </span><span class="cov0" title="0">{
                clusterMap[label] = append(clusterMap[label], files[i])
        }</span>

        <span class="cov0" title="0">clusters := make([][]string, 0, len(clusterMap))
        for _, cluster := range clusterMap </span><span class="cov0" title="0">{
                clusters = append(clusters, cluster)
        }</span>

        <span class="cov0" title="0">return clusters</span>
}

// performOriginalThresholdClustering is the fallback implementation with enhanced similarity
func performOriginalThresholdClustering(fileEmbeddings map[string][]float32, threshold float64) [][]string <span class="cov0" title="0">{
        files := make([]string, 0, len(fileEmbeddings))
        embeddings := make([][]float32, 0, len(fileEmbeddings))

        for file, embedding := range fileEmbeddings </span><span class="cov0" title="0">{
                files = append(files, file)
                embeddings = append(embeddings, embedding)
        }</span>

        // Calculate similarity matrix using enhanced similarity methods
        <span class="cov0" title="0">similarities := make([][]float64, len(files))
        config := DefaultSimilarityConfig()

        for i := range similarities </span><span class="cov0" title="0">{
                similarities[i] = make([]float64, len(files))
                for j := range similarities[i] </span><span class="cov0" title="0">{
                        if i == j </span><span class="cov0" title="0">{
                                similarities[i][j] = 1.0
                        }</span> else<span class="cov0" title="0"> {
                                // Use hybrid similarity for better clustering quality
                                similarities[i][j] = hybridSimilarity(embeddings[i], embeddings[j], config)
                        }</span>
                }
        }

        // Group files that have similarity above threshold
        <span class="cov0" title="0">clusters := make([][]string, 0)
        assigned := make([]bool, len(files))

        for i := 0; i &lt; len(files); i++ </span><span class="cov0" title="0">{
                if assigned[i] </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">cluster := []string{files[i]}
                assigned[i] = true

                // Find all files similar to this one
                for j := i + 1; j &lt; len(files); j++ </span><span class="cov0" title="0">{
                        if !assigned[j] &amp;&amp; similarities[i][j] &gt;= threshold </span><span class="cov0" title="0">{
                                cluster = append(cluster, files[j])
                                assigned[j] = true
                        }</span>
                }

                <span class="cov0" title="0">clusters = append(clusters, cluster)</span>
        }

        <span class="cov0" title="0">return clusters</span>
}

// performEmbeddingBasedClustering performs K-means clustering on embeddings
func performEmbeddingBasedClustering(fileEmbeddings map[string][]float32, targetClusters int) [][]string <span class="cov0" title="0">{
        if targetClusters &lt;= 0 </span><span class="cov0" title="0">{
                targetClusters = int(math.Max(1, math.Min(float64(len(fileEmbeddings))/2, 5)))
        }</span>

        <span class="cov0" title="0">files := make([]string, 0, len(fileEmbeddings))
        vectors := make([][]float32, 0, len(fileEmbeddings))

        for file, embedding := range fileEmbeddings </span><span class="cov0" title="0">{
                files = append(files, file)
                vectors = append(vectors, embedding)
        }</span>

        <span class="cov0" title="0">if len(vectors) &lt;= targetClusters </span><span class="cov0" title="0">{
                return createSingleFileClusters(files)
        }</span>

        // Use adaptive clustering for better performance
        <span class="cov0" title="0">labels, metrics, err := embeddings.KMeansWithMetrics(vectors, targetClusters, 20)
        if err != nil </span><span class="cov0" title="0">{
                utils.Warning(fmt.Sprintf("[GIT.CLUSTER]: K-means clustering failed: %v", err))
                return createSingleFileClusters(files)
        }</span>

        // Log clustering performance metrics
        <span class="cov0" title="0">utils.Debug(fmt.Sprintf("[GIT.CLUSTER]: Clustering completed - Algorithm: %s, Silhouette: %.3f, Duration: %v",
                metrics.Algorithm, metrics.Silhouette, metrics.Duration))

        // Group files by cluster labels
        clusterMap := make(map[int][]string)
        for i, label := range labels </span><span class="cov0" title="0">{
                clusterMap[label] = append(clusterMap[label], files[i])
        }</span>

        <span class="cov0" title="0">clusters := make([][]string, 0, len(clusterMap))
        for _, cluster := range clusterMap </span><span class="cov0" title="0">{
                clusters = append(clusters, cluster)
        }</span>

        <span class="cov0" title="0">return clusters</span>
}

// LRU Cache implementation for embedding management
func NewLRUCache(capacity int) *LRUCache <span class="cov0" title="0">{
        head := &amp;LRUNode{}
        tail := &amp;LRUNode{}
        head.Next = tail
        tail.Prev = head

        return &amp;LRUCache{
                capacity: capacity,
                size:     0,
                cache:    make(map[string]*LRUNode),
                head:     head,
                tail:     tail,
        }
}</span>

func (lru *LRUCache) addToHead(node *LRUNode) <span class="cov0" title="0">{
        node.Prev = lru.head
        node.Next = lru.head.Next
        lru.head.Next.Prev = node
        lru.head.Next = node
}</span>

func (lru *LRUCache) removeNode(node *LRUNode) <span class="cov0" title="0">{
        node.Prev.Next = node.Next
        node.Next.Prev = node.Prev
}</span>

func (lru *LRUCache) moveToHead(node *LRUNode) <span class="cov0" title="0">{
        lru.removeNode(node)
        lru.addToHead(node)
}</span>

func (lru *LRUCache) removeTail() *LRUNode <span class="cov0" title="0">{
        lastNode := lru.tail.Prev
        lru.removeNode(lastNode)
        return lastNode
}</span>

func (lru *LRUCache) Get(key string) (*FileCacheEntry, bool) <span class="cov0" title="0">{
        if node, exists := lru.cache[key]; exists </span><span class="cov0" title="0">{
                lru.moveToHead(node)
                return node.Entry, true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func (lru *LRUCache) Put(key string, entry *FileCacheEntry) *FileCacheEntry <span class="cov0" title="0">{
        if node, exists := lru.cache[key]; exists </span><span class="cov0" title="0">{
                node.Entry = entry
                lru.moveToHead(node)
                return nil
        }</span>

        <span class="cov0" title="0">newNode := &amp;LRUNode{Key: key, Entry: entry}

        if lru.size &gt;= lru.capacity </span><span class="cov0" title="0">{
                tail := lru.removeTail()
                delete(lru.cache, tail.Key)
                lru.size--
                lru.addToHead(newNode)
                lru.cache[key] = newNode
                lru.size++
                return tail.Entry // Return evicted entry
        }</span>

        <span class="cov0" title="0">lru.addToHead(newNode)
        lru.cache[key] = newNode
        lru.size++
        return nil</span>
}

// Enhanced cache management functions
func NewEnhancedEmbeddingCache(rootFolder string) *EnhancedEmbeddingCache <span class="cov0" title="0">{
        baseCache := loadEmbeddingCache(rootFolder)

        config := CacheConfig{
                MaxSize:         1000,             // Maximum 1000 entries
                MaxSizeBytes:    50 * 1024 * 1024, // 50MB max cache size
                TTL:             24 * time.Hour,   // 24 hour TTL
                CleanupInterval: 1 * time.Hour,    // Cleanup every hour
        }

        enhanced := &amp;EnhancedEmbeddingCache{
                EmbeddingCache: baseCache,
                Config:         config,
                LRU:            NewLRUCache(config.MaxSize),
                LastAccess:     make(map[string]time.Time),
                Stats: CacheStats{
                        LastCleanup: time.Now(),
                },
        }

        // Initialize LRU with existing cache entries
        for key, entry := range baseCache.Embeddings </span><span class="cov0" title="0">{
                enhanced.LRU.Put(key, &amp;entry)
                enhanced.LastAccess[key] = entry.LastUpdated
        }</span>

        <span class="cov0" title="0">return enhanced</span>
}

func (ec *EnhancedEmbeddingCache) GetEmbedding(filePath string) (*FileCacheEntry, bool) <span class="cov0" title="0">{
        ec.Stats.TotalRequests++

        // Check if entry exists and is valid
        if entry, exists := ec.LRU.Get(filePath); exists </span><span class="cov0" title="0">{
                // Check TTL
                if time.Since(ec.LastAccess[filePath]) &lt; ec.Config.TTL </span><span class="cov0" title="0">{
                        // Validate file hasn't changed
                        if currentHash := getFileContentHash(filePath); currentHash == entry.ContentHash </span><span class="cov0" title="0">{
                                ec.Stats.CacheHits++
                                ec.LastAccess[filePath] = time.Now()
                                ec.updateHitRatio()
                                return entry, true
                        }</span>
                }
                // Remove expired or invalid entry
                <span class="cov0" title="0">delete(ec.Embeddings, filePath)
                delete(ec.LastAccess, filePath)</span>
        }

        <span class="cov0" title="0">ec.Stats.CacheMisses++
        ec.updateHitRatio()
        return nil, false</span>
}

func (ec *EnhancedEmbeddingCache) PutEmbedding(filePath string, embedding []float32) <span class="cov0" title="0">{
        entry := FileCacheEntry{
                FilePath:    filePath,
                Embedding:   embedding,
                ContentHash: getFileContentHash(filePath),
                LastUpdated: time.Now(),
        }

        // Check if we need to evict due to size constraints
        evicted := ec.LRU.Put(filePath, &amp;entry)
        if evicted != nil </span><span class="cov0" title="0">{
                ec.Stats.EvictedEntries++
                delete(ec.Embeddings, evicted.FilePath)
                delete(ec.LastAccess, evicted.FilePath)
        }</span>

        <span class="cov0" title="0">ec.Embeddings[filePath] = entry
        ec.LastAccess[filePath] = time.Now()
        ec.LastUpdated = time.Now()

        // Check cache size constraints
        ec.enforceMemoryLimits()</span>
}

func (ec *EnhancedEmbeddingCache) updateHitRatio() <span class="cov0" title="0">{
        if ec.Stats.TotalRequests &gt; 0 </span><span class="cov0" title="0">{
                ec.Stats.HitRatio = float64(ec.Stats.CacheHits) / float64(ec.Stats.TotalRequests)
        }</span>
}

func (ec *EnhancedEmbeddingCache) enforceMemoryLimits() <span class="cov0" title="0">{
        // Calculate current cache size in bytes
        totalSize := int64(0)
        for _, entry := range ec.Embeddings </span><span class="cov0" title="0">{
                totalSize += int64(len(entry.Embedding)*4) + int64(len(entry.FilePath)) + int64(len(entry.ContentHash)) + 100 // overhead
        }</span>
        <span class="cov0" title="0">ec.Stats.CacheSizeBytes = totalSize

        // Evict entries if over memory limit
        if totalSize &gt; ec.Config.MaxSizeBytes </span><span class="cov0" title="0">{
                utils.Debug(fmt.Sprintf("[CACHE]: Memory limit exceeded (%d bytes), performing cleanup", totalSize))
                ec.performMemoryCleanup()
        }</span>
}

func (ec *EnhancedEmbeddingCache) performMemoryCleanup() <span class="cov0" title="0">{
        // Sort entries by last access time (oldest first)
        type accessTime struct {
                path string
                time time.Time
        }

        var sortedEntries []accessTime
        for path, lastAccess := range ec.LastAccess </span><span class="cov0" title="0">{
                sortedEntries = append(sortedEntries, accessTime{path, lastAccess})
        }</span>

        <span class="cov0" title="0">sort.Slice(sortedEntries, func(i, j int) bool </span><span class="cov0" title="0">{
                return sortedEntries[i].time.Before(sortedEntries[j].time)
        }</span>)

        // Remove oldest 25% of entries
        <span class="cov0" title="0">removeCount := len(sortedEntries) / 4
        if removeCount &lt; 1 </span><span class="cov0" title="0">{
                removeCount = 1
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; removeCount &amp;&amp; i &lt; len(sortedEntries); i++ </span><span class="cov0" title="0">{
                path := sortedEntries[i].path
                delete(ec.Embeddings, path)
                delete(ec.LastAccess, path)
                ec.Stats.EvictedEntries++
        }</span>

        <span class="cov0" title="0">utils.Debug(fmt.Sprintf("[CACHE]: Cleaned up %d old cache entries", removeCount))</span>
}

func (ec *EnhancedEmbeddingCache) performScheduledCleanup() <span class="cov0" title="0">{
        if time.Since(ec.Stats.LastCleanup) &lt; ec.Config.CleanupInterval </span><span class="cov0" title="0">{
                return
        }</span>

        // Remove expired entries
        <span class="cov0" title="0">expiredCount := 0
        for path, lastAccess := range ec.LastAccess </span><span class="cov0" title="0">{
                if time.Since(lastAccess) &gt; ec.Config.TTL </span><span class="cov0" title="0">{
                        delete(ec.Embeddings, path)
                        delete(ec.LastAccess, path)
                        expiredCount++
                }</span>
        }

        <span class="cov0" title="0">if expiredCount &gt; 0 </span><span class="cov0" title="0">{
                utils.Debug(fmt.Sprintf("[CACHE]: Removed %d expired cache entries", expiredCount))
        }</span>

        <span class="cov0" title="0">ec.Stats.LastCleanup = time.Now()
        ec.enforceMemoryLimits()</span>
}

func (ec *EnhancedEmbeddingCache) Save() <span class="cov0" title="0">{
        ec.performScheduledCleanup()
        saveEmbeddingCache(ec.EmbeddingCache)
}</span>

func (ec *EnhancedEmbeddingCache) GetStats() CacheStats <span class="cov0" title="0">{
        return ec.Stats
}</span>

// Core cache management functions
func saveEmbeddingCache(cache *EmbeddingCache) <span class="cov0" title="0">{
        cacheFile := getCacheFilePath(cache.RootFolder)

        // Ensure cache directory exists
        if err := os.MkdirAll(filepath.Dir(cacheFile), 0755); err != nil </span><span class="cov0" title="0">{
                utils.Warning(fmt.Sprintf("[GIT.CLUSTER]: Failed to create cache directory: %v", err))
                return
        }</span>

        <span class="cov0" title="0">data, err := json.Marshal(cache)
        if err != nil </span><span class="cov0" title="0">{
                utils.Warning(fmt.Sprintf("[GIT.CLUSTER]: Failed to marshal cache: %v", err))
                return
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(cacheFile, data, 0644); err != nil </span><span class="cov0" title="0">{
                utils.Warning(fmt.Sprintf("[GIT.CLUSTER]: Failed to save cache file: %v", err))
        }</span>
}

func getCacheFilePath(rootFolder string) string <span class="cov0" title="0">{
        homeDir, _ := os.UserHomeDir()
        hasher := sha256.Sum256([]byte(rootFolder))
        folderHash := hex.EncodeToString(hasher[:])[:12]
        return filepath.Join(homeDir, ".gitcury", fmt.Sprintf("embedding_cache_%s.json", folderHash))
}</span>

func getFileContentHash(filePath string) string <span class="cov0" title="0">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">hasher := sha256.Sum256(content)
        return hex.EncodeToString(hasher[:])</span>
}

// Helper functions for embedding cache management
func loadEmbeddingCache(rootFolder string) *EmbeddingCache <span class="cov0" title="0">{
        cacheFile := getCacheFilePath(rootFolder)

        if _, err := os.Stat(cacheFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return &amp;EmbeddingCache{
                        RootFolder:  rootFolder,
                        Embeddings:  make(map[string]FileCacheEntry),
                        LastUpdated: time.Now(),
                }
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(cacheFile)
        if err != nil </span><span class="cov0" title="0">{
                utils.Warning(fmt.Sprintf("[GIT.CLUSTER]: Failed to read cache file: %v", err))
                return &amp;EmbeddingCache{
                        RootFolder:  rootFolder,
                        Embeddings:  make(map[string]FileCacheEntry),
                        LastUpdated: time.Now(),
                }
        }</span>

        <span class="cov0" title="0">var cache EmbeddingCache
        if err := json.Unmarshal(data, &amp;cache); err != nil </span><span class="cov0" title="0">{
                utils.Warning(fmt.Sprintf("[GIT.CLUSTER]: Failed to parse cache file: %v", err))
                return &amp;EmbeddingCache{
                        RootFolder:  rootFolder,
                        Embeddings:  make(map[string]FileCacheEntry),
                        LastUpdated: time.Now(),
                }
        }</span>

        <span class="cov0" title="0">return &amp;cache</span>
}

func getCachedEmbedding(filePath string, cache *EmbeddingCache) (*FileCacheEntry, bool) <span class="cov0" title="0">{
        entry, exists := cache.Embeddings[filePath]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check if file has been modified since caching
        <span class="cov0" title="0">currentHash := getFileContentHash(filePath)
        if currentHash != entry.ContentHash </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return &amp;entry, true</span>
}

func saveEmbeddingToCache(filePath string, embedding []float32, content string, cache *EmbeddingCache) <span class="cov0" title="0">{
        entry := FileCacheEntry{
                FilePath:    filePath,
                Embedding:   embedding,
                ContentHash: getFileContentHash(filePath),
                LastUpdated: time.Now(),
        }

        cache.Embeddings[filePath] = entry
        cache.LastUpdated = time.Now()
}</span>

// Helper functions for enhanced caching optimization
func calculateOptimalBatchSize(totalFiles int, hitRatio float64) int <span class="cov0" title="0">{
        baseSize := 5

        // Increase batch size if cache is performing well
        if hitRatio &gt; 0.8 </span><span class="cov0" title="0">{
                baseSize = 8
        }</span> else<span class="cov0" title="0"> if hitRatio &gt; 0.6 </span><span class="cov0" title="0">{
                baseSize = 7
        }</span> else<span class="cov0" title="0"> if hitRatio &lt; 0.3 </span><span class="cov0" title="0">{
                baseSize = 3
        }</span>

        // Scale based on total files
        <span class="cov0" title="0">if totalFiles &gt; 20 </span><span class="cov0" title="0">{
                baseSize = int(math.Min(float64(baseSize), float64(totalFiles)/4))
        }</span>

        <span class="cov0" title="0">return baseSize</span>
}

func getOptimalDiffSize(filePath string) int <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(filePath))

        // Different optimal sizes for different file types
        switch ext </span>{
        case ".go", ".py", ".js", ".ts":<span class="cov0" title="0">
                return 12000</span> // Larger for code files
        case ".md", ".txt", ".rst":<span class="cov0" title="0">
                return 8000</span> // Medium for documentation
        case ".json", ".yaml", ".yml", ".xml":<span class="cov0" title="0">
                return 6000</span> // Smaller for config files
        default:<span class="cov0" title="0">
                return 10000</span> // Default size
        }
}

func calculateAdaptiveDelay(recentMisses int) time.Duration <span class="cov0" title="0">{
        baseDelay := 1000 * time.Millisecond

        // Increase delay based on cache miss rate
        if recentMisses &gt; 15 </span><span class="cov0" title="0">{
                return baseDelay * 5 // 5 seconds for high miss rate
        }</span> else<span class="cov0" title="0"> if recentMisses &gt; 10 </span><span class="cov0" title="0">{
                return baseDelay * 3 // 3 seconds for medium miss rate
        }</span> else<span class="cov0" title="0"> if recentMisses &gt; 5 </span><span class="cov0" title="0">{
                return baseDelay * 2 // 2 seconds for low miss rate
        }</span>

        <span class="cov0" title="0">return baseDelay</span> // 1 second default
}

// Utility functions
func createSingleFileClusters(files []string) [][]string <span class="cov0" title="0">{
        clusters := make([][]string, len(files))
        for i, file := range files </span><span class="cov0" title="0">{
                clusters[i] = []string{file}
        }</span>
        <span class="cov0" title="0">return clusters</span>
}

func mergeClusters(clusters [][]string, targetCount int) [][]string <span class="cov0" title="0">{
        if len(clusters) &lt;= targetCount </span><span class="cov0" title="0">{
                return clusters
        }</span>

        // Merge smallest clusters first
        <span class="cov0" title="0">for len(clusters) &gt; targetCount </span><span class="cov0" title="0">{
                // Find two smallest clusters
                minSize1, minSize2 := math.MaxInt32, math.MaxInt32
                idx1, idx2 := -1, -1

                for i, cluster := range clusters </span><span class="cov0" title="0">{
                        size := len(cluster)
                        if size &lt; minSize1 </span><span class="cov0" title="0">{
                                minSize2 = minSize1
                                idx2 = idx1
                                minSize1 = size
                                idx1 = i
                        }</span> else<span class="cov0" title="0"> if size &lt; minSize2 </span><span class="cov0" title="0">{
                                minSize2 = size
                                idx2 = i
                        }</span>
                }

                <span class="cov0" title="0">if idx1 != -1 &amp;&amp; idx2 != -1 </span><span class="cov0" title="0">{
                        // Merge cluster at idx2 into cluster at idx1
                        clusters[idx1] = append(clusters[idx1], clusters[idx2]...)
                        // Remove cluster at idx2
                        clusters = append(clusters[:idx2], clusters[idx2+1:]...)
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        <span class="cov0" title="0">return clusters</span>
}

// AdvancedSimilarityConfig configures advanced similarity calculations
type AdvancedSimilarityConfig struct {
        SemanticWeight   float64 `json:"semanticWeight"`
        StructuralWeight float64 `json:"structuralWeight"`
        LexicalWeight    float64 `json:"lexicalWeight"`
        ThresholdValue   float32 `json:"thresholdValue"`
        UseNormalization bool    `json:"useNormalization"`
}

// DefaultSimilarityConfig returns optimized default configuration
func DefaultSimilarityConfig() AdvancedSimilarityConfig <span class="cov0" title="0">{
        return AdvancedSimilarityConfig{
                SemanticWeight:   0.6,
                StructuralWeight: 0.3,
                LexicalWeight:    0.1,
                ThresholdValue:   0.5,
                UseNormalization: true,
        }
}</span>

// Advanced similarity calculation methods
func advancedCosineSimilarity(vec1, vec2 []float32, normalize bool) float64 <span class="cov0" title="0">{
        if len(vec1) != len(vec2) </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Normalize vectors if requested
        <span class="cov0" title="0">if normalize </span><span class="cov0" title="0">{
                vec1 = normalizeVector(vec1)
                vec2 = normalizeVector(vec2)
        }</span>

        // Calculate dot product and magnitudes
        <span class="cov0" title="0">dotProduct := float64(0)
        magnitude1 := float64(0)
        magnitude2 := float64(0)

        for i := 0; i &lt; len(vec1); i++ </span><span class="cov0" title="0">{
                dotProduct += float64(vec1[i]) * float64(vec2[i])
                magnitude1 += float64(vec1[i]) * float64(vec1[i])
                magnitude2 += float64(vec2[i]) * float64(vec2[i])
        }</span>

        <span class="cov0" title="0">magnitude1 = math.Sqrt(magnitude1)
        magnitude2 = math.Sqrt(magnitude2)

        if magnitude1 == 0 || magnitude2 == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">similarity := dotProduct / (magnitude1 * magnitude2)
        return math.Max(0, math.Min(1, similarity))</span> // Clamp to [0, 1]
}

func jaccardSimilarity(vec1, vec2 []float32, threshold float32) float64 <span class="cov0" title="0">{
        if len(vec1) != len(vec2) </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Convert to binary features using adaptive threshold
        <span class="cov0" title="0">if threshold &lt;= 0 </span><span class="cov0" title="0">{
                threshold = calculateAdaptiveThreshold(vec1, vec2)
        }</span>

        <span class="cov0" title="0">intersection := 0
        union := 0

        for i := 0; i &lt; len(vec1); i++ </span><span class="cov0" title="0">{
                v1 := vec1[i] &gt;= threshold
                v2 := vec2[i] &gt;= threshold

                if v1 &amp;&amp; v2 </span><span class="cov0" title="0">{
                        intersection++
                }</span>
                <span class="cov0" title="0">if v1 || v2 </span><span class="cov0" title="0">{
                        union++
                }</span>
        }

        <span class="cov0" title="0">if union == 0 </span><span class="cov0" title="0">{
                return 1.0 // Both vectors are zero
        }</span>

        <span class="cov0" title="0">return float64(intersection) / float64(union)</span>
}

func manhattanSimilarity(vec1, vec2 []float32) float64 <span class="cov0" title="0">{
        if len(vec1) != len(vec2) </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">distance := float64(0)
        for i := 0; i &lt; len(vec1); i++ </span><span class="cov0" title="0">{
                distance += math.Abs(float64(vec1[i]) - float64(vec2[i]))
        }</span>

        // Convert distance to similarity using exponential decay
        <span class="cov0" title="0">maxDistance := float64(len(vec1)) * 2.0 // Rough max distance estimate
        similarity := math.Exp(-distance / maxDistance)

        return similarity</span>
}

func hybridSimilarity(vec1, vec2 []float32, config AdvancedSimilarityConfig) float64 <span class="cov0" title="0">{
        // Calculate multiple similarity measures
        cosine := advancedCosineSimilarity(vec1, vec2, true)
        jaccard := jaccardSimilarity(vec1, vec2, 0)
        manhattan := manhattanSimilarity(vec1, vec2)

        // Ensemble voting with confidence weighting
        similarities := []float64{cosine, jaccard, manhattan}
        weights := []float64{0.5, 0.3, 0.2} // Default weights

        // Calculate confidence for each method
        confidences := []float64{
                calculateSimilarityConfidence(cosine),
                calculateSimilarityConfidence(jaccard),
                calculateSimilarityConfidence(manhattan),
        }

        // Weighted average with confidence adjustment
        weightedSum := 0.0
        totalWeight := 0.0

        for i, sim := range similarities </span><span class="cov0" title="0">{
                adjustedWeight := weights[i] * confidences[i]
                weightedSum += sim * adjustedWeight
                totalWeight += adjustedWeight
        }</span>

        <span class="cov0" title="0">if totalWeight == 0 </span><span class="cov0" title="0">{
                return cosine // Fallback to cosine
        }</span>

        <span class="cov0" title="0">return weightedSum / totalWeight</span>
}

func calculateWeightedSemanticSimilarity(vec1, vec2 []float32, config AdvancedSimilarityConfig) float64 <span class="cov0" title="0">{
        // Combine semantic similarity with structural similarity
        semanticSim := advancedCosineSimilarity(vec1, vec2, true)
        structuralSim := jaccardSimilarity(vec1, vec2, 0)
        lexicalSim := manhattanSimilarity(vec1, vec2)

        // Apply configured weights
        totalWeight := config.SemanticWeight + config.StructuralWeight + config.LexicalWeight
        if totalWeight == 0 </span><span class="cov0" title="0">{
                totalWeight = 1.0
        }</span>

        <span class="cov0" title="0">weighted := (semanticSim*config.SemanticWeight +
                structuralSim*config.StructuralWeight +
                lexicalSim*config.LexicalWeight) / totalWeight

        return weighted</span>
}

// Helper functions for advanced similarity calculations
func normalizeVector(vec []float32) []float32 <span class="cov0" title="0">{
        normalized := make([]float32, len(vec))
        magnitude := float32(0)

        for _, v := range vec </span><span class="cov0" title="0">{
                magnitude += v * v
        }</span>
        <span class="cov0" title="0">magnitude = float32(math.Sqrt(float64(magnitude)))

        if magnitude == 0 </span><span class="cov0" title="0">{
                return normalized
        }</span>

        <span class="cov0" title="0">for i, v := range vec </span><span class="cov0" title="0">{
                normalized[i] = v / magnitude
        }</span>

        <span class="cov0" title="0">return normalized</span>
}

func calculateAdaptiveThreshold(vec1, vec2 []float32) float32 <span class="cov0" title="0">{
        // Calculate threshold as mean of both vectors
        sum := float32(0)
        count := 0

        for i := 0; i &lt; len(vec1); i++ </span><span class="cov0" title="0">{
                sum += vec1[i] + vec2[i]
                count += 2
        }</span>

        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return 0.5
        }</span>

        <span class="cov0" title="0">return sum / float32(count)</span>
}

func calculateSimilarityConfidence(similarity float64) float64 <span class="cov0" title="0">{
        // Higher confidence for extreme values (close to 0 or 1)
        return 1.0 - 4.0*similarity*(1.0-similarity)
}</span>

func cosineSimilarity(vec1, vec2 []float32) float64 <span class="cov0" title="0">{
        return advancedCosineSimilarity(vec1, vec2, false)
}</span>

// Helper functions for confidence calculations
func calculateDirectoryGroupingConfidence(files []string, clusters [][]string, rootFolder string) float64 <span class="cov0" title="0">{
        if len(clusters) == 0 || len(files) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Calculate how well files are grouped by directory structure
        <span class="cov0" title="0">totalScore := 0.0
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                if len(cluster) &lt;= 1 </span><span class="cov0" title="0">{
                        totalScore += 1.0 // Single file clusters are always perfect
                        continue</span>
                }

                // Calculate directory coherence within cluster
                <span class="cov0" title="0">dirSimilarity := calculateDirectorySimilarity(cluster, rootFolder)
                totalScore += dirSimilarity</span>
        }

        <span class="cov0" title="0">return totalScore / float64(len(clusters))</span>
}

func calculatePatternConfidence(files []string, clusters [][]string) float64 <span class="cov0" title="0">{
        if len(clusters) == 0 || len(files) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">totalScore := 0.0
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                if len(cluster) &lt;= 1 </span><span class="cov0" title="0">{
                        totalScore += 1.0
                        continue</span>
                }

                // Calculate extension similarity within cluster
                <span class="cov0" title="0">extSimilarity := calculateExtensionSimilarity(cluster)

                // Calculate test-impl relationship bonus
                testImplRelations := findTestImplementationRelations(cluster)
                relationBonus := float64(len(testImplRelations)) / float64(len(cluster))

                clusterScore := (extSimilarity + relationBonus) / 2.0
                totalScore += clusterScore</span>
        }

        <span class="cov0" title="0">return totalScore / float64(len(clusters))</span>
}

func calculateEmbeddingClusterConfidence(clusters [][]string, fileEmbeddings map[string][]float32) float64 <span class="cov0" title="0">{
        if len(clusters) == 0 || len(fileEmbeddings) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov0" title="0">totalScore := 0.0
        validClusters := 0
        config := DefaultSimilarityConfig()

        for _, cluster := range clusters </span><span class="cov0" title="0">{
                if len(cluster) &lt;= 1 </span><span class="cov0" title="0">{
                        totalScore += 1.0
                        validClusters++
                        continue</span>
                }

                // Calculate average pairwise similarity within cluster using enhanced methods
                <span class="cov0" title="0">clusterEmbeddings := make([][]float32, 0)
                for _, file := range cluster </span><span class="cov0" title="0">{
                        if embedding, exists := fileEmbeddings[file]; exists </span><span class="cov0" title="0">{
                                clusterEmbeddings = append(clusterEmbeddings, embedding)
                        }</span>
                }

                <span class="cov0" title="0">if len(clusterEmbeddings) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">avgSimilarity := 0.0
                pairs := 0
                for i := 0; i &lt; len(clusterEmbeddings); i++ </span><span class="cov0" title="0">{
                        for j := i + 1; j &lt; len(clusterEmbeddings); j++ </span><span class="cov0" title="0">{
                                // Use weighted semantic similarity for better cluster quality assessment
                                similarity := calculateWeightedSemanticSimilarity(clusterEmbeddings[i], clusterEmbeddings[j], config)
                                avgSimilarity += similarity
                                pairs++
                        }</span>
                }

                <span class="cov0" title="0">if pairs &gt; 0 </span><span class="cov0" title="0">{
                        avgSimilarity /= float64(pairs)
                        totalScore += avgSimilarity
                        validClusters++
                }</span>
        }

        <span class="cov0" title="0">if validClusters &gt; 0 </span><span class="cov0" title="0">{
                return totalScore / float64(validClusters)
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

func selectRepresentativeFiles(files []string, sampleSize int) []string <span class="cov0" title="0">{
        if len(files) &lt;= sampleSize </span><span class="cov0" title="0">{
                return files
        }</span>

        // Group files by extension and directory to ensure diverse sampling
        <span class="cov0" title="0">extGroups := make(map[string][]string)
        dirGroups := make(map[string][]string)

        for _, file := range files </span><span class="cov0" title="0">{
                ext := strings.ToLower(filepath.Ext(file))
                if ext == "" </span><span class="cov0" title="0">{
                        ext = "no-ext"
                }</span>
                <span class="cov0" title="0">extGroups[ext] = append(extGroups[ext], file)

                dir := filepath.Dir(file)
                dirGroups[dir] = append(dirGroups[dir], file)</span>
        }

        <span class="cov0" title="0">representatives := make([]string, 0, sampleSize)
        used := make(map[string]bool)

        // First, pick one representative from each extension group
        for _, group := range extGroups </span><span class="cov0" title="0">{
                if len(representatives) &gt;= sampleSize </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if len(group) &gt; 0 &amp;&amp; !used[group[0]] </span><span class="cov0" title="0">{
                        representatives = append(representatives, group[0])
                        used[group[0]] = true
                }</span>
        }

        // Fill remaining slots from directory groups
        <span class="cov0" title="0">for _, group := range dirGroups </span><span class="cov0" title="0">{
                if len(representatives) &gt;= sampleSize </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">for _, file := range group </span><span class="cov0" title="0">{
                        if len(representatives) &gt;= sampleSize </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if !used[file] </span><span class="cov0" title="0">{
                                representatives = append(representatives, file)
                                used[file] = true
                        }</span>
                }
        }

        // Fill any remaining slots randomly
        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if len(representatives) &gt;= sampleSize </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if !used[file] </span><span class="cov0" title="0">{
                        representatives = append(representatives, file)
                        used[file] = true
                }</span>
        }

        <span class="cov0" title="0">return representatives</span>
}

func fallbackToPatterClustering(files []string, targetClusters int) [][]string <span class="cov0" title="0">{
        clusters, _ := patternBasedClustering(files, targetClusters)
        return clusters
}</span>

func assignFilesToClusters(files []string, reprClusters [][]string, rootFolder string) [][]string <span class="cov0" title="0">{
        if len(reprClusters) == 0 </span><span class="cov0" title="0">{
                return createSingleFileClusters(files)
        }</span>

        // Create map of representative files to their cluster index
        <span class="cov0" title="0">reprToCluster := make(map[string]int)
        for clusterIdx, cluster := range reprClusters </span><span class="cov0" title="0">{
                for _, file := range cluster </span><span class="cov0" title="0">{
                        reprToCluster[file] = clusterIdx
                }</span>
        }

        // Initialize final clusters
        <span class="cov0" title="0">finalClusters := make([][]string, len(reprClusters))
        for i, cluster := range reprClusters </span><span class="cov0" title="0">{
                finalClusters[i] = make([]string, len(cluster))
                copy(finalClusters[i], cluster)
        }</span>

        // Assign non-representative files to closest cluster
        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                if _, isRepr := reprToCluster[file]; isRepr </span><span class="cov0" title="0">{
                        continue</span> // Already assigned
                }

                // Find best cluster based on directory and extension similarity
                <span class="cov0" title="0">bestCluster := 0
                bestScore := -1.0

                for i, cluster := range finalClusters </span><span class="cov0" title="0">{
                        if len(cluster) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Calculate similarity to cluster centroid (using first file as proxy)
                        <span class="cov0" title="0">dirSim := calculateDirectorySimilarity([]string{file, cluster[0]}, rootFolder)
                        extSim := calculateExtensionSimilarity([]string{file, cluster[0]})
                        score := (dirSim + extSim) / 2.0

                        if score &gt; bestScore </span><span class="cov0" title="0">{
                                bestScore = score
                                bestCluster = i
                        }</span>
                }

                <span class="cov0" title="0">finalClusters[bestCluster] = append(finalClusters[bestCluster], file)</span>
        }

        <span class="cov0" title="0">return finalClusters</span>
}

func filterClustersByThreshold(clusters [][]string, rootFolder string, threshold float64) [][]string <span class="cov0" title="0">{
        filtered := make([][]string, 0)

        for _, cluster := range clusters </span><span class="cov0" title="0">{
                if len(cluster) &lt;= 1 </span><span class="cov0" title="0">{
                        filtered = append(filtered, cluster)
                        continue</span>
                }

                // Check if cluster meets similarity threshold
                <span class="cov0" title="0">similarity := calculateClusterSimilarity(cluster, rootFolder)
                if similarity &gt;= threshold </span><span class="cov0" title="0">{
                        filtered = append(filtered, cluster)
                }</span> else<span class="cov0" title="0"> {
                        // Split cluster into individual files if it doesn't meet threshold
                        for _, file := range cluster </span><span class="cov0" title="0">{
                                filtered = append(filtered, []string{file})
                        }</span>
                }
        }

        <span class="cov0" title="0">return filtered</span>
}

// Performance benchmarking and metrics collection for clustering optimization
type ClusteringBenchmark struct {
        TestName         string           `json:"testName"`
        FileCount        int              `json:"fileCount"`
        TargetClusters   int              `json:"targetClusters"`
        ActualClusters   int              `json:"actualClusters"`
        Method           string           `json:"method"`
        SimilarityMethod SimilarityMethod `json:"similarityMethod"`
        ExecutionTime    time.Duration    `json:"executionTime"`
        CacheHitRatio    float64          `json:"cacheHitRatio"`
        ConfidenceScore  float64          `json:"confidenceScore"`
        SilhouetteScore  float64          `json:"silhouetteScore"`
        MemoryUsage      int64            `json:"memoryUsage"`
        ApiCalls         int              `json:"apiCalls"`
        Timestamp        time.Time        `json:"timestamp"`
}

// BenchmarkResult aggregates multiple benchmark runs
type BenchmarkResult struct {
        Benchmarks    []ClusteringBenchmark `json:"benchmarks"`
        AverageTime   time.Duration         `json:"averageTime"`
        AverageConf   float64               `json:"averageConfidence"`
        TotalApiCalls int                   `json:"totalApiCalls"`
        BestMethod    string                `json:"bestMethod"`
        Summary       string                `json:"summary"`
}

// Global benchmark collector
var clusteringBenchmarksEnabled = false
var collectedBenchmarks []ClusteringBenchmark

// EnableBenchmarking enables collection of clustering performance metrics
func EnableBenchmarking() <span class="cov0" title="0">{
        clusteringBenchmarksEnabled = true
        collectedBenchmarks = []ClusteringBenchmark{}
        utils.Debug("[BENCHMARK]: Clustering performance benchmarking enabled")
}</span>

// DisableBenchmarking disables benchmark collection
func DisableBenchmarking() <span class="cov0" title="0">{
        clusteringBenchmarksEnabled = false
        utils.Debug("[BENCHMARK]: Clustering performance benchmarking disabled")
}</span>

// recordBenchmark records a clustering benchmark if enabled
func recordBenchmark(benchmark ClusteringBenchmark) <span class="cov0" title="0">{
        if !clusteringBenchmarksEnabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">benchmark.Timestamp = time.Now()
        collectedBenchmarks = append(collectedBenchmarks, benchmark)

        utils.Debug(fmt.Sprintf("[BENCHMARK]: Recorded %s - %d files -&gt; %d clusters in %v",
                benchmark.TestName, benchmark.FileCount, benchmark.ActualClusters, benchmark.ExecutionTime))</span>
}

// GetBenchmarkResults returns all collected benchmarks with analysis
func GetBenchmarkResults() BenchmarkResult <span class="cov0" title="0">{
        if len(collectedBenchmarks) == 0 </span><span class="cov0" title="0">{
                return BenchmarkResult{
                        Summary: "No benchmarks collected",
                }
        }</span>

        <span class="cov0" title="0">totalTime := time.Duration(0)
        totalConf := 0.0
        totalApiCalls := 0
        methodCounts := make(map[string]int)
        methodPerformance := make(map[string]float64)

        for _, benchmark := range collectedBenchmarks </span><span class="cov0" title="0">{
                totalTime += benchmark.ExecutionTime
                totalConf += benchmark.ConfidenceScore
                totalApiCalls += benchmark.ApiCalls

                methodCounts[benchmark.Method]++
                methodPerformance[benchmark.Method] += benchmark.ConfidenceScore
        }</span>

        <span class="cov0" title="0">avgTime := totalTime / time.Duration(len(collectedBenchmarks))
        avgConf := totalConf / float64(len(collectedBenchmarks))

        // Find best performing method
        bestMethod := ""
        bestScore := 0.0
        for method, totalScore := range methodPerformance </span><span class="cov0" title="0">{
                avgScore := totalScore / float64(methodCounts[method])
                if avgScore &gt; bestScore </span><span class="cov0" title="0">{
                        bestScore = avgScore
                        bestMethod = method
                }</span>
        }

        <span class="cov0" title="0">summary := fmt.Sprintf("Analyzed %d benchmarks. Best method: %s (%.3f avg confidence). Avg time: %v",
                len(collectedBenchmarks), bestMethod, bestScore, avgTime)

        return BenchmarkResult{
                Benchmarks:    collectedBenchmarks,
                AverageTime:   avgTime,
                AverageConf:   avgConf,
                TotalApiCalls: totalApiCalls,
                BestMethod:    bestMethod,
                Summary:       summary,
        }</span>
}

// ResetBenchmarks clears all collected benchmarks
func ResetBenchmarks() <span class="cov0" title="0">{
        collectedBenchmarks = []ClusteringBenchmark{}
        utils.Debug("[BENCHMARK]: Cleared all benchmark data")
}</span>

// saveBenchmarkResults saves benchmark results to disk
func saveBenchmarkResults(results BenchmarkResult, filepath string) error <span class="cov0" title="0">{
        data, err := json.MarshalIndent(results, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(filepath, data, 0644)</span>
}

// RunClusteringPerformanceTest runs comprehensive performance tests
func RunClusteringPerformanceTest(files []string, rootFolder string) BenchmarkResult <span class="cov0" title="0">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return BenchmarkResult{Summary: "No files provided for testing"}
        }</span>

        <span class="cov0" title="0">EnableBenchmarking()
        defer DisableBenchmarking()

        utils.Debug(fmt.Sprintf("[BENCHMARK]: Starting performance test with %d files", len(files)))

        // Test different clustering methods
        testConfigurations := []struct {
                name           string
                targetClusters int
                method         string
        }{
                {"threshold-clustering", 0, "threshold"},
                {"small-clusters", 3, "target"},
                {"medium-clusters", 5, "target"},
                {"large-clusters", 8, "target"},
        }

        for _, config := range testConfigurations </span><span class="cov0" title="0">{
                startTime := time.Now()

                clusters, err := SmartClusterFiles(files, rootFolder, config.targetClusters)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Warning(fmt.Sprintf("[BENCHMARK]: Test %s failed: %v", config.name, err))
                        continue</span>
                }

                <span class="cov0" title="0">executionTime := time.Since(startTime)

                benchmark := ClusteringBenchmark{
                        TestName:        config.name,
                        FileCount:       len(files),
                        TargetClusters:  config.targetClusters,
                        ActualClusters:  len(clusters),
                        Method:          config.method,
                        ExecutionTime:   executionTime,
                        ConfidenceScore: calculateOverallClusteringConfidence(clusters, files, rootFolder),
                }

                recordBenchmark(benchmark)</span>
        }

        <span class="cov0" title="0">return GetBenchmarkResults()</span>
}

// calculateOverallClusteringConfidence calculates overall confidence for cluster quality
func calculateOverallClusteringConfidence(clusters [][]string, allFiles []string, rootFolder string) float64 <span class="cov0" title="0">{
        if len(clusters) == 0 || len(allFiles) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        // Calculate multiple confidence metrics
        <span class="cov0" title="0">dirConfidence := calculateDirectoryGroupingConfidence(allFiles, clusters, rootFolder)
        patternConfidence := calculatePatternConfidence(allFiles, clusters)

        // Size distribution confidence (prefer balanced cluster sizes)
        sizeVariance := calculateClusterSizeVariance(clusters)
        sizeConfidence := math.Max(0, 1.0-sizeVariance)

        // Coverage confidence (all files should be clustered)
        totalClustered := 0
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                totalClustered += len(cluster)
        }</span>
        <span class="cov0" title="0">coverageConfidence := float64(totalClustered) / float64(len(allFiles))

        // Weighted average of all confidence measures
        weights := []float64{0.3, 0.3, 0.2, 0.2}
        scores := []float64{dirConfidence, patternConfidence, sizeConfidence, coverageConfidence}

        weightedSum := 0.0
        for i, score := range scores </span><span class="cov0" title="0">{
                weightedSum += score * weights[i]
        }</span>

        <span class="cov0" title="0">return weightedSum</span>
}

// calculateClusterSizeVariance calculates variance in cluster sizes
func calculateClusterSizeVariance(clusters [][]string) float64 <span class="cov0" title="0">{
        if len(clusters) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Calculate mean cluster size
        <span class="cov0" title="0">totalFiles := 0
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                totalFiles += len(cluster)
        }</span>
        <span class="cov0" title="0">mean := float64(totalFiles) / float64(len(clusters))

        // Calculate variance
        variance := 0.0
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                diff := float64(len(cluster)) - mean
                variance += diff * diff
        }</span>
        <span class="cov0" title="0">variance /= float64(len(clusters))

        // Normalize variance by mean to get coefficient of variation
        if mean &gt; 0 </span><span class="cov0" title="0">{
                return math.Sqrt(variance) / mean
        }</span>
        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package git

import (
        "GitCury/interfaces"
        "GitCury/output"
        "time"
)

// DefaultGitRunner implements the GitRunner interface with real Git operations
type DefaultGitRunner struct{}

// Ensure DefaultGitRunner implements GitRunner interface
var _ interfaces.GitRunner = (*DefaultGitRunner)(nil)

// RunGitCmd executes a Git command in the specified directory
func (d *DefaultGitRunner) RunGitCmd(dir string, envVars map[string]string, args ...string) (string, error) <span class="cov0" title="0">{
        return RunGitCmd(dir, envVars, args...)
}</span>

// RunGitCmdWithTimeout executes a Git command with a timeout
func (d *DefaultGitRunner) RunGitCmdWithTimeout(dir string, envVars map[string]string, timeout time.Duration, args ...string) (string, error) <span class="cov0" title="0">{
        return RunGitCmdWithTimeout(dir, envVars, timeout, args...)
}</span>

// CommitBatch commits a batch of files for a folder
func (d *DefaultGitRunner) CommitBatch(folder interfaces.Folder, env ...[]string) error <span class="cov0" title="0">{
        outputFolder := interfaceToOutput(folder)
        return CommitBatch(outputFolder, env...)
}</span>

// GetChangedFiles gets changed files from the specified root folders
func (d *DefaultGitRunner) GetChangedFiles(rootFolders []string, maxConcurrency int, env ...[]string) ([]interfaces.Folder, error) <span class="cov0" title="0">{
        folders, err := GetChangedFiles(rootFolders, maxConcurrency, env...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return outputFoldersToInterface(folders), nil</span>
}

// Status gets the status of the specified root paths
func (d *DefaultGitRunner) Status(rootPaths []string) ([]interfaces.Folder, error) <span class="cov0" title="0">{
        folders, err := Status(rootPaths)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return outputFoldersToInterface(folders), nil</span>
}

// ProcessOneFile processes a single file with the given commit message
func (d *DefaultGitRunner) ProcessOneFile(filePath, commitMessage string, env ...[]string) error <span class="cov0" title="0">{
        return ProcessOneFile(filePath, commitMessage, env...)
}</span>

// GetDiff gets the diff for a specific file
func (d *DefaultGitRunner) GetDiff(filePath string, env ...[]string) (string, error) <span class="cov0" title="0">{
        // For now, use empty rootFolder since GetFileDiff doesn't support env vars yet
        return GetFileDiff(filePath, "")
}</span>

// IsGitRepository checks if the given path is a Git repository
func (d *DefaultGitRunner) IsGitRepository(path string) bool <span class="cov0" title="0">{
        return IsGitRepository(path)
}</span>

// GetGitConfigValue gets a Git configuration value
func (d *DefaultGitRunner) GetGitConfigValue(key string, env ...[]string) (string, error) <span class="cov0" title="0">{
        return GetGitConfigValue(key, env...)
}</span>

// SetGitConfigValue sets a Git configuration value
func (d *DefaultGitRunner) SetGitConfigValue(key, value string, env ...[]string) error <span class="cov0" title="0">{
        return SetGitConfigValue(key, value, env...)
}</span>

// ProgressCommitBatch is an enhanced version with progress reporting
func (d *DefaultGitRunner) ProgressCommitBatch(folder interfaces.Folder, env ...[]string) error <span class="cov0" title="0">{
        outputFolder := interfaceToOutput(folder)
        return ProgressCommitBatch(outputFolder, env...)
}</span>

// ProgressPushBranch is an enhanced version with progress reporting
func (d *DefaultGitRunner) ProgressPushBranch(rootFolderName string, branch string) error <span class="cov0" title="0">{
        return ProgressPushBranch(rootFolderName, branch)
}</span>

// GetAllChangedFiles gets all changed files for a directory
func (d *DefaultGitRunner) GetAllChangedFiles(dir string) ([]string, error) <span class="cov0" title="0">{
        return GetAllChangedFiles(dir)
}</span>

// BatchProcessGetMessages processes multiple files and generates commit messages
func (d *DefaultGitRunner) BatchProcessGetMessages(allChangedFiles []string, rootFolder string) error <span class="cov0" title="0">{
        return BatchProcessGetMessages(allChangedFiles, rootFolder)
}</span>

// BatchProcessWithEmbeddings processes files using embeddings and clustering
func (d *DefaultGitRunner) BatchProcessWithEmbeddings(allChangedFiles []string, rootFolder string, numClusters int) error <span class="cov0" title="0">{
        return BatchProcessWithEmbeddings(allChangedFiles, rootFolder, numClusters)
}</span>

// Conversion functions between output and interface types
func outputToInterface(folder output.Folder) interfaces.Folder <span class="cov0" title="0">{
        var files []interfaces.FileEntry
        for _, file := range folder.Files </span><span class="cov0" title="0">{
                files = append(files, interfaces.FileEntry{
                        Name:    file.Name,
                        Message: file.Message,
                })
        }</span>
        <span class="cov0" title="0">return interfaces.Folder{
                Name:  folder.Name,
                Files: files,
        }</span>
}

func interfaceToOutput(folder interfaces.Folder) output.Folder <span class="cov0" title="0">{
        var files []output.FileEntry
        for _, file := range folder.Files </span><span class="cov0" title="0">{
                files = append(files, output.FileEntry{
                        Name:    file.Name,
                        Message: file.Message,
                })
        }</span>
        <span class="cov0" title="0">return output.Folder{
                Name:  folder.Name,
                Files: files,
        }</span>
}

func outputFoldersToInterface(folders []output.Folder) []interfaces.Folder <span class="cov0" title="0">{
        var result []interfaces.Folder
        for _, folder := range folders </span><span class="cov0" title="0">{
                result = append(result, outputToInterface(folder))
        }</span>
        <span class="cov0" title="0">return result</span>
}</pre>
		
		<pre class="file" id="file20" style="display: none">package git

import (
        "GitCury/config"
        "GitCury/di"
        "GitCury/output"
        "GitCury/utils"
        "GitCury/embeddings"
        "bytes"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "time"
)

type FileEmbedding struct {
        Path      string
        Diff      string
        Embedding []float32
}

func RunGitCmd(dir string, envVars map[string]string, args ...string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("git", args...)
        cmd.Dir = dir

        // Append custom environment variables to the existing environment
        if envVars != nil </span><span class="cov0" title="0">{
                env := cmd.Env
                for key, value := range envVars </span><span class="cov0" title="0">{
                        env = append(env, fmt.Sprintf("%s=%s", key, value))
                }</span>
                <span class="cov0" title="0">cmd.Env = env</span>
        }

        <span class="cov0" title="0">var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                utils.Error(fmt.Sprintf(
                        "[GIT.EXEC.FAIL]: Command failed: %s\nStdout: %s\nStderr: %s\n",
                        err,
                        stdout.String(),
                        stderr.String(),
                ))
                return "", err
        }</span>

        <span class="cov0" title="0">utils.Debug("[GIT.EXEC.SUCCESS]: Command executed successfully in directory '" + dir + "': git " + strings.Join(args, " "))
        return stdout.String(), nil</span>
}

var changedFilesCache = make(map[string]string)
var cacheMu sync.RWMutex

func GetAllChangedFiles(dir string) ([]string, error) <span class="cov0" title="0">{
        output, err := RunGitCmd(dir, nil, "status", "--porcelain")
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[GIT.STATUS.FAIL]: Failed to get git status: " + err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(output) == "" </span><span class="cov0" title="0">{
                utils.Debug("[GIT.STATUS]: No changed files detected in directory: " + dir)
                return nil, nil
        }</span>

        <span class="cov0" title="0">var changedFiles []string
        lines := strings.Split(output, "\n")

        cacheMu.Lock()
        defer cacheMu.Unlock()

        for _, line := range lines </span><span class="cov0" title="0">{
                if len(line) &lt; 4 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">status := strings.TrimSpace(line[:2])
                relativePath := strings.TrimSpace(line[3:])
                absolutePath := filepath.Join(dir, relativePath)
                abs, err := filepath.Abs(absolutePath)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("[GIT.PATH.FAIL]: Failed to resolve absolute path for '" + relativePath + "': " + err.Error())
                        continue</span>
                }

                <span class="cov0" title="0">changedFilesCache[abs] = status

                if strings.HasPrefix(status, "D") </span><span class="cov0" title="0">{
                        utils.Debug("[GIT.FILE.DELETED]: File marked as deleted: " + abs)
                        changedFiles = append(changedFiles, abs)
                        continue</span>
                }

                <span class="cov0" title="0">info, err := os.Stat(abs)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                utils.Debug("[GIT.FILE.MISSING]: File does not exist (possibly deleted): " + abs)
                                changedFiles = append(changedFiles, abs)
                                continue</span>
                        }
                        <span class="cov0" title="0">utils.Error("[GIT.STAT.FAIL]: Failed to stat path '" + abs + "': " + err.Error())
                        return nil, err</span>
                }

                <span class="cov0" title="0">if info.IsDir() &amp;&amp; status == "??" </span><span class="cov0" title="0">{
                        innerOutput, err := RunGitCmd(dir, nil, "ls-files", "--others", "--exclude-standard", relativePath)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[GIT.UNTRACKED.FAIL]: Failed to list files in untracked dir '" + relativePath + "': " + err.Error())
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">for _, inner := range strings.Split(innerOutput, "\n") </span><span class="cov0" title="0">{
                                if strings.TrimSpace(inner) == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">fullPath := filepath.Join(dir, inner)
                                absInner, err := filepath.Abs(fullPath)
                                if err == nil </span><span class="cov0" title="0">{
                                        changedFiles = append(changedFiles, absInner)
                                        changedFilesCache[absInner] = "??"
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        changedFiles = append(changedFiles, abs)
                }</span>
        }

        <span class="cov0" title="0">utils.Debug("[GIT.CHANGED.FILES]: " + strings.Join(changedFiles, ", "))
        return changedFiles, nil</span>
}

func GenCommitMessage(files []string, dir string) (string, error) <span class="cov0" title="0">{
        contextData := make(map[string]map[string]string)
        
        apiKey := config.Get("GEMINI_API_KEY")                                                                                                                                                                                                                                                                                                                                                                
        if apiKey == "" </span><span class="cov0" title="0">{
                apiKey = os.Getenv("GEMINI_API_KEY")
                if apiKey == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("Gemini API key not found in config or env")
                }</span>
        }

        <span class="cov0" title="0">for _, file := range files </span><span class="cov0" title="0">{
                var fileType, diffOutput string

                cacheMu.RLock()
                status, cached := changedFilesCache[file]
                cacheMu.RUnlock()

                if cached &amp;&amp; strings.HasPrefix(status, "D") </span><span class="cov0" title="0">{
                        fileType = "deleted"
                        contextData[file] = map[string]string{
                                "type": fileType,
                                "diff": "file deleted",                                                                                                                                 
                        }
                        utils.Debug("[GIT.COMMIT.MSG]: File marked as deleted: '" + file + "'")
                        continue</span>
                }

                <span class="cov0" title="0">diffOutput, err := RunGitCmd(dir, nil, "diff", "--", file)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error(fmt.Sprintf("[GIT.DIFF.FAIL]: Error running git diff for '%s': %s", file, err.Error()))
                        return "", err
                }</span>

                <span class="cov0" title="0">if strings.TrimSpace(diffOutput) == "" </span><span class="cov0" title="0">{
                        diffOutput, err = RunGitCmd(dir, nil, "diff", "--cached", "--", file)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error(fmt.Sprintf("[GIT.DIFF.FAIL]: Error running git diff --cached for '%s': %s", file, err.Error()))
                                return "", err
                        }</span>
                }

                <span class="cov0" title="0">if strings.TrimSpace(diffOutput) == "" </span><span class="cov0" title="0">{
                        contentBytes, err := os.ReadFile(file)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error(fmt.Sprintf("[GIT.FILE.READ.FAIL]: Error reading new file '%s': %s", file, err.Error()))
                                return "", err
                        }</span>
                        <span class="cov0" title="0">diffOutput = string(contentBytes)
                        fileType = "new"</span>
                } else<span class="cov0" title="0"> {
                        fileType = "updated"
                }</span>

                <span class="cov0" title="0">contextData[file] = map[string]string{
                        "type": fileType,
                        "diff": diffOutput,
                }

                utils.Debug("[GIT.COMMIT.MSG]: Processed file '" + file + "' as " + fileType)</span>
        }

        <span class="cov0" title="0">message, err := di.GetGeminiRunner().SendToGemini(contextData, apiKey.(string))
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[GEMINI.FAIL]: Error generating group commit message: " + err.Error())
                return "", err
        }</span>

        <span class="cov0" title="0">return message, nil</span>
}

func BatchProcessGetMessages(allChangedFiles []string, rootFolder string) error <span class="cov0" title="0">{
        utils.Debug("[GIT.BATCH]: Starting batch processing of commit messages")
        var fileWg sync.WaitGroup
        var fileErrors []error
        fileMu := sync.Mutex{}

        for _, file := range allChangedFiles </span><span class="cov0" title="0">{
                fileWg.Add(1)
                go func(file string) </span><span class="cov0" title="0">{
                        defer fileWg.Done()

                        utils.Debug("[GIT.BATCH]: Processing file: " + file)
                        message, err := GenCommitMessage([]string{file}, rootFolder) // &lt;-- wrapped in slice
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error("[GIT.BATCH.FAIL]: Failed to generate commit message for file: " + file + " - " + err.Error())
                                fileMu.Lock()
                                fileErrors = append(fileErrors, err)
                                fileMu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">utils.Debug("[GIT.BATCH.SUCCESS]: Generated commit message for file: " + file + " - " + message)
                        output.Set(file, rootFolder, message)</span>
                }(file)
        }

        <span class="cov0" title="0">fileWg.Wait()

        if len(fileErrors) &gt; 0 </span><span class="cov0" title="0">{
                utils.Error("[GIT.BATCH.FAIL]: Batch processing completed with errors")
                return fmt.Errorf("one or more errors occurred while preparing commit messages")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func CommitBatch(rootFolder output.Folder, env ...[]string) error <span class="cov0" title="0">{
        commitMessagesList := rootFolder.Files
        if len(commitMessagesList) == 0 </span><span class="cov0" title="0">{
                utils.Debug("[GIT.COMMIT]: No commit messages found for root folder: " + rootFolder.Name)
                return fmt.Errorf("no commit messages found for root folder: %s", rootFolder.Name)
        }</span>

        <span class="cov0" title="0">utils.Debug("[GIT.COMMIT]: Starting batch commit in folder: " + rootFolder.Name)
        utils.Debug("[GIT.COMMIT]: Total files to commit: " + fmt.Sprint(len(commitMessagesList)))

        envMap := make(map[string]string)
        if len(env) &gt; 0 </span><span class="cov0" title="0">{
                for _, pair := range env[0] </span><span class="cov0" title="0">{
                        parts := strings.SplitN(pair, "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                envMap[parts[0]] = parts[1]
                        }</span>
                }
        }

        <span class="cov0" title="0">messageToFiles := make(map[string][]string)
        for _, entry := range commitMessagesList </span><span class="cov0" title="0">{
                utils.Debug("[GIT.COMMIT]: Staging file for grouping: " + entry.Name + " with message: " + entry.Message)
                messageToFiles[entry.Message] = append(messageToFiles[entry.Message], entry.Name)
        }</span>

        <span class="cov0" title="0">for message, files := range messageToFiles </span><span class="cov0" title="0">{
                for _, file := range files </span><span class="cov0" title="0">{
                        utils.Debug("[GIT.COMMIT]: Adding file to commit: " + file)
                        if _, err := RunGitCmd(rootFolder.Name, envMap, "add", file); err != nil </span><span class="cov0" title="0">{
                                utils.Error("[GIT.COMMIT.FAIL]: Failed to add file to commit: " + err.Error())
                                return fmt.Errorf("failed to add file to commit: %s", err.Error())
                        }</span>
                }

                <span class="cov0" title="0">utils.Debug(fmt.Sprintf("[GIT.COMMIT]: Committing %d file(s) with message: %s", len(files), message))
                if _, err := RunGitCmd(rootFolder.Name, envMap, "commit", "-m", message); err != nil </span><span class="cov0" title="0">{
                        utils.Error("[GIT.COMMIT.FAIL]: Failed to commit files with message '"+message+"': " + err.Error())
                        return fmt.Errorf("failed to commit files: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">output.RemoveFolder(rootFolder.Name)
        utils.Info("[GIT.COMMIT.SUCCESS]: Batch commit completed successfully and folder removed: " + rootFolder.Name)
        return nil</span>
}

func PushBranch(rootFolderName string, branch string) error <span class="cov0" title="0">{
        if branch == "" </span><span class="cov0" title="0">{
                utils.Debug("[GIT.PUSH]: Branch name is empty, defaulting to 'main'")
                branch = "main"
        }</span>

        <span class="cov0" title="0">utils.Debug("[GIT.PUSH]: Pushing branch: " + branch + " in folder: " + rootFolderName)
        if _, err := RunGitCmd(rootFolderName, nil, "push", "origin", branch); err != nil </span><span class="cov0" title="0">{
                utils.Error("[GIT.PUSH.FAIL]: Failed to push branch: " + err.Error())
                return fmt.Errorf("failed to push branch: %s", err.Error())
        }</span>

        <span class="cov0" title="0">utils.Info("[GIT.PUSH.SUCCESS]: Branch pushed successfully")
        return nil</span>
}

func GetFileDiff(filePath string, rootFolder string) (string, error) <span class="cov0" title="0">{
    cmdStatus := exec.Command("git", "-C", rootFolder, "status", "--porcelain", "--untracked-files=all", "--", filePath)

    var statusOut bytes.Buffer
    cmdStatus.Stdout = &amp;statusOut
    cmdStatus.Stderr = &amp;statusOut

    err := cmdStatus.Run()
    if err != nil </span><span class="cov0" title="0">{
        return "", fmt.Errorf("error checking status for file %s: %v", filePath, err)
    }</span>

    <span class="cov0" title="0">if statusOut.String() != "" </span><span class="cov0" title="0">{
        return fmt.Sprintf("New untracked file: %s", filePath), nil
    }</span>

    <span class="cov0" title="0">cmd := exec.Command("git", "-C", rootFolder, "diff", "--", filePath)

    var out bytes.Buffer
    cmd.Stdout = &amp;out
    cmd.Stderr = &amp;out

    err = cmd.Run()
    if err != nil </span><span class="cov0" title="0">{
        return "", fmt.Errorf("error getting diff for file %s: %v", filePath, err)
    }</span>

    <span class="cov0" title="0">return out.String(), nil</span>
}

func BatchProcessWithEmbeddings(allChangedFiles []string, rootFolder string, numClusters int) error <span class="cov0" title="0">{
        utils.Debug("[GIT.BATCH]: Starting batch processing with embeddings and clustering")

        var fileData []FileEmbedding
        var fileErrors []error
        var fileMu sync.Mutex

        for _, file := range allChangedFiles </span><span class="cov0" title="0">{
                diff, err := GetFileDiff(file, rootFolder)
                if err != nil || strings.TrimSpace(diff) == "" </span><span class="cov0" title="0">{
                        utils.Error("[GIT.BATCH]: Could not get diff for file: " + file)
                        continue</span>
                }

                <span class="cov0" title="0">embed, err := embeddings.GenerateEmbedding(diff)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("[GIT.BATCH]: Could not generate embedding for file: " + file)
                        fileMu.Lock()
                        fileErrors = append(fileErrors, err)
                        fileMu.Unlock()        
                        continue</span>
                }

                <span class="cov0" title="0">fileData = append(fileData, FileEmbedding{
                        Path:      file,
                        Diff:      diff,
                        Embedding: embed,
                })</span>
        }

        <span class="cov0" title="0">if len(fileData) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no valid diffs or embeddings generated")
        }</span>

        <span class="cov0" title="0">utils.Debug(fmt.Sprintf("[GIT.BATCH]: Clustering %d files by embeddings", len(fileData)))

        vectors := make([][]float32, len(fileData))
        for i, f := range fileData </span><span class="cov0" title="0">{
                vectors[i] = f.Embedding
        }</span>

        <span class="cov0" title="0">labels, err := embeddings.KMeans(vectors, numClusters, 10)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("clustering failed: %v", err)
        }</span>

        <span class="cov0" title="0">groupMap := make(map[int][]FileEmbedding)
        for i, label := range labels </span><span class="cov0" title="0">{
                groupMap[label] = append(groupMap[label], fileData[i])
        }</span>

        <span class="cov0" title="0">type CommitGroup struct {
                Message string   `json:"message"`
                Files   []string `json:"files"`
        }

        var commitGroups []CommitGroup
        var commitMu sync.Mutex
        var fileWg sync.WaitGroup

        for label, group := range groupMap </span><span class="cov0" title="0">{
                fileWg.Add(1)
                go func(label int, group []FileEmbedding) </span><span class="cov0" title="0">{
                        defer fileWg.Done()
        
                        utils.Debug(fmt.Sprintf("[GIT.BATCH]: Generating commit message for group %d with %d files", label, len(group)))
        
                        var filePaths []string
                        for _, f := range group </span><span class="cov0" title="0">{
                                filePaths = append(filePaths, f.Path)
                        }</span>
        
                        <span class="cov0" title="0">message, err := GenCommitMessage(filePaths, rootFolder)
                        if err != nil </span><span class="cov0" title="0">{
                                utils.Error(fmt.Sprintf("[GIT.BATCH]: Commit message generation failed for group %d - %s", label, err.Error()))
                                fileMu.Lock()
                                fileErrors = append(fileErrors, err)
                                fileMu.Unlock()
                                return
                        }</span>
        
                        <span class="cov0" title="0">commitMu.Lock()
                        commitGroups = append(commitGroups, CommitGroup{
                                Message: message,
                                Files:   filePaths,
                        })
                        commitMu.Unlock()
        
                        for _, f := range group </span><span class="cov0" title="0">{
                                utils.Debug("[GIT.BATCH.SUCCESS]: Generated commit message for file: " + f.Path + " - " + message)
                                output.Set(f.Path, rootFolder, message)
                        }</span>
                }(label, group)
        }
        

        <span class="cov0" title="0">fileWg.Wait()

        if len(fileErrors) &gt; 0 </span><span class="cov0" title="0">{
                utils.Error("[GIT.BATCH.FAIL]: Batch processing completed with errors")
                return fmt.Errorf("one or more errors occurred while preparing commit messages")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RunGitCmdWithTimeout executes a Git command with a timeout
func RunGitCmdWithTimeout(dir string, envVars map[string]string, timeout time.Duration, args ...string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("git", args...)
        cmd.Dir = dir

        // Append custom environment variables to the existing environment
        if envVars != nil </span><span class="cov0" title="0">{
                env := cmd.Env
                for key, value := range envVars </span><span class="cov0" title="0">{
                        env = append(env, fmt.Sprintf("%s=%s", key, value))
                }</span>
                <span class="cov0" title="0">cmd.Env = env</span>
        }

        <span class="cov0" title="0">var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        // Create a channel to signal completion
        done := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                done &lt;- cmd.Run()
        }</span>()

        // Wait for command completion or timeout
        <span class="cov0" title="0">select </span>{
        case err := &lt;-done:<span class="cov0" title="0">
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error(fmt.Sprintf(
                                "[GIT.EXEC.TIMEOUT.FAIL]: Command failed: %s\nStdout: %s\nStderr: %s\n",
                                err,
                                stdout.String(),
                                stderr.String(),
                        ))
                        return "", err
                }</span>
                <span class="cov0" title="0">utils.Debug("[GIT.EXEC.TIMEOUT.SUCCESS]: Command executed successfully in directory '" + dir + "': git " + strings.Join(args, " "))
                return stdout.String(), nil</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                if cmd.Process != nil </span><span class="cov0" title="0">{
                        cmd.Process.Kill()
                }</span>
                <span class="cov0" title="0">err := fmt.Errorf("command timeout after %v", timeout)
                utils.Error("[GIT.EXEC.TIMEOUT]: Command timed out: git " + strings.Join(args, " "))
                return "", err</span>
        }
}

// GetChangedFiles gets changed files from multiple root folders with concurrency control
func GetChangedFiles(rootFolders []string, maxConcurrency int, env ...[]string) ([]output.Folder, error) <span class="cov0" title="0">{
        if maxConcurrency &lt;= 0 </span><span class="cov0" title="0">{
                maxConcurrency = 5 // Default concurrency
        }</span>

        <span class="cov0" title="0">var folders []output.Folder
        folderChan := make(chan output.Folder, len(rootFolders))
        errorChan := make(chan error, len(rootFolders))
        
        // Use a semaphore to limit concurrency
        semaphore := make(chan struct{}, maxConcurrency)
        var wg sync.WaitGroup

        for _, rootFolder := range rootFolders </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(folder string) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        semaphore &lt;- struct{}{} // Acquire
                        defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>() // Release

                        <span class="cov0" title="0">changedFiles, err := GetAllChangedFiles(folder)
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- fmt.Errorf("failed to get changed files for %s: %w", folder, err)
                                return
                        }</span>

                        <span class="cov0" title="0">if len(changedFiles) &gt; 0 </span><span class="cov0" title="0">{
                                var fileEntries []output.FileEntry
                                for _, file := range changedFiles </span><span class="cov0" title="0">{
                                        fileEntries = append(fileEntries, output.FileEntry{
                                                Name:    file,
                                                Message: "", // Message will be generated later
                                        })
                                }</span>
                                
                                <span class="cov0" title="0">folderChan &lt;- output.Folder{
                                        Name:  folder,
                                        Files: fileEntries,
                                }</span>
                        }
                }(rootFolder)
        }

        // Close channels when all goroutines are done
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(folderChan)
                close(errorChan)
        }</span>()

        // Collect results
        <span class="cov0" title="0">for folder := range folderChan </span><span class="cov0" title="0">{
                folders = append(folders, folder)
        }</span>

        // Check for errors
        <span class="cov0" title="0">select </span>{
        case err := &lt;-errorChan:<span class="cov0" title="0">
                return folders, err</span>
        default:<span class="cov0" title="0">
                return folders, nil</span>
        }
}

// Status gets the git status for multiple root paths
func Status(rootPaths []string) ([]output.Folder, error) <span class="cov0" title="0">{
        var folders []output.Folder

        for _, rootPath := range rootPaths </span><span class="cov0" title="0">{
                statusOutput, err := RunGitCmd(rootPath, nil, "status", "--porcelain")
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error("[GIT.STATUS.FAIL]: Failed to get status for " + rootPath + ": " + err.Error())
                        continue</span>
                }

                <span class="cov0" title="0">if strings.TrimSpace(statusOutput) == "" </span><span class="cov0" title="0">{
                        utils.Debug("[GIT.STATUS]: No changes in " + rootPath)
                        continue</span>
                }

                <span class="cov0" title="0">var fileEntries []output.FileEntry
                lines := strings.Split(statusOutput, "\n")
                
                for _, line := range lines </span><span class="cov0" title="0">{
                        if len(line) &lt; 4 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        
                        <span class="cov0" title="0">relativePath := strings.TrimSpace(line[3:])
                        absolutePath := filepath.Join(rootPath, relativePath)
                        
                        fileEntries = append(fileEntries, output.FileEntry{
                                Name:    absolutePath,
                                Message: "", // Status doesn't include commit message
                        })</span>
                }

                <span class="cov0" title="0">if len(fileEntries) &gt; 0 </span><span class="cov0" title="0">{
                        folders = append(folders, output.Folder{
                                Name:  rootPath,
                                Files: fileEntries,
                        })
                }</span>
        }

        <span class="cov0" title="0">return folders, nil</span>
}

// ProcessOneFile processes a single file with the given commit message
func ProcessOneFile(filePath, commitMessage string, env ...[]string) error <span class="cov0" title="0">{
        // Get the directory containing the file
        dir := filepath.Dir(filePath)
        fileName := filepath.Base(filePath)

        // Convert env slice to map
        envMap := make(map[string]string)
        if len(env) &gt; 0 </span><span class="cov0" title="0">{
                for _, pair := range env[0] </span><span class="cov0" title="0">{
                        parts := strings.SplitN(pair, "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                envMap[parts[0]] = parts[1]
                        }</span>
                }
        }

        // Add the file to git
        <span class="cov0" title="0">_, err := RunGitCmd(dir, envMap, "add", fileName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[GIT.PROCESS.FAIL]: Failed to add file: " + err.Error())
                return fmt.Errorf("failed to add file %s: %w", filePath, err)
        }</span>

        // Commit the file
        <span class="cov0" title="0">_, err = RunGitCmd(dir, envMap, "commit", "-m", commitMessage)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[GIT.PROCESS.FAIL]: Failed to commit file: " + err.Error())
                return fmt.Errorf("failed to commit file %s: %w", filePath, err)
        }</span>

        <span class="cov0" title="0">utils.Debug("[GIT.PROCESS.SUCCESS]: Successfully processed file: " + filePath)
        return nil</span>
}

// IsGitRepository checks if the given path is a Git repository
func IsGitRepository(path string) bool <span class="cov0" title="0">{
        _, err := RunGitCmd(path, nil, "rev-parse", "--git-dir")
        return err == nil
}</span>

// GetGitConfigValue gets a Git configuration value
func GetGitConfigValue(key string, env ...[]string) (string, error) <span class="cov0" title="0">{
        // Convert env slice to map
        envMap := make(map[string]string)
        if len(env) &gt; 0 </span><span class="cov0" title="0">{
                for _, pair := range env[0] </span><span class="cov0" title="0">{
                        parts := strings.SplitN(pair, "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                envMap[parts[0]] = parts[1]
                        }</span>
                }
        }

        // Use current directory as default
        <span class="cov0" title="0">dir := "."
        
        output, err := RunGitCmd(dir, envMap, "config", "--get", key)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get git config value for %s: %w", key, err)
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(output), nil</span>
}

// SetGitConfigValue sets a Git configuration value
func SetGitConfigValue(key, value string, env ...[]string) error <span class="cov0" title="0">{
        // Convert env slice to map
        envMap := make(map[string]string)
        if len(env) &gt; 0 </span><span class="cov0" title="0">{
                for _, pair := range env[0] </span><span class="cov0" title="0">{
                        parts := strings.SplitN(pair, "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                envMap[parts[0]] = parts[1]
                        }</span>
                }
        }

        // Use current directory as default
        <span class="cov0" title="0">dir := "."
        
        _, err := RunGitCmd(dir, envMap, "config", "--local", key, value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set git config value %s=%s: %w", key, value, err)
        }</span>

        <span class="cov0" title="0">utils.Debug("[GIT.CONFIG.SET]: Successfully set " + key + "=" + value)
        return nil</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">package git

import (
        "GitCury/output"
        "GitCury/utils"
        "fmt"
        "path/filepath"
        "sync"
        "time"
)

// ProgressCommitBatch is an enhanced version of CommitBatch that includes progress reporting
// and better resource management
func ProgressCommitBatch(rootFolder output.Folder, env ...[]string) error <span class="cov0" title="0">{
        commitMessagesList := rootFolder.Files
        if len(commitMessagesList) == 0 </span><span class="cov0" title="0">{
                utils.Debug("[GIT.COMMIT]: No commit messages found for root folder: " + rootFolder.Name)
                return utils.NewValidationError(
                        "No commit messages found for root folder",
                        nil,
                        map[string]interface{}{
                                "folderName": rootFolder.Name,
                        },
                )
        }</span>

        // Start tracking operation in stats
        <span class="cov0" title="0">if utils.IsStatsEnabled() </span><span class="cov0" title="0">{
                utils.StartOperation("CommitBatch")
        }</span>

        // Create progress reporter for better user feedback
        <span class="cov0" title="0">progress := utils.NewProgressReporter(int64(len(commitMessagesList)), "Committing files in "+rootFolder.Name)
        progress.Start()
        defer progress.Done()

        // Track overall progress
        var progressCounter int64
        var progressMu sync.Mutex

        // Function to update progress safely
        updateProgress := func(count int64, message string) </span><span class="cov0" title="0">{
                progressMu.Lock()
                defer progressMu.Unlock()
                progressCounter += count
                progress.Update(progressCounter)
                if message != "" </span><span class="cov0" title="0">{
                        progress.UpdateMessage(message)
                }</span>

                // Also update stats tracking
                <span class="cov0" title="0">if utils.IsStatsEnabled() </span><span class="cov0" title="0">{
                        // Calculate percentage progress
                        percentage := float64(progressCounter) / float64(len(commitMessagesList)) * 100.0
                        utils.UpdateProgress("CommitBatch", percentage, "running")
                }</span>
        }

        // Call original CommitBatch with progress hooks
        <span class="cov0" title="0">err := SafeGitOperation(rootFolder.Name, "CommitBatch", func() error </span><span class="cov0" title="0">{
                // Process each file with progress reporting
                for i, entry := range commitMessagesList </span><span class="cov0" title="0">{
                        shortFile := filepath.Base(entry.Name)
                        updateProgress(1, fmt.Sprintf("Processing %d/%d: %s", i+1, len(commitMessagesList), shortFile))

                        // Add artificial delay to make progress visible
                        time.Sleep(50 * time.Millisecond)
                }</span>

                // Let the original function do the actual work
                <span class="cov0" title="0">return CommitBatch(rootFolder, env...)</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                progress.UpdateMessage("Commit failed: " + err.Error())

                // Mark operation as failed in stats
                if utils.IsStatsEnabled() </span><span class="cov0" title="0">{
                        utils.FailOperation("CommitBatch", err.Error())
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">progress.UpdateMessage("Commit completed successfully")

        // Mark operation as completed in stats
        if utils.IsStatsEnabled() </span><span class="cov0" title="0">{
                utils.MarkOperationComplete("CommitBatch")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ProgressPushBranch is an enhanced version of PushBranch that includes progress reporting
func ProgressPushBranch(rootFolderName string, branch string) error <span class="cov0" title="0">{
        if branch == "" </span><span class="cov0" title="0">{
                utils.Debug("[GIT.PUSH]: Branch name is empty, defaulting to 'main'")
                branch = "main"
        }</span>

        // Start stats tracking
        <span class="cov0" title="0">if utils.IsStatsEnabled() </span><span class="cov0" title="0">{
                utils.StartOperation("PushBranch")
                utils.UpdateOperationProgress("PushBranch", 10.0)
        }</span>

        // Create progress reporter for terminal output
        <span class="cov0" title="0">progress := utils.NewProgressReporter(100, "Pushing to remote repository")
        progress.Start()
        defer progress.Done()

        // Update initial progress
        progress.Update(10)
        progress.UpdateMessage("Preparing to push branch: " + branch)

        // Update stats progress to match terminal progress
        if utils.IsStatsEnabled() </span><span class="cov0" title="0">{
                utils.UpdateOperationProgress("PushBranch", 25.0)
        }</span>

        // Sleep briefly to make progress visible
        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)

        // Update progress
        progress.Update(50)
        progress.UpdateMessage("Pushing branch '" + branch + "' to remote")

        // Update stats progress
        if utils.IsStatsEnabled() </span><span class="cov0" title="0">{
                utils.UpdateOperationProgress("PushBranch", 50.0)
        }</span>

        // Sleep briefly to make progress visible
        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)

        utils.Debug("[GIT.PUSH]: Pushing branch: " + branch + " in folder: " + rootFolderName)

        // Use SafeGitOperation to handle index.lock and other recovery scenarios
        err := SafeGitOperation(rootFolderName, "push", func() error </span><span class="cov0" title="0">{
                _, gitErr := RunGitCmd(rootFolderName, nil, "push", "origin", branch)
                return gitErr
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                progress.UpdateMessage("Failed to push branch: " + err.Error())

                // Mark operation as failed in stats
                if utils.IsStatsEnabled() </span><span class="cov0" title="0">{
                        utils.FailOperation("PushBranch", err.Error())
                }</span>

                <span class="cov0" title="0">utils.Error("[GIT.PUSH.FAIL]: Failed to push branch: " + err.Error())
                return fmt.Errorf("failed to push branch: %s", err.Error())</span>
        }

        // Update final progress
        <span class="cov0" title="0">progress.Update(100)
        progress.UpdateMessage("Branch pushed successfully")

        // Mark operation as completed in stats
        if utils.IsStatsEnabled() </span><span class="cov0" title="0">{
                utils.MarkOperationComplete("PushBranch")
        }</span>

        <span class="cov0" title="0">utils.Info("[GIT.PUSH.SUCCESS]: Branch pushed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package git

import (
        "GitCury/utils"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// GitOperationResult represents the result of a git operation with recovery information
type GitOperationResult struct {
        Success      bool
        Error        error
        RecoveryPath string
        Message      string
}

// CheckRepositoryHealth checks if a git repository is in a healthy state
// and returns any issues found
func CheckRepositoryHealth(dir string) error <span class="cov0" title="0">{
        // Check if directory exists
        if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return utils.NewValidationError(
                        "Directory does not exist",
                        err,
                        map[string]interface{}{
                                "directory": dir,
                        },
                )
        }</span>

        // Check if this is a git repository
        <span class="cov0" title="0">_, err := RunGitCmdWithTimeout(dir, nil, 5*time.Second, "rev-parse", "--is-inside-work-tree")
        if err != nil </span><span class="cov0" title="0">{
                return utils.NewGitError(
                        "Not a git repository",
                        err,
                        map[string]interface{}{
                                "directory":  dir,
                                "suggestion": "Initialize a git repository with 'git init'",
                        },
                )
        }</span>

        // Check for uncommitted changes that might cause conflicts
        <span class="cov0" title="0">output, err := RunGitCmdWithTimeout(dir, nil, 5*time.Second, "status", "--porcelain")
        if err != nil </span><span class="cov0" title="0">{
                return utils.NewGitError(
                        "Failed to get repository status",
                        err,
                        map[string]interface{}{
                                "directory": dir,
                        },
                )
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(output) != "" </span><span class="cov0" title="0">{
                // There are uncommitted changes, but this is not an error
                utils.Debug("[GIT.HEALTH]: Repository has uncommitted changes: " + dir)
        }</span>

        // Check if the git index is locked
        <span class="cov0" title="0">indexLockPath := filepath.Join(dir, ".git", "index.lock")
        if _, err := os.Stat(indexLockPath); err == nil </span><span class="cov0" title="0">{
                // Index is locked, this might indicate a problem
                lockFileInfo, err := os.Stat(indexLockPath)
                if err == nil </span><span class="cov0" title="0">{
                        lockAge := time.Since(lockFileInfo.ModTime())

                        // If lock file is older than 10 minutes, it's likely stale
                        if lockAge &gt; 10*time.Minute </span><span class="cov0" title="0">{
                                utils.Warning("[GIT.HEALTH]: Found stale index.lock file (age: " + lockAge.String() + ")")
                                return utils.NewGitError(
                                        "Repository index is locked (stale lock)",
                                        nil,
                                        map[string]interface{}{
                                                "directory":  dir,
                                                "lockFile":   indexLockPath,
                                                "lockAge":    lockAge.String(),
                                                "suggestion": "Remove the lock file with 'rm " + indexLockPath + "'",
                                        },
                                )
                        }</span>

                        <span class="cov0" title="0">return utils.NewGitError(
                                "Repository index is locked",
                                nil,
                                map[string]interface{}{
                                        "directory":  dir,
                                        "lockFile":   indexLockPath,
                                        "lockAge":    lockAge.String(),
                                        "suggestion": "Wait for the current git operation to complete or remove the lock file",
                                },
                        )</span>
                }
        }

        // Check if we can access the git config
        <span class="cov0" title="0">_, err = RunGitCmdWithTimeout(dir, nil, 5*time.Second, "config", "--local", "--list")
        if err != nil </span><span class="cov0" title="0">{
                return utils.NewGitError(
                        "Failed to access git config",
                        err,
                        map[string]interface{}{
                                "directory":  dir,
                                "suggestion": "The .git directory might be corrupted, try reinitializing the repository",
                        },
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RecoverFromGitError attempts to recover from common git errors
func RecoverFromGitError(dir string, err error) GitOperationResult <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return GitOperationResult{
                        Success: true,
                        Message: "No error to recover from",
                }
        }</span>

        <span class="cov0" title="0">errMsg := err.Error()

        // Check for index.lock issues
        if strings.Contains(errMsg, "index.lock") </span><span class="cov0" title="0">{
                indexLockPath := filepath.Join(dir, ".git", "index.lock")
                if _, statErr := os.Stat(indexLockPath); statErr == nil </span><span class="cov0" title="0">{
                        // Index lock exists, try to remove it
                        utils.Warning("[GIT.RECOVERY]: Found index.lock file, attempting to remove it")

                        if rmErr := os.Remove(indexLockPath); rmErr == nil </span><span class="cov0" title="0">{
                                return GitOperationResult{
                                        Success:      true,
                                        RecoveryPath: "index_lock_removed",
                                        Message:      "Removed stale index.lock file",
                                }
                        }</span> else<span class="cov0" title="0"> {
                                return GitOperationResult{
                                        Success:      false,
                                        Error:        rmErr,
                                        RecoveryPath: "index_lock_removal_failed",
                                        Message:      "Failed to remove stale index.lock file",
                                }
                        }</span>
                }
        }

        // Check for conflicts
        <span class="cov0" title="0">if strings.Contains(errMsg, "conflict") || strings.Contains(errMsg, "CONFLICT") </span><span class="cov0" title="0">{
                utils.Warning("[GIT.RECOVERY]: Detected conflict in git operation")
                return GitOperationResult{
                        Success:      false,
                        Error:        err,
                        RecoveryPath: "conflict_detected",
                        Message:      "Git operation failed due to conflicts. Manual resolution required.",
                }
        }</span>

        // Check for permission issues
        <span class="cov0" title="0">if strings.Contains(errMsg, "Permission denied") </span><span class="cov0" title="0">{
                utils.Warning("[GIT.RECOVERY]: Detected permission issue in git operation")
                return GitOperationResult{
                        Success:      false,
                        Error:        err,
                        RecoveryPath: "permission_denied",
                        Message:      "Git operation failed due to permission issues. Check file permissions.",
                }
        }</span>

        // No specific recovery path identified
        <span class="cov0" title="0">return GitOperationResult{
                Success:      false,
                Error:        err,
                RecoveryPath: "unknown_error",
                Message:      "No automatic recovery available for this git error",
        }</span>
}

// SafeGitOperation executes a git operation with built-in recovery mechanisms
func SafeGitOperation(dir string, operation string, fn func() error) error <span class="cov0" title="0">{
        // First check repository health
        if err := CheckRepositoryHealth(dir); err != nil </span><span class="cov0" title="0">{
                utils.Warning("[GIT.SAFE]: Repository health check failed: " + err.Error())

                // If the directory doesn't exist, no recovery is possible
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Try to recover from repository issues
                <span class="cov0" title="0">result := RecoverFromGitError(dir, err)
                if !result.Success </span><span class="cov0" title="0">{
                        utils.Error("[GIT.SAFE]: Failed to recover from repository issue: " + result.Message)
                        return utils.NewGitError(
                                "Repository is in an unhealthy state",
                                err,
                                map[string]interface{}{
                                        "directory":    dir,
                                        "operation":    operation,
                                        "recoveryPath": result.RecoveryPath,
                                        "message":      result.Message,
                                },
                        )
                }</span>

                <span class="cov0" title="0">utils.Info("[GIT.SAFE]: Successfully recovered from repository issue: " + result.Message)</span>
        }

        // Execute the git operation
        <span class="cov0" title="0">err := fn()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[GIT.SAFE]: Git operation failed: " + err.Error())

                // Try to recover from the error
                result := RecoverFromGitError(dir, err)
                if !result.Success </span><span class="cov0" title="0">{
                        return utils.NewGitError(
                                fmt.Sprintf("Git operation '%s' failed", operation),
                                err,
                                map[string]interface{}{
                                        "directory":    dir,
                                        "operation":    operation,
                                        "recoveryPath": result.RecoveryPath,
                                        "message":      result.Message,
                                },
                        )
                }</span>

                <span class="cov0" title="0">utils.Info("[GIT.SAFE]: Successfully recovered from git error: " + result.Message)

                // Retry the operation after recovery
                retryErr := fn()
                if retryErr != nil </span><span class="cov0" title="0">{
                        return utils.NewGitError(
                                fmt.Sprintf("Git operation '%s' failed even after recovery", operation),
                                retryErr,
                                map[string]interface{}{
                                        "directory":    dir,
                                        "operation":    operation,
                                        "recoveryPath": result.RecoveryPath,
                                        "message":      "Recovery was successful but operation still failed on retry",
                                },
                        )
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package handlers

import (
        "GitCury/config"
        "GitCury/core"
        "GitCury/output"
        "GitCury/utils"
        "encoding/json"
        "fmt"
        "net/http"
)

func ConfigHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method == http.MethodGet </span><span class="cov0" title="0">{
                // Handle GET request to return the current configuration
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(config.GetAll())
                return
        }</span>

        <span class="cov0" title="0">if r.Method == http.MethodPost </span><span class="cov0" title="0">{
                // Handle POST request to update the configuration
                var settings map[string]interface{}

                if err := json.NewDecoder(r.Body).Decode(&amp;settings); err != nil </span><span class="cov0" title="0">{
                        utils.Error("Error decoding request: " + err.Error())
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">for key, value := range settings </span><span class="cov0" title="0">{
                        utils.Info("Setting " + key + " to " + fmt.Sprintf("%v", value))
                        config.Set(key, value)
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(config.GetAll())
                return</span>
        }

        // Handle unsupported methods
        <span class="cov0" title="0">http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)</span>
}

func PrepareCommitMessagesHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        err := core.GetAllMsgs()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err.Error())
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(output.GetAll())</span>
}

func PrepareCommitMessagesOne(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        folder := r.URL.Query().Get("rootFolder")
        if folder == "" </span><span class="cov0" title="0">{
                utils.Error("Missing root folder name in query parameter")
                http.Error(w, "Missing root folder name in query parameter", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := core.GetMsgsForRootFolder(folder)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err.Error())
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(output.GetFolder(folder))</span>
}

func CommitAllFiles(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        err := core.CommitAllRoots()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err.Error())
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        w.Write([]byte("Files committed successfully and output.json deleted"))</span>
}

func CommitFolder(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        rootFolderName := r.URL.Query().Get("rootFolder")
        if rootFolderName == "" </span><span class="cov0" title="0">{
                utils.Error("Missing root folder name in query parameter")
                http.Error(w, "Missing root folder name in query parameter", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := core.CommitOneRoot(rootFolderName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err.Error())
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        w.Write([]byte("Files committed successfully"))</span>
}

func PushAll(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        branchName := r.URL.Query().Get("branch")
        if branchName == "" </span><span class="cov0" title="0">{
                utils.Error("Missing branch name in query parameter")
                http.Error(w, "Missing branch name in query parameter", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := core.PushAllRoots(branchName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err.Error())
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        w.Write([]byte("All folders pushed successfully"))</span>
}

func PushOne(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        rootFolderName := r.URL.Query().Get("rootFolder")
        branchName := r.URL.Query().Get("branch")

        if rootFolderName == "" || branchName == "" </span><span class="cov0" title="0">{
                utils.Error("Missing root folder name or branch name in query parameters")
                http.Error(w, "Missing root folder name or branch name in query parameters", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := core.PushOneRoot(rootFolderName, branchName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err.Error())
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        w.Write([]byte("Files pushed successfully"))</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package main

import (
        "GitCury/cmd"
        "GitCury/utils"
        "fmt"
        "os"
)

// Version information - these will be set during build by GoReleaser
var (
        version = "dev"
        commit  = "none"
        date    = "unknown"
)

// Old server code left for reference
// func main() {
//         router := mux.NewRouter()

//         router.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
//                 fmt.Fprintln(w, "Welcome to GitCury!")
//         })

//         router.HandleFunc("/config", handlers.ConfigHandler).Methods("GET")
//         router.HandleFunc("/config", handlers.ConfigHandler).Methods("POST")
//         router.HandleFunc("/getallmsgs", handlers.PrepareCommitMessagesHandler).Methods("GET")
//         router.HandleFunc("/getonemsgs", handlers.PrepareCommitMessagesOne).Methods("GET")
//         router.HandleFunc("/commitall", handlers.CommitAllFiles).Methods("GET")
//         router.HandleFunc("/commitone", handlers.CommitFolder).Methods("GET")
//         router.HandleFunc("/pushall", handlers.PushAll).Methods("GET")
//         router.HandleFunc("/pushone", handlers.PushOne).Methods("GET")

//         err := http.ListenAndServe(":8080", router)
//         if err != nil {
//                 utils.Error("Error starting server: " + err.Error())
//                 return
//         }

//         utils.Info("Starting server on :8080")
// }

func main() <span class="cov0" title="0">{
        // Set version information for use in commands
        cmd.SetVersionInfo(version, commit, date)

        // Direct version flag check for simple usage
        if len(os.Args) &gt; 1 &amp;&amp; (os.Args[1] == "--version" || os.Args[1] == "-v") </span><span class="cov0" title="0">{
                fmt.Printf("GitCury %s (commit %s, built on %s)\n", version, commit, date)
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">utils.Debug(fmt.Sprintf("Starting GitCury %s", version))
        cmd.Execute()</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package output

import (
        "GitCury/config"
        "GitCury/utils"
        "encoding/json"
        "os"
        "sync"
)

type FileEntry struct {
        Name    string `json:"name"`
        Message string `json:"message"`
}

type Folder struct {
        Name  string      `json:"name"`
        Files []FileEntry `json:"files"`
}

type OutputData struct {
        Folders []Folder `json:"folders"`
}

var (
        outputData = OutputData{}
        mu         sync.RWMutex
)

func init() <span class="cov0" title="0">{
        LoadOutput()
}</span>

func LoadOutput() <span class="cov0" title="0">{
        outputFilePath, ok := config.Get("output_file_path").(string)
        if !ok || outputFilePath == "" </span><span class="cov0" title="0">{
                outputFilePath = os.Getenv("HOME") + "/.gitcury/output.json"
        }</span>

        <span class="cov0" title="0">file, err := os.Open(outputFilePath)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                utils.Debug("[" + config.Aliases.Output + "]: No existing output file found. Initializing fresh output.")
                return
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: 🚨 Error loading output file: " + err.Error())
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;outputData); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: 🚨 Error decoding output file: " + err.Error())
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.Output + "]: Loaded output data successfully.")</span>
}

func Set(file, rootFolder string, commitMessage string) <span class="cov0" title="0">{
        mu.Lock()
        defer mu.Unlock()

        utils.Debug("[" + config.Aliases.Output + "]: Setting commit message for file: " + file + " in folder: " + rootFolder)
        folder := findOrCreateFolder(rootFolder)

        updated := false
        for i, entry := range folder.Files </span><span class="cov0" title="0">{
                if entry.Name == file </span><span class="cov0" title="0">{
                        folder.Files[i].Message = commitMessage
                        updated = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !updated </span><span class="cov0" title="0">{
                folder.Files = append(folder.Files, FileEntry{Name: file, Message: commitMessage})
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.Output + "]: Commit message set for file: " + file + " in folder: " + rootFolder)</span>
}

func Get(file string, rootFolder string) string <span class="cov0" title="0">{
        mu.RLock()
        defer mu.RUnlock()

        folder := findFolder(rootFolder)
        if folder == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">for _, entry := range folder.Files </span><span class="cov0" title="0">{
                if entry.Name == file </span><span class="cov0" title="0">{
                        return entry.Message
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func GetFolder(rootFolder string) Folder <span class="cov0" title="0">{
        mu.RLock()
        defer mu.RUnlock()

        folder := findFolder(rootFolder)
        if folder != nil </span><span class="cov0" title="0">{
                return *folder
        }</span>
        <span class="cov0" title="0">return Folder{Name: rootFolder, Files: []FileEntry{}}</span>
}

func GetAll() OutputData <span class="cov0" title="0">{
        mu.RLock()
        defer mu.RUnlock()

        copy := OutputData{Folders: make([]Folder, len(outputData.Folders))}
        for i, folder := range outputData.Folders </span><span class="cov0" title="0">{
                copy.Folders[i] = Folder{
                        Name:  folder.Name,
                        Files: append([]FileEntry{}, folder.Files...),
                }
        }</span>
        <span class="cov0" title="0">return copy</span>
}

func Delete(file string, rootFolder string) <span class="cov0" title="0">{
        mu.Lock()
        defer mu.Unlock()

        folder := findFolder(rootFolder)
        if folder == nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: ⚠️ Folder not found: " + rootFolder)
                return
        }</span>

        <span class="cov0" title="0">for i, entry := range folder.Files </span><span class="cov0" title="0">{
                if entry.Name == file </span><span class="cov0" title="0">{
                        folder.Files = append(folder.Files[:i], folder.Files[i+1:]...)
                        break</span>
                }
        }

        <span class="cov0" title="0">if len(folder.Files) == 0 </span><span class="cov0" title="0">{
                RemoveFolder(rootFolder)
        }</span>

        <span class="cov0" title="0">SaveToFile()
        utils.Debug("[" + config.Aliases.Output + "]: File deleted and output saved.")</span>
}

func Clear() <span class="cov0" title="0">{
        mu.Lock()
        defer mu.Unlock()
        outputData = OutputData{}

        outputFilePath, ok := config.Get("output_file_path").(string)
        if !ok || outputFilePath == "" </span><span class="cov0" title="0">{
                outputFilePath = os.Getenv("HOME") + "/.gitcury/output.json"
        }</span>

        <span class="cov0" title="0">if err := os.Remove(outputFilePath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: 🚨 Error deleting output file: " + err.Error())
        }</span> else<span class="cov0" title="0"> {
                utils.Debug("[" + config.Aliases.Output + "]: Output file cleared successfully.")
        }</span>
}

func SaveToFile() <span class="cov0" title="0">{
        utils.Debug("[" + config.Aliases.Output + "]: Saving output data to file...")
        mu.RLock()
        defer mu.RUnlock()

        outputFilePath, ok := config.Get("output_file_path").(string)
        if !ok || outputFilePath == "" </span><span class="cov0" title="0">{
                outputFilePath = os.Getenv("HOME") + "/.gitcury/output.json"
                config.Set("output_file_path", outputFilePath)
        }</span>

        <span class="cov0" title="0">outputFile, err := os.OpenFile(outputFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: 🚨 Error saving output file: " + err.Error())
                return
        }</span>
        <span class="cov0" title="0">defer outputFile.Close()

        encoder := json.NewEncoder(outputFile)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(outputData); err != nil </span><span class="cov0" title="0">{
                utils.Error("[" + config.Aliases.Output + "]: 🚨 Error encoding output data: " + err.Error())
        }</span>

        <span class="cov0" title="0">utils.Debug("[" + config.Aliases.Output + "]: Output data saved successfully to: " + outputFilePath)</span>
}

func findFolder(name string) *Folder <span class="cov0" title="0">{
        for i := range outputData.Folders </span><span class="cov0" title="0">{
                if outputData.Folders[i].Name == name </span><span class="cov0" title="0">{
                        return &amp;outputData.Folders[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func findOrCreateFolder(name string) *Folder <span class="cov0" title="0">{
        folder := findFolder(name)
        if folder == nil </span><span class="cov0" title="0">{
                outputData.Folders = append(outputData.Folders, Folder{Name: name, Files: []FileEntry{}})
                return &amp;outputData.Folders[len(outputData.Folders)-1]
        }</span>
        <span class="cov0" title="0">return folder</span>
}

func RemoveFolder(name string) <span class="cov0" title="0">{
        for i, folder := range outputData.Folders </span><span class="cov0" title="0">{
                if folder.Name == name </span><span class="cov0" title="0">{
                        outputData.Folders = append(outputData.Folders[:i], outputData.Folders[i+1:]...)
                        break</span>
                }
        }

        <span class="cov0" title="0">SaveToFile()
        utils.Debug("[" + config.Aliases.Output + "]: Folder removed and output saved.")</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package mock

import (
        "GitCury/interfaces"
        "fmt"
        "path/filepath"
        "strings"
)

// MockGeminiAPI simulates the Google Gemini API for testing
type MockGeminiAPI struct {
        // State for testing
        CommitMessages     map[string]string // map[filePathKey]commitMessage
        DefaultMessage     string            // Default message if not specifically configured
        ResponseDelay      int               // Simulated response delay in milliseconds
        ShouldFail         bool              // Whether API calls should fail
        FailureMessage     string            // Error message when failing
        LastPrompt         string            // Last prompt sent to API
        LastContextData    map[string]map[string]string // Last context data sent to API
        CallCount          int               // Number of times the API was called
}

// NewMockGeminiAPI creates a new instance with default testing values
func NewMockGeminiAPI() *MockGeminiAPI <span class="cov0" title="0">{
        return &amp;MockGeminiAPI{
                CommitMessages: make(map[string]string),
                DefaultMessage: "feat: implement new feature",
                ResponseDelay:  0,
                ShouldFail:     false,
                FailureMessage: "mock API error",
                CallCount:      0,
        }
}</span>

// Ensure MockGeminiAPI implements GeminiRunner interface
var _ interfaces.GeminiRunner = (*MockGeminiAPI)(nil)

// SetupMockCommitMessage configures a specific commit message for a file or files
func (m *MockGeminiAPI) SetupMockCommitMessage(filePathKey string, message string) <span class="cov0" title="0">{
        m.CommitMessages[filePathKey] = message
}</span>

// SetupDefaultMessage configures the default commit message
func (m *MockGeminiAPI) SetupDefaultMessage(message string) <span class="cov0" title="0">{
        m.DefaultMessage = message
}</span>

// SetupResponseDelay configures a simulated API response delay
func (m *MockGeminiAPI) SetupResponseDelay(milliseconds int) <span class="cov0" title="0">{
        m.ResponseDelay = milliseconds
}</span>

// SetupShouldFail configures whether API calls should fail
func (m *MockGeminiAPI) SetupShouldFail(shouldFail bool, message string) <span class="cov0" title="0">{
        m.ShouldFail = shouldFail
        if message != "" </span><span class="cov0" title="0">{
                m.FailureMessage = message
        }</span>
}

// SendToGemini mocks the SendToGemini function for testing
func (m *MockGeminiAPI) SendToGemini(contextData map[string]map[string]string, apiKey string, customInstructions ...string) (string, error) <span class="cov0" title="0">{
        m.CallCount++
        m.LastContextData = contextData
        
        // Record the last prompt
        if len(customInstructions) &gt; 0 </span><span class="cov0" title="0">{
                m.LastPrompt = customInstructions[0]
        }</span>
        
        // Simulate failure if configured
        <span class="cov0" title="0">if m.ShouldFail </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%s", m.FailureMessage)
        }</span>
        
        // Check for specific file paths to determine the commit message
        <span class="cov0" title="0">var filesList []string
        for filePath := range contextData </span><span class="cov0" title="0">{
                filesList = append(filesList, filePath)
        }</span>
        
        // Sort files to create a consistent key
        <span class="cov0" title="0">filesKey := strings.Join(filesList, "|")
        
        // Return specific message if configured
        if message, ok := m.CommitMessages[filesKey]; ok </span><span class="cov0" title="0">{
                return message, nil
        }</span>
        
        // For single file cases, check individual files
        <span class="cov0" title="0">if len(filesList) == 1 &amp;&amp; len(m.CommitMessages) &gt; 0 </span><span class="cov0" title="0">{
                for filePath, message := range m.CommitMessages </span><span class="cov0" title="0">{
                        if strings.Contains(filesKey, filePath) </span><span class="cov0" title="0">{
                                return message, nil
                        }</span>
                }
        }
        
        // Default message with file info
        <span class="cov0" title="0">fileCount := len(filesList)
        if fileCount == 1 </span><span class="cov0" title="0">{
                baseName := filepath.Base(filesList[0])
                return fmt.Sprintf("feat: update %s", baseName), nil
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("feat: update %d files", fileCount), nil
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package mock

import (
        "GitCury/di"
        "GitCury/interfaces"
        "GitCury/output"
        "errors"
        "fmt"
        "path/filepath"
        "strings"
        "time"
)

// MockGitRunner implements the GitRunner interface for testing
type MockGitRunner struct {
        // State for testing
        ChangedFiles     map[string][]string          // map[rootPath][]filePaths
        CommitResults    map[string]bool              // map[folderName]success
        PushResults      map[string]bool              // map[folderName]success
        DiffResults      map[string]string            // map[filePath]diffOutput
        ConfigValues     map[string]string            // map[key]value
        IsRepoResults    map[string]bool              // map[path]isRepo
        CommandResults   map[string]string            // map[command]output
        CommandErrors    map[string]error             // map[command]error
        CommandCalls     []CommandCall                // Record of all commands called
        LastCommitFolder interfaces.Folder              // Last folder committed
        LastPushBranch   string                       // Last branch pushed
        ShouldFailBatchProcess bool                    // Control batch processing failures
}

// CommandCall records details of a command that was called
type CommandCall struct {
        Dir     string
        Env     map[string]string
        Args    []string
        Timeout time.Duration
}

// NewMockGitRunner creates a new instance with default testing values
func NewMockGitRunner() *MockGitRunner <span class="cov0" title="0">{
        return &amp;MockGitRunner{
                ChangedFiles:   make(map[string][]string),
                CommitResults:  make(map[string]bool),
                PushResults:    make(map[string]bool),
                DiffResults:    make(map[string]string),
                ConfigValues:   make(map[string]string),
                IsRepoResults:  make(map[string]bool),
                CommandResults: make(map[string]string),
                CommandErrors:  make(map[string]error),
                CommandCalls:   make([]CommandCall, 0),
                ShouldFailBatchProcess: false, // Default to success
        }
}</span>

// SetupMockChangedFiles configures mock changed files for testing
func (m *MockGitRunner) SetupMockChangedFiles(rootFolder string, files []string) <span class="cov0" title="0">{
        m.ChangedFiles[rootFolder] = files
}</span>

// SetupMockCommitResult configures mock commit results for testing
func (m *MockGitRunner) SetupMockCommitResult(folderName string, success bool) <span class="cov0" title="0">{
        m.CommitResults[folderName] = success
}</span>

// SetupMockPushResult configures mock push results for testing
func (m *MockGitRunner) SetupMockPushResult(folderName string, success bool) <span class="cov0" title="0">{
        m.PushResults[folderName] = success
}</span>

// SetupMockDiffResult configures mock diff results for testing
func (m *MockGitRunner) SetupMockDiffResult(filePath string, diffOutput string) <span class="cov0" title="0">{
        m.DiffResults[filePath] = diffOutput
}</span>

// SetupMockConfigValue configures mock git config values for testing
func (m *MockGitRunner) SetupMockConfigValue(key string, value string) <span class="cov0" title="0">{
        m.ConfigValues[key] = value
}</span>

// SetupMockIsRepo configures mock repository check results for testing
func (m *MockGitRunner) SetupMockIsRepo(path string, isRepo bool) <span class="cov0" title="0">{
        m.IsRepoResults[path] = isRepo
}</span>

// SetupMockCommandResult configures mock command results for testing
func (m *MockGitRunner) SetupMockCommandResult(command string, output string) <span class="cov0" title="0">{
        m.CommandResults[command] = output
}</span>

// SetupMockCommandError configures mock command errors for testing
func (m *MockGitRunner) SetupMockCommandError(command string, err error) <span class="cov0" title="0">{
        m.CommandErrors[command] = err
}</span>

// ClearMockErrors clears all configured command errors
func (m *MockGitRunner) ClearMockErrors() <span class="cov0" title="0">{
        m.CommandErrors = make(map[string]error)
}</span>

// RunGitCmd implements the GitRunner.RunGitCmd interface method
func (m *MockGitRunner) RunGitCmd(dir string, envVars map[string]string, args ...string) (string, error) <span class="cov0" title="0">{
        return m.RunGitCmdWithTimeout(dir, envVars, 30*time.Second, args...)
}</span>

// RunGitCmdWithTimeout implements the GitRunner.RunGitCmdWithTimeout interface method
func (m *MockGitRunner) RunGitCmdWithTimeout(dir string, envVars map[string]string, timeout time.Duration, args ...string) (string, error) <span class="cov0" title="0">{
        // Record the command call
        m.CommandCalls = append(m.CommandCalls, CommandCall{
                Dir:     dir,
                Env:     envVars,
                Args:    args,
                Timeout: timeout,
        })

        // Create a command string for lookup
        cmdStr := strings.Join(args, " ")

        // Check for specific command errors
        if err, ok := m.CommandErrors[cmdStr]; ok &amp;&amp; err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Return command result if configured
        <span class="cov0" title="0">if output, ok := m.CommandResults[cmdStr]; ok </span><span class="cov0" title="0">{
                return output, nil
        }</span>

        // Default behavior based on command type
        <span class="cov0" title="0">switch </span>{
        case len(args) &gt;= 2 &amp;&amp; args[0] == "diff":<span class="cov0" title="0">
                // Handle diff command
                filePath := args[len(args)-1]
                if diff, ok := m.DiffResults[filePath]; ok </span><span class="cov0" title="0">{
                        return diff, nil
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("mock diff for %s", filePath), nil</span>

        case len(args) &gt;= 1 &amp;&amp; args[0] == "status":<span class="cov0" title="0">
                // Generate mock status output
                var output strings.Builder
                output.WriteString("On branch main\n")
                output.WriteString("Changes not staged for commit:\n")
                
                if files, ok := m.ChangedFiles[dir]; ok </span><span class="cov0" title="0">{
                        for _, file := range files </span><span class="cov0" title="0">{
                                output.WriteString(fmt.Sprintf("  modified: %s\n", file))
                        }</span>
                }
                
                <span class="cov0" title="0">return output.String(), nil</span>

        case len(args) &gt;= 2 &amp;&amp; args[0] == "config" &amp;&amp; args[1] == "--get":<span class="cov0" title="0">
                // Handle config get command
                if len(args) &gt;= 3 </span><span class="cov0" title="0">{
                        key := args[2]
                        if value, ok := m.ConfigValues[key]; ok </span><span class="cov0" title="0">{
                                return value, nil
                        }</span>
                        <span class="cov0" title="0">return "", errors.New("mock: config value not found")</span>
                }
                <span class="cov0" title="0">return "", errors.New("mock: invalid config get command")</span>

        case len(args) &gt;= 3 &amp;&amp; args[0] == "config" &amp;&amp; args[1] == "--local":<span class="cov0" title="0">
                // Handle config set command
                key := args[2]
                value := args[3]
                m.ConfigValues[key] = value
                return "", nil</span>

        case len(args) &gt;= 2 &amp;&amp; args[0] == "add":<span class="cov0" title="0">
                // Handle add command
                return "", nil</span>

        case len(args) &gt;= 2 &amp;&amp; args[0] == "commit":<span class="cov0" title="0">
                // Handle commit command
                return "", nil</span>

        case len(args) &gt;= 2 &amp;&amp; args[0] == "push":<span class="cov0" title="0">
                // Handle push command
                return "", nil</span>

        default:<span class="cov0" title="0">
                // Default mock response
                return fmt.Sprintf("mock output for git %s", strings.Join(args, " ")), nil</span>
        }
}

// CommitBatch implements the GitRunner.CommitBatch interface method
func (m *MockGitRunner) CommitBatch(folder interfaces.Folder, env ...[]string) error <span class="cov0" title="0">{
        m.LastCommitFolder = folder
        
        // Check if we have a specific result for this folder
        if result, ok := m.CommitResults[folder.Name]; ok </span><span class="cov0" title="0">{
                if !result </span><span class="cov0" title="0">{
                        return errors.New("mock commit error for folder: " + folder.Name)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        
        // Default to success
        <span class="cov0" title="0">return nil</span>
}

// GetChangedFiles implements the GitRunner.GetChangedFiles interface method
func (m *MockGitRunner) GetChangedFiles(rootFolders []string, maxConcurrency int, env ...[]string) ([]interfaces.Folder, error) <span class="cov0" title="0">{
        var folders []interfaces.Folder
        
        for _, rootFolder := range rootFolders </span><span class="cov0" title="0">{
                if files, ok := m.ChangedFiles[rootFolder]; ok &amp;&amp; len(files) &gt; 0 </span><span class="cov0" title="0">{
                        var fileEntries []interfaces.FileEntry
                        for _, file := range files </span><span class="cov0" title="0">{
                                fileEntries = append(fileEntries, interfaces.FileEntry{
                                        Name:    filepath.Join(rootFolder, file),
                                        Message: "", // Empty message initially
                                })
                        }</span>
                        
                        <span class="cov0" title="0">folders = append(folders, interfaces.Folder{
                                Name:  rootFolder,
                                Files: fileEntries,
                        })</span>
                }
        }
        
        <span class="cov0" title="0">return folders, nil</span>
}

// Status implements the GitRunner.Status interface method
func (m *MockGitRunner) Status(rootPaths []string) ([]interfaces.Folder, error) <span class="cov0" title="0">{
        return m.GetChangedFiles(rootPaths, 1)
}</span>

// ProcessOneFile implements the GitRunner.ProcessOneFile interface method
func (m *MockGitRunner) ProcessOneFile(filePath, commitMessage string, env ...[]string) error <span class="cov0" title="0">{
        // Check if the file is in our mock changed files
        for _, files := range m.ChangedFiles </span><span class="cov0" title="0">{
                for _, file := range files </span><span class="cov0" title="0">{
                        if strings.HasSuffix(filePath, file) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return errors.New("mock: file not found: " + filePath)</span>
}

// GetDiff implements the GitRunner.GetDiff interface method
func (m *MockGitRunner) GetDiff(filePath string, env ...[]string) (string, error) <span class="cov0" title="0">{
        if diff, ok := m.DiffResults[filePath]; ok </span><span class="cov0" title="0">{
                return diff, nil
        }</span>
        
        <span class="cov0" title="0">return fmt.Sprintf("mock diff for %s", filePath), nil</span>
}

// IsGitRepository implements the GitRunner.IsGitRepository interface method
func (m *MockGitRunner) IsGitRepository(path string) bool <span class="cov0" title="0">{
        if result, ok := m.IsRepoResults[path]; ok </span><span class="cov0" title="0">{
                return result
        }</span>
        
        // Default to true for testing
        <span class="cov0" title="0">return true</span>
}

// GetGitConfigValue implements the GitRunner.GetGitConfigValue interface method
func (m *MockGitRunner) GetGitConfigValue(key string, env ...[]string) (string, error) <span class="cov0" title="0">{
        if value, ok := m.ConfigValues[key]; ok </span><span class="cov0" title="0">{
                return value, nil
        }</span>
        
        <span class="cov0" title="0">return "", errors.New("mock: config value not found: " + key)</span>
}

// SetGitConfigValue implements the GitRunner.SetGitConfigValue interface method
func (m *MockGitRunner) SetGitConfigValue(key, value string, env ...[]string) error <span class="cov0" title="0">{
        m.ConfigValues[key] = value
        return nil
}</span>

// ProgressCommitBatch implements the GitRunner.ProgressCommitBatch interface method
func (m *MockGitRunner) ProgressCommitBatch(folder interfaces.Folder, env ...[]string) error <span class="cov0" title="0">{
        m.LastCommitFolder = folder
        
        // Check if we have a specific result for this folder
        if result, ok := m.CommitResults[folder.Name]; ok </span><span class="cov0" title="0">{
                if !result </span><span class="cov0" title="0">{
                        return errors.New("mock commit error for folder: " + folder.Name)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        
        // Default to success
        <span class="cov0" title="0">return nil</span>
}

// ProgressPushBranch implements the GitRunner.ProgressPushBranch interface method
func (m *MockGitRunner) ProgressPushBranch(rootFolderName string, branch string) error <span class="cov0" title="0">{
        m.LastPushBranch = branch
        
        // Record the command call
        m.CommandCalls = append(m.CommandCalls, CommandCall{
                Dir:  rootFolderName,
                Args: []string{"push", "origin", branch},
        })
        
        // Check if we have a specific result for this folder
        if result, ok := m.PushResults[rootFolderName]; ok </span><span class="cov0" title="0">{
                if !result </span><span class="cov0" title="0">{
                        return errors.New("mock push error for folder: " + rootFolderName)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        
        // Default to success
        <span class="cov0" title="0">return nil</span>
}

// GetAllChangedFiles implements the GitRunner.GetAllChangedFiles interface method
func (m *MockGitRunner) GetAllChangedFiles(dir string) ([]string, error) <span class="cov0" title="0">{
        if files, ok := m.ChangedFiles[dir]; ok </span><span class="cov0" title="0">{
                var absolutePaths []string
                for _, file := range files </span><span class="cov0" title="0">{
                        absolutePaths = append(absolutePaths, filepath.Join(dir, file))
                }</span>
                <span class="cov0" title="0">return absolutePaths, nil</span>
        }
        
        // Return empty slice for testing
        <span class="cov0" title="0">return []string{}, nil</span>
}

// BatchProcessGetMessages implements the GitRunner.BatchProcessGetMessages interface method
func (m *MockGitRunner) BatchProcessGetMessages(allChangedFiles []string, rootFolder string) error <span class="cov0" title="0">{
        // This mock should call the Gemini API to ensure dependency injection testing works correctly
        // Instead of calling the real git.GenCommitMessage which requires real git repos,
        // we'll directly call the dependency-injected Gemini runner
        
        for _, file := range allChangedFiles </span><span class="cov0" title="0">{
                // Create mock context data for the file
                contextData := map[string]map[string]string{
                        file: {
                                "type": "modified",
                                "diff": fmt.Sprintf("mock diff for %s", file),
                        },
                }
                
                // Call the dependency-injected Gemini runner to test the DI system
                message, err := di.GetGeminiRunner().SendToGemini(contextData, "test-api-key")
                if err != nil </span><span class="cov0" title="0">{
                        // If there's an error, use a fallback mock message
                        message = fmt.Sprintf("Mock commit message for %s", filepath.Base(file))
                }</span>
                
                // Use the output system to store the message
                <span class="cov0" title="0">output.Set(file, rootFolder, message)</span>
        }
        
        // Check if there's a predefined error for this operation
        <span class="cov0" title="0">if m.ShouldFailBatchProcess </span><span class="cov0" title="0">{
                return errors.New("mock: batch process failed")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// BatchProcessWithEmbeddings implements the GitRunner.BatchProcessWithEmbeddings interface method
func (m *MockGitRunner) BatchProcessWithEmbeddings(allChangedFiles []string, rootFolder string, numClusters int) error <span class="cov0" title="0">{
        // Mock implementation that simulates successful clustering and processing
        for i, file := range allChangedFiles </span><span class="cov0" title="0">{
                // Generate a mock grouped commit message
                clusterID := i % numClusters
                message := fmt.Sprintf("Mock grouped commit message for cluster %d: %s", clusterID, filepath.Base(file))
                
                // Use the output system to store the message
                output.Set(file, rootFolder, message)
        }</span>
        
        // Check if there's a predefined error for this operation
        <span class="cov0" title="0">if m.ShouldFailBatchProcess </span><span class="cov0" title="0">{
                return errors.New("mock: batch process with embeddings failed")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// Ensure MockGitRunner implements GitRunner interface
var _ interfaces.GitRunner = (*MockGitRunner)(nil)
</pre>
		
		<pre class="file" id="file28" style="display: none">// package testutils provides utilities for setting up test environments
package testutils

import (
        "GitCury/config"
        "GitCury/core"
        "GitCury/di"
        "GitCury/output"
        "GitCury/tests/mock"
        "os"
        "path/filepath"
)

// TestEnv holds references to mocks and test setup
type TestEnv struct {
        TempDir    string               // Temporary directory for test files
        GitMock    *mock.MockGitRunner  // Mock git implementation
        GeminiMock *mock.MockGeminiAPI  // Mock Gemini API
}

// SetupTestEnv creates a test environment with mocks
func SetupTestEnv() (*TestEnv, error) <span class="cov0" title="0">{
        // Create temporary directory
        tempDir, err := os.MkdirTemp("", "gitcury-test-")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create mock instances
        <span class="cov0" title="0">gitMock := mock.NewMockGitRunner()
        geminiMock := mock.NewMockGeminiAPI()

        // Set test mode environment variable to bypass config validation
        os.Setenv("GITCURY_TEST_MODE", "true")

        // Inject the mock git runner for testing
        core.SetGitRunner(gitMock)

        // Inject the mock Gemini runner for testing
        di.SetGeminiRunner(geminiMock)

        // Reset config for testing
        config.ResetConfig()

        // Configure test settings
        config.Set("app_name", "GitCury-Test")
        config.Set("numFilesToCommit", 5)
        config.Set("root_folders", []string{tempDir})
        config.Set("GEMINI_API_KEY", "test-api-key")

        // Return the test environment
        return &amp;TestEnv{
                TempDir:    tempDir,
                GitMock:    gitMock,
                GeminiMock: geminiMock,
        }, nil</span>
}

// CreateTestFiles creates test files in the temp directory
func (env *TestEnv) CreateTestFiles(files []string) []string <span class="cov0" title="0">{
        var paths []string
        for _, file := range files </span><span class="cov0" title="0">{
                path := filepath.Join(env.TempDir, file)
                dir := filepath.Dir(path)
                
                // Create directory if it doesn't exist
                if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        os.MkdirAll(dir, 0755)
                }</span>
                
                // Create file with simple content
                <span class="cov0" title="0">content := []byte("Test content for " + file)
                os.WriteFile(path, content, 0644)
                
                paths = append(paths, path)</span>
        }
        <span class="cov0" title="0">return paths</span>
}

// MockMessages adds mock messages directly to the output system
func (env *TestEnv) MockMessages(files []string, messages map[string]string) <span class="cov0" title="0">{
        for _, file := range files </span><span class="cov0" title="0">{
                filePath := filepath.Join(env.TempDir, file)
                message := "Default mock message"
                
                if msg, ok := messages[file]; ok </span><span class="cov0" title="0">{
                        message = msg
                }</span>
                
                <span class="cov0" title="0">output.Set(filePath, env.TempDir, message)</span>
        }
}

// Cleanup releases resources used by the test environment
func (env *TestEnv) Cleanup() <span class="cov0" title="0">{
        // Remove temporary directory
        os.RemoveAll(env.TempDir)
        
        // Reset config
        config.ResetConfig()
        
        // Clear output data
        output.Clear()
        
        // Reset test mode environment variable
        os.Unsetenv("GITCURY_TEST_MODE")
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package utils

import (
        "context"
        "fmt"
        "io"
        "math/rand"
        "os"
        "sync"
        "time"
)

// CreativeLoader provides a more engaging progress display with various animations
type CreativeLoader struct {
        message       string
        isActive      bool
        ctx           context.Context
        cancel        context.CancelFunc
        wg            sync.WaitGroup
        writer        io.Writer
        hideInQuiet   bool
        animationType AnimationType
        currentPhase  string
        startTime     time.Time
        mu            sync.RWMutex
}

// AnimationType defines the type of animation to use
type AnimationType int

const (
        SpinnerAnimation AnimationType = iota
        DotsAnimation
        BarAnimation
        BrailleAnimation
        GitAnimation
        ProcessingAnimation
)

// Animation frames for different types
var (
        spinnerFrames = []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"}
        dotsFrames    = []string{"   ", ".  ", ".. ", "..."}
        barFrames     = []string{"▱▱▱▱▱", "▰▱▱▱▱", "▰▰▱▱▱", "▰▰▰▱▱", "▰▰▰▰▱", "▰▰▰▰▰", "▱▰▰▰▰", "▱▱▰▰▰", "▱▱▱▰▰", "▱▱▱▱▰"}
        brailleFrames = []string{"⣾", "⣽", "⣻", "⢿", "⡿", "⣟", "⣯", "⣷"}
        gitFrames     = []string{"🌱", "🌿", "🌳", "📝", "✨", "🚀"}
        processFrames = []string{"📂", "🔍", "⚙️", "🔧", "✅", "🎉"}
)

// Creative messages for different phases
var creativeMessages = map[string][]string{
        "analyzing": {
                "Analyzing code changes",
                "Examining file modifications",
                "Understanding your work",
                "Parsing repository state",
                "Inspecting changes",
        },
        "generating": {
                "Crafting commit messages",
                "Generating descriptions",
                "Creating summaries",
                "Composing commit text",
                "Building messages",
        },
        "clustering": {
                "Grouping related files",
                "Organizing changes",
                "Clustering modifications",
                "Categorizing updates",
                "Arranging file groups",
        },
        "processing": {
                "Processing files",
                "Working through changes",
                "Handling modifications",
                "Processing updates",
                "Managing file operations",
        },
        "finalizing": {
                "Finalizing results",
                "Completing operations",
                "Wrapping up",
                "Finishing touches",
                "Nearly done",
        },
}

// NewCreativeLoader creates a new creative loader
func NewCreativeLoader(message string, animationType AnimationType) *CreativeLoader <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        return &amp;CreativeLoader{
                message:       message,
                isActive:      false,
                ctx:           ctx,
                cancel:        cancel,
                writer:        os.Stdout,
                hideInQuiet:   true,
                animationType: animationType,
                currentPhase:  "processing",
        }
}</span>

// SetWriter sets the output writer
func (cl *CreativeLoader) SetWriter(writer io.Writer) *CreativeLoader <span class="cov0" title="0">{
        cl.writer = writer
        return cl
}</span>

// SetHideInQuiet sets whether to hide in quiet mode
func (cl *CreativeLoader) SetHideInQuiet(hide bool) *CreativeLoader <span class="cov0" title="0">{
        cl.hideInQuiet = hide
        return cl
}</span>

// SetPhase updates the current phase for dynamic messages
func (cl *CreativeLoader) SetPhase(phase string) <span class="cov0" title="0">{
        cl.mu.Lock()
        defer cl.mu.Unlock()
        cl.currentPhase = phase
}</span>

// Start begins the creative loader animation
func (cl *CreativeLoader) Start() <span class="cov0" title="0">{
        cl.mu.Lock()
        if cl.isActive </span><span class="cov0" title="0">{
                cl.mu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">cl.isActive = true
        cl.startTime = time.Now()
        cl.mu.Unlock()

        cl.wg.Add(1)
        go cl.animate()</span>
}

// Stop stops the creative loader animation
func (cl *CreativeLoader) Stop() <span class="cov0" title="0">{
        cl.mu.Lock()
        if !cl.isActive </span><span class="cov0" title="0">{
                cl.mu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">cl.isActive = false
        cl.mu.Unlock()

        cl.cancel()
        cl.wg.Wait()

        // Clear the line properly
        if !cl.hideInQuiet || !IsQuietMode() </span><span class="cov0" title="0">{
                fmt.Fprintf(cl.writer, "\r%s\r", clearLine(100))
        }</span>
}

// UpdateMessage updates the loader message
func (cl *CreativeLoader) UpdateMessage(message string) <span class="cov0" title="0">{
        cl.mu.Lock()
        defer cl.mu.Unlock()
        cl.message = message
}</span>

// animate runs the animation loop
func (cl *CreativeLoader) animate() <span class="cov0" title="0">{
        defer cl.wg.Done()

        var frames []string
        var frameDuration time.Duration

        switch cl.animationType </span>{
        case SpinnerAnimation:<span class="cov0" title="0">
                frames = spinnerFrames
                frameDuration = 80 * time.Millisecond</span>
        case DotsAnimation:<span class="cov0" title="0">
                frames = dotsFrames
                frameDuration = 400 * time.Millisecond</span>
        case BarAnimation:<span class="cov0" title="0">
                frames = barFrames
                frameDuration = 150 * time.Millisecond</span>
        case BrailleAnimation:<span class="cov0" title="0">
                frames = brailleFrames
                frameDuration = 100 * time.Millisecond</span>
        case GitAnimation:<span class="cov0" title="0">
                frames = gitFrames
                frameDuration = 600 * time.Millisecond</span>
        case ProcessingAnimation:<span class="cov0" title="0">
                frames = processFrames
                frameDuration = 800 * time.Millisecond</span>
        default:<span class="cov0" title="0">
                frames = spinnerFrames
                frameDuration = 80 * time.Millisecond</span>
        }

        <span class="cov0" title="0">ticker := time.NewTicker(frameDuration)
        defer ticker.Stop()

        frameIndex := 0
        messageIndex := 0
        messageChangeCounter := 0

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-cl.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if cl.hideInQuiet &amp;&amp; IsQuietMode() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">cl.mu.RLock()
                        if !cl.isActive </span><span class="cov0" title="0">{
                                cl.mu.RUnlock()
                                return
                        }</span>

                        // Get current frame
                        <span class="cov0" title="0">frame := frames[frameIndex]
                        frameIndex = (frameIndex + 1) % len(frames)

                        // Get dynamic message based on phase
                        currentMessage := cl.message
                        if messages, exists := creativeMessages[cl.currentPhase]; exists &amp;&amp; len(messages) &gt; 0 </span><span class="cov0" title="0">{
                                // Change message every 8 animation cycles for smoother experience
                                if messageChangeCounter%8 == 0 </span><span class="cov0" title="0">{
                                        messageIndex = rand.Intn(len(messages))
                                }</span>
                                <span class="cov0" title="0">currentMessage = messages[messageIndex]</span>
                        }
                        <span class="cov0" title="0">messageChangeCounter++

                        // Create the animated line with consistent width
                        elapsed := time.Since(cl.startTime)
                        timeStr := formatDuration(elapsed)

                        // Pad message to consistent width (40 characters) for smooth animation
                        paddedMessage := padString(currentMessage, 40)

                        var animatedLine string
                        switch cl.animationType </span>{
                        case GitAnimation, ProcessingAnimation:<span class="cov0" title="0">
                                animatedLine = fmt.Sprintf("\r%s %s [%s]", frame, paddedMessage, timeStr)</span>
                        case DotsAnimation:<span class="cov0" title="0">
                                // For dots, show dots after padding
                                baseMsg := padString(currentMessage, 37) // Leave room for dots
                                animatedLine = fmt.Sprintf("\r🔄 %s%s [%s]", baseMsg, frame, timeStr)</span>
                        case BarAnimation:<span class="cov0" title="0">
                                animatedLine = fmt.Sprintf("\r[%s] %s [%s]", frame, paddedMessage, timeStr)</span>
                        default:<span class="cov0" title="0">
                                animatedLine = fmt.Sprintf("\r%s %s [%s]", frame, paddedMessage, timeStr)</span>
                        }

                        // Clear any remaining characters and write the line
                        <span class="cov0" title="0">fmt.Fprintf(cl.writer, "%s%s", animatedLine, clearEndOfLine())
                        cl.mu.RUnlock()</span>
                }
        }
}

// clearLine returns a string of spaces to clear a line of given length
func clearLine(length int) string <span class="cov0" title="0">{
        spaces := make([]byte, length)
        for i := range spaces </span><span class="cov0" title="0">{
                spaces[i] = ' '
        }</span>
        <span class="cov0" title="0">return string(spaces)</span>
}

// clearEndOfLine returns ANSI escape sequence to clear to end of line
func clearEndOfLine() string <span class="cov0" title="0">{
        return "\033[K"
}</span>

// padString pads a string to a specific width, truncating if too long
func padString(s string, width int) string <span class="cov0" title="0">{
        if len(s) &gt; width </span><span class="cov0" title="0">{
                return s[:width-3] + "..."
        }</span>
        <span class="cov0" title="0">format := fmt.Sprintf("%%-%ds", width)
        return fmt.Sprintf(format, s)</span>
}

// Global creative loader instance for easy access
var globalLoader *CreativeLoader
var loaderMu sync.Mutex

// StartCreativeLoader starts a global creative loader
func StartCreativeLoader(message string, animationType AnimationType) <span class="cov0" title="0">{
        loaderMu.Lock()
        defer loaderMu.Unlock()

        if globalLoader != nil </span><span class="cov0" title="0">{
                globalLoader.Stop()
        }</span>

        <span class="cov0" title="0">globalLoader = NewCreativeLoader(message, animationType)
        globalLoader.Start()</span>
}

// UpdateCreativeLoaderMessage updates the global loader message
func UpdateCreativeLoaderMessage(message string) <span class="cov0" title="0">{
        loaderMu.Lock()
        defer loaderMu.Unlock()

        if globalLoader != nil </span><span class="cov0" title="0">{
                globalLoader.UpdateMessage(message)
        }</span>
}

// UpdateCreativeLoaderPhase updates the global loader phase
func UpdateCreativeLoaderPhase(phase string) <span class="cov0" title="0">{
        loaderMu.Lock()
        defer loaderMu.Unlock()

        if globalLoader != nil </span><span class="cov0" title="0">{
                globalLoader.SetPhase(phase)
        }</span>
}

// StopCreativeLoader stops the global creative loader
func StopCreativeLoader() <span class="cov0" title="0">{
        loaderMu.Lock()
        defer loaderMu.Unlock()

        if globalLoader != nil </span><span class="cov0" title="0">{
                globalLoader.Stop()
                globalLoader = nil
        }</span>
}

// IsCreativeLoaderActive returns whether the global loader is active
func IsCreativeLoaderActive() bool <span class="cov0" title="0">{
        loaderMu.Lock()
        defer loaderMu.Unlock()

        return globalLoader != nil &amp;&amp; globalLoader.isActive
}</span>

// ShowCompletionMessage displays a completion message with appropriate styling
func ShowCompletionMessage(message string, success bool) <span class="cov0" title="0">{
        StopCreativeLoader()

        if IsQuietMode() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var icon string
        if success </span><span class="cov0" title="0">{
                icon = "✅"
        }</span> else<span class="cov0" title="0"> {
                icon = "❌"
        }</span>

        <span class="cov0" title="0">fmt.Printf("\r%s %s\n", icon, message)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package utils

import (
        "GitCury/di"
        "GitCury/interfaces"
)

// DefaultGeminiRunner implements the GeminiRunner interface using the real Gemini API
type DefaultGeminiRunner struct{}

// NewDefaultGeminiRunner creates a new instance of DefaultGeminiRunner
func NewDefaultGeminiRunner() interfaces.GeminiRunner <span class="cov0" title="0">{
        return &amp;DefaultGeminiRunner{}
}</span>

// init initializes the default Gemini runner
func init() <span class="cov0" title="0">{
        if di.GetGeminiRunner() == nil </span><span class="cov0" title="0">{
                di.SetGeminiRunner(NewDefaultGeminiRunner())
        }</span>
}

// SendToGemini delegates to the real SendToGemini function
func (r *DefaultGeminiRunner) SendToGemini(contextData map[string]map[string]string, apiKey string, customInstructions ...string) (string, error) <span class="cov0" title="0">{
        return SendToGemini(contextData, apiKey, customInstructions...)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package utils

import (
        "fmt"
        "strings"
)

// ErrorType represents the category of an error
type ErrorType string

const (
        // Error categories
        ConfigError     ErrorType = "CONFIG"
        GitError        ErrorType = "GIT"
        APIError        ErrorType = "API"
        ValidationError ErrorType = "VALIDATION"
        SystemError     ErrorType = "SYSTEM"
        UserError       ErrorType = "USER"
)

// StructuredError represents an error with additional context
type StructuredError struct {
        Type          ErrorType
        Message       string
        Cause         error
        Context       map[string]interface{}
        ProcessedFile string
}

// Error implements the error interface
func (e *StructuredError) Error() string <span class="cov0" title="0">{
        msg := fmt.Sprintf("[%s] %s", e.Type, e.Message)
        if e.Cause != nil </span><span class="cov0" title="0">{
                msg += fmt.Sprintf(": %s", e.Cause.Error())
        }</span>

        <span class="cov0" title="0">if len(e.Context) &gt; 0 </span><span class="cov0" title="0">{
                contextStrs := make([]string, 0, len(e.Context))
                for k, v := range e.Context </span><span class="cov0" title="0">{
                        contextStrs = append(contextStrs, fmt.Sprintf("%s=%v", k, v))
                }</span>
                <span class="cov0" title="0">msg += fmt.Sprintf(" [%s]", strings.Join(contextStrs, ", "))</span>
        }

        <span class="cov0" title="0">if e.ProcessedFile != "" </span><span class="cov0" title="0">{
                msg += fmt.Sprintf(" [File: %s]", e.ProcessedFile)
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// Unwrap implements the errors.Unwrap interface
func (e *StructuredError) Unwrap() error <span class="cov0" title="0">{
        return e.Cause
}</span>

// Helper functions to create different types of errors

// NewConfigError creates a new configuration error
func NewConfigError(message string, cause error, context map[string]interface{}, processedFile ...string) *StructuredError <span class="cov0" title="0">{
        var file string
        if len(processedFile) &gt; 0 </span><span class="cov0" title="0">{
                file = processedFile[0]
        }</span>
        <span class="cov0" title="0">return &amp;StructuredError{
                Type:          ConfigError,
                Message:       message,
                Cause:         cause,
                Context:       context,
                ProcessedFile: file,
        }</span>
}

// NewGitError creates a new Git-related error
func NewGitError(message string, cause error, context map[string]interface{}, processedFile ...string) *StructuredError <span class="cov0" title="0">{
        var file string
        if len(processedFile) &gt; 0 </span><span class="cov0" title="0">{
                file = processedFile[0]
        }</span>
        <span class="cov0" title="0">return &amp;StructuredError{
                Type:          GitError,
                Message:       message,
                Cause:         cause,
                Context:       context,
                ProcessedFile: file,
        }</span>
}

// NewAPIError creates a new API-related error
func NewAPIError(message string, cause error, context map[string]interface{}, processedFile ...string) *StructuredError <span class="cov0" title="0">{
        var file string
        if len(processedFile) &gt; 0 </span><span class="cov0" title="0">{
                file = processedFile[0]
        }</span>
        <span class="cov0" title="0">return &amp;StructuredError{
                Type:          APIError,
                Message:       message,
                Cause:         cause,
                Context:       context,
                ProcessedFile: file,
        }</span>
}

// NewValidationError creates a new validation error
func NewValidationError(message string, cause error, context map[string]interface{}, processedFile ...string) *StructuredError <span class="cov0" title="0">{
        var file string
        if len(processedFile) &gt; 0 </span><span class="cov0" title="0">{
                file = processedFile[0]
        }</span>
        <span class="cov0" title="0">return &amp;StructuredError{
                Type:          ValidationError,
                Message:       message,
                Cause:         cause,
                Context:       context,
                ProcessedFile: file,
        }</span>
}

// NewSystemError creates a new system-related error
func NewSystemError(message string, cause error, context map[string]interface{}, processedFile ...string) *StructuredError <span class="cov0" title="0">{
        var file string
        if len(processedFile) &gt; 0 </span><span class="cov0" title="0">{
                file = processedFile[0]
        }</span>
        <span class="cov0" title="0">return &amp;StructuredError{
                Type:          SystemError,
                Message:       message,
                Cause:         cause,
                Context:       context,
                ProcessedFile: file,
        }</span>
}

// NewUserError creates a new user-related error
func NewUserError(message string, cause error, context map[string]interface{}) *StructuredError <span class="cov0" title="0">{
        return &amp;StructuredError{
                Type:    UserError,
                Message: message,
                Cause:   cause,
                Context: context,
        }
}</span>

// ToUserFriendlyMessage converts an error to a user-friendly message with possible solution
func ToUserFriendlyMessage(err error) string <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Try to cast to StructuredError
        <span class="cov0" title="0">if structured, ok := err.(*StructuredError); ok </span><span class="cov0" title="0">{
                switch structured.Type </span>{
                case ConfigError:<span class="cov0" title="0">
                        return fmt.Sprintf("Configuration issue: %s\nSuggestion: Check your configuration file or run 'gitcury setup' to reconfigure.", structured.Message)</span>
                case GitError:<span class="cov0" title="0">
                        return fmt.Sprintf("Git operation failed: %s\nSuggestion: Verify that Git is installed and that you have the necessary permissions.", structured.Message)</span>
                case APIError:<span class="cov0" title="0">
                        return fmt.Sprintf("API connection issue: %s\nSuggestion: Check your internet connection and API key configuration.", structured.Message)</span>
                case ValidationError:<span class="cov0" title="0">
                        return fmt.Sprintf("Invalid input: %s\nSuggestion: Review the command syntax and parameters.", structured.Message)</span>
                case SystemError:<span class="cov0" title="0">
                        return fmt.Sprintf("System error: %s\nSuggestion: Verify that you have the necessary permissions and system resources.", structured.Message)</span>
                case UserError:<span class="cov0" title="0">
                        return fmt.Sprintf("User error: %s", structured.Message)</span>
                default:<span class="cov0" title="0">
                        return fmt.Sprintf("Error: %s", err.Error())</span>
                }
        }

        // Default error handling
        <span class="cov0" title="0">return fmt.Sprintf("Error: %s", err.Error())</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
        "os"
)

func ListFiles(directory string) ([]string, error) <span class="cov0" title="0">{
        entries, err := os.ReadDir(directory)
        if err != nil </span><span class="cov0" title="0">{
                Debug("[FILES]: 🚨 Error reading directory: " + err.Error())
                return nil, err
        }</span>

        <span class="cov0" title="0">var files []string
        for _, entry := range entries </span><span class="cov0" title="0">{
                if !entry.IsDir() </span><span class="cov0" title="0">{
                        files = append(files, entry.Name())
                }</span>
        }

        <span class="cov0" title="0">Debug("[FILES]: 📂 Successfully listed files in directory: " + directory)
        return files, nil</span>
}

func ToJSON(data interface{}) string <span class="cov0" title="0">{
        jsonData, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                Debug("[JSON]: 🚨 Error marshalling data: " + err.Error())
                return "{}"
        }</span>
        <span class="cov0" title="0">Debug("[JSON]: ✨ Successfully marshalled data to JSON")
        return string(jsonData)</span>
}

func IsNumeric(s string) bool <span class="cov0" title="0">{
        for _, char := range s </span><span class="cov0" title="0">{
                if char &lt; '0' || char &gt; '9' </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">Debug("[NUMERIC]: 🔢 String is numeric: " + s)
        return len(s) &gt; 0</span>
}

func ParseInt(s string) (int, error) <span class="cov0" title="0">{
        if !IsNumeric(s) </span><span class="cov0" title="0">{
                Error("[PARSE]: 🚨 Error parsing string to int: " + s)
                return 0, fmt.Errorf("invalid number: %s", s)
        }</span>

        <span class="cov0" title="0">result := 0
        for _, char := range s </span><span class="cov0" title="0">{
                result = result*10 + int(char-'0')
        }</span>

        <span class="cov0" title="0">Debug("[PARSE]: 🔢 Successfully parsed string to int: " + s)
        return result, nil</span>
}

func ParseFloat(s string) (float64, error) <span class="cov0" title="0">{
        var result float64
        if _, err := fmt.Sscanf(s, "%f", &amp;result); err != nil </span><span class="cov0" title="0">{
                Error("[PARSE]: 🚨 Error parsing string to float: " + s)
                return 0, fmt.Errorf("invalid float: %s", s)
        }</span>

        <span class="cov0" title="0">Debug("[PARSE]: 🔢 Successfully parsed string to float: " + s)
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package utils

import (
        "GitCury/api"
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/google/generative-ai-go/genai"
        "google.golang.org/api/option"
        "google.golang.org/grpc/status"
)

var (
        maxRetries int
        retryDelay int
)

func init() <span class="cov0" title="0">{
        // Initialize with default values
        maxRetries = 3
        retryDelay = 5
}</span>

func SetTimeoutVar(retries, delay int) <span class="cov0" title="0">{
        if retries &lt;= 0 </span><span class="cov0" title="0">{
                Warning("[GEMINI]: Invalid maxRetries value: " + fmt.Sprintf("%d", retries) + ", using default (3)")
                retries = 3
        }</span>

        <span class="cov0" title="0">if delay &lt;= 0 </span><span class="cov0" title="0">{
                Warning("[GEMINI]: Invalid retryDelay value: " + fmt.Sprintf("%d", delay) + ", using default (5)")
                delay = 5
        }</span>

        <span class="cov0" title="0">maxRetries = retries
        retryDelay = delay

        // Also update the API config
        api.SetRetryConfig(retries, delay)

        Debug(fmt.Sprintf("[GEMINI]: Updated retry settings: maxRetries=%d, retryDelay=%d", maxRetries, retryDelay))</span>
}

func printResponse(resp *genai.GenerateContentResponse) <span class="cov0" title="0">{
        if resp == nil </span><span class="cov0" title="0">{
                Debug("[GEMINI]: Response is nil")
                return
        }</span>
        <span class="cov0" title="0">for i, candidate := range resp.Candidates </span><span class="cov0" title="0">{
                if candidate == nil </span><span class="cov0" title="0">{
                        Debug(fmt.Sprintf("[GEMINI]: Candidate %d is nil", i+1))
                        continue</span>
                }
                <span class="cov0" title="0">if candidate.Content == nil </span><span class="cov0" title="0">{
                        Debug(fmt.Sprintf("[GEMINI]: Candidate %d content is nil", i+1))
                        continue</span>
                }
                <span class="cov0" title="0">if len(candidate.Content.Parts) == 0 </span><span class="cov0" title="0">{
                        Debug(fmt.Sprintf("[GEMINI]: Candidate %d has no content parts", i+1))
                        continue</span>
                }
                <span class="cov0" title="0">Debug(fmt.Sprintf("[GEMINI]: Candidate %d: %s", i+1, candidate.Content.Parts[0]))</span>
        }
}

func SendToGemini(contextData map[string]map[string]string, apiKey string, customInstructions ...string) (string, error) <span class="cov0" title="0">{
        // Validate API key with helpful guidance
        if apiKey == "" </span><span class="cov0" title="0">{
                Error("[GEMINI]: ❌ API key is empty")
                Error("🔑 GEMINI_API_KEY is required but not set!")
                Error("💡 To fix this, run one of these commands:")
                Error("   • gitcury config set --key GEMINI_API_KEY --value YOUR_API_KEY_HERE")
                Error("   • export GEMINI_API_KEY=your_api_key_here")
                Error("📖 Get your API key from: https://aistudio.google.com/app/apikey")
                return "", NewAPIError("GEMINI_API_KEY is not set", nil, map[string]interface{}{
                        "suggestion": "Set GEMINI_API_KEY using the commands shown above",
                        "docs_url":   "https://aistudio.google.com/app/apikey",
                })
        }</span>

        // Get retry configuration from API package
        <span class="cov0" title="0">maxRetries, retryDelay = api.GetRetryConfig()

        // Ensure we have sensible defaults
        if maxRetries &lt;= 0 </span><span class="cov0" title="0">{
                maxRetries = 3
        }</span>

        <span class="cov0" title="0">if retryDelay &lt;= 0 </span><span class="cov0" title="0">{
                retryDelay = 5
        }</span>

        <span class="cov0" title="0">Debug(fmt.Sprintf("[GEMINI]: 🔑 Using API key (length: %d)", len(apiKey)))
        Debug(fmt.Sprintf("[GEMINI]: ⚙️ Retry config: maxRetries=%d, retryDelay=%d", maxRetries, retryDelay))

        ctx := context.Background()
        Debug("[GEMINI]: 🔐 Initializing Gemini client...")
        client, err := genai.NewClient(ctx, option.WithAPIKey(apiKey))
        if err != nil </span><span class="cov0" title="0">{
                Error("[GEMINI]: 🚨 Failed to initialize Gemini client: " + err.Error())
                return "", NewAPIError("Failed to initialize Gemini client", err, map[string]interface{}{
                        "api_key_length": len(apiKey),
                })
        }</span>
        <span class="cov0" title="0">defer client.Close()
        Debug("[GEMINI]: ✅ Gemini client initialized successfully")

        Debug("[GEMINI]: ⚙️ Configuring Gemini model...")
        model := client.GenerativeModel("gemini-2.0-flash")
        model.SetTemperature(0.5)
        model.SetMaxOutputTokens(100)
        model.ResponseMIMEType = "application/json"
        Debug("[GEMINI]: ⚙️ Model configuration: temperature=0.5, max_tokens=100, mime=application/json")

        // Configure safety settings to be more permissive for code content
        model.SafetySettings = []*genai.SafetySetting{
                {
                        Category:  genai.HarmCategoryHarassment,
                        Threshold: genai.HarmBlockNone,
                },
                {
                        Category:  genai.HarmCategoryHateSpeech,
                        Threshold: genai.HarmBlockNone,
                },
                {
                        Category:  genai.HarmCategorySexuallyExplicit,
                        Threshold: genai.HarmBlockNone,
                },
                {
                        Category:  genai.HarmCategoryDangerousContent,
                        Threshold: genai.HarmBlockNone,
                },
        }

        // Build the system instruction with default guidelines
        baseInstruction := `
        Generate and return only a commit message as JSON with the key "message".
        Follow these guidelines for the commit message:
        • Capitalize the first word, omit final punctuation. If using conventional commits, use lowercase for the commit type.
        • Use imperative mood in the subject line.
        • Include a commit type (e.g. fix, update, refactor, bump).
        • Limit the first line to ≤ 50 characters, subsequent lines ≤ 72.
        • Be concise and direct; avoid filler words.
        • Do not include newline characters (\n) or similar formatting.

        The commit type can include the following:
        feat – a new feature
        fix – a bug fix
        chore – non-source changes
        refactor – refactored code
        docs – documentation updates
        style – formatting changes
        test – tests
        perf – performance improvements
        ci – continuous integration
        build – build system changes
        revert – revert a previous commit
        `

        // Check for user-provided custom instructions
        if len(customInstructions) &gt; 0 &amp;&amp; customInstructions[0] != "" </span><span class="cov0" title="0">{
                userInstructions := customInstructions[0]
                Debug("[GEMINI]: 📝 Found custom commit instructions")

                // Sanitize the instructions to prevent misuse (warnings handled inside function)
                sanitized := SanitizeUserInstructions(userInstructions)

                // Add user instructions at the beginning of the base instruction
                baseInstruction = `
        Generate and return only a commit message as JSON with the key "message".
        
        CUSTOM INSTRUCTIONS FROM USER:
        ` + sanitized + `
         
        Additionally, follow these guidelines strictly for the commit message:
        • Limit the first line to ≤ 50 characters, subsequent lines ≤ 72.
        • Be concise and direct; avoid filler words.
        • Do not include newline characters (\n) or similar formatting.
        `
        }</span>

        // Save the instruction for testing
        <span class="cov0" title="0">lastSystemInstruction = baseInstruction

        model.SystemInstruction = genai.NewUserContent(genai.Text(baseInstruction))

        var promptBuilder strings.Builder
        promptBuilder.WriteString("Summarize the following file changes:\n\n")
        for file, data := range contextData </span><span class="cov0" title="0">{
                promptBuilder.WriteString(fmt.Sprintf("File: %s\nType: %s\nDiff:\n%s\n\n", file, data["type"], data["diff"]))
        }</span>
        <span class="cov0" title="0">prompt := promptBuilder.String()

        // Debug logging for API request
        Debug(fmt.Sprintf("[GEMINI]: 📤 Making API request with prompt length: %d characters", len(prompt)))
        Debug(fmt.Sprintf("[GEMINI]: 📤 Context data files: %d", len(contextData)))

        Debug("[GEMINI]: Max retries set to: " + fmt.Sprintf("%d", maxRetries))

        var resp *genai.GenerateContentResponse
        var lastErr error

        // Ensure maxRetries is at least 1
        if maxRetries &lt; 1 </span><span class="cov0" title="0">{
                Debug("[GEMINI]: maxRetries was less than 1, setting to default (3)")
                maxRetries = 3
        }</span>

        <span class="cov0" title="0">for retries := 0; retries &lt; maxRetries; retries++ </span><span class="cov0" title="0">{
                Debug(fmt.Sprintf("[GEMINI]: 🔄 Attempt %d/%d - Calling GenerateContent", retries+1, maxRetries))

                resp, err = model.GenerateContent(ctx, genai.Text(prompt))
                lastErr = err

                Debug(fmt.Sprintf("[GEMINI]: 📥 API call completed. Error: %v, Response nil: %v",
                        err != nil, resp == nil))

                // Successful response
                if err == nil &amp;&amp; resp != nil &amp;&amp; len(resp.Candidates) &gt; 0 &amp;&amp;
                        resp.Candidates[0] != nil &amp;&amp; resp.Candidates[0].Content != nil &amp;&amp;
                        len(resp.Candidates[0].Content.Parts) &gt; 0 </span><span class="cov0" title="0">{
                        Debug("[GEMINI]: ✅ Received valid response")
                        break</span>
                }

                // Handle errors
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        Debug(fmt.Sprintf("[GEMINI]: ⚠️ Error received: %v", err))
                        if strings.Contains(err.Error(), "googleapi: Error 429: You exceeded your current quota") ||
                                status.Code(err) == 14 </span><span class="cov0" title="0">{ // Retry on specific 429 error or UNAVAILABLE
                                Warning("[GEMINI]: ⚠️ Quota exceeded or service unavailable. Retrying in " +
                                        fmt.Sprintf("%d", retryDelay) + " seconds... (attempt " +
                                        fmt.Sprintf("%d/%d", retries+1, maxRetries) + ")")
                        }</span> else<span class="cov0" title="0"> {
                                Debug(fmt.Sprintf("[GEMINI]: ⚠️ API error: %v. Retrying...", err))
                        }</span>
                } else<span class="cov0" title="0"> if resp == nil </span><span class="cov0" title="0">{
                        Debug("[GEMINI]: ⚠️ Received nil response. Retrying...")
                }</span> else<span class="cov0" title="0"> if len(resp.Candidates) == 0 </span><span class="cov0" title="0">{
                        Debug("[GEMINI]: ⚠️ No candidates in response. Retrying...")
                }</span> else<span class="cov0" title="0"> {
                        Debug("[GEMINI]: ⚠️ Invalid response structure. Retrying...")
                }</span>

                // Don't sleep on the last retry
                <span class="cov0" title="0">if retries &lt; maxRetries-1 </span><span class="cov0" title="0">{
                        Debug(fmt.Sprintf("[GEMINI]: 😴 Sleeping for %d seconds before next retry...", retryDelay))
                        time.Sleep(time.Duration(retryDelay) * time.Second)
                }</span>
        }

        // If we still have an error after all retries, return it
        <span class="cov0" title="0">if lastErr != nil </span><span class="cov0" title="0">{
                return "", NewAPIError("Failed to generate content from Gemini after "+
                        fmt.Sprintf("%d", maxRetries)+" attempts", lastErr, map[string]interface{}{
                        "retries_attempted": maxRetries,
                })
        }</span>

        // Comprehensive response validation
        <span class="cov0" title="0">if resp == nil </span><span class="cov0" title="0">{
                Error("[GEMINI]: ❌ Received nil response from Gemini API.")
                return "", NewAPIError("Received nil response from Gemini API", nil, map[string]interface{}{
                        "context_files": len(contextData),
                })
        }</span>

        <span class="cov0" title="0">if len(resp.Candidates) == 0 </span><span class="cov0" title="0">{
                Error("[GEMINI]: ❌ No candidates returned by Gemini.")
                return "", NewAPIError("No candidates returned by Gemini API", nil, map[string]interface{}{
                        "context_files":   len(contextData),
                        "prompt_feedback": fmt.Sprintf("%+v", resp.PromptFeedback),
                })
        }</span>

        <span class="cov0" title="0">candidate := resp.Candidates[0]
        if candidate == nil </span><span class="cov0" title="0">{
                Error("[GEMINI]: ❌ First candidate is nil.")
                return "", NewAPIError("First candidate is nil", nil, map[string]interface{}{
                        "total_candidates": len(resp.Candidates),
                })
        }</span>

        <span class="cov0" title="0">if candidate.Content == nil </span><span class="cov0" title="0">{
                Error("[GEMINI]: ❌ Candidate content is nil.")
                return "", NewAPIError("Candidate content is nil", nil, map[string]interface{}{
                        "finish_reason":  fmt.Sprintf("%v", candidate.FinishReason),
                        "safety_ratings": fmt.Sprintf("%+v", candidate.SafetyRatings),
                })
        }</span>

        <span class="cov0" title="0">if len(candidate.Content.Parts) == 0 </span><span class="cov0" title="0">{
                Error("[GEMINI]: ❌ No content parts in candidate.")
                return "", NewAPIError("No content parts in candidate", nil, map[string]interface{}{
                        "content_role": candidate.Content.Role,
                })
        }</span>

        <span class="cov0" title="0">respMessage := fmt.Sprintf(`%s`, candidate.Content.Parts[0])
        if respMessage == "" </span><span class="cov0" title="0">{
                Error("[GEMINI]: ❌ Empty content returned from Gemini.")
                return "", NewAPIError("Empty content returned from Gemini", nil, map[string]interface{}{
                        "parts_count": len(candidate.Content.Parts),
                })
        }</span>

        <span class="cov0" title="0">Debug("[GEMINI]: ✨ Response received: " + respMessage)

        // First try to parse as JSON with "message" key
        var result map[string]string
        err = json.Unmarshal([]byte(respMessage), &amp;result)
        if err == nil </span><span class="cov0" title="0">{
                // Successfully parsed as JSON object
                if message, ok := result["message"]; ok </span><span class="cov0" title="0">{
                        return message, nil
                }</span>
                // JSON object but no "message" key, fall through to treat as plain text
                <span class="cov0" title="0">Debug("[GEMINI]: JSON response missing 'message' key, treating as plain text")</span>
        } else<span class="cov0" title="0"> {
                // Failed to parse as JSON object, check if it's an array or other format
                Debug("[GEMINI]: Failed to parse as JSON object, treating as plain text: " + err.Error())
        }</span>

        // If JSON parsing failed or no "message" key found, treat the entire response as the message
        // This handles cases where Gemini returns plain text or unexpected JSON format
        <span class="cov0" title="0">trimmedResponse := strings.TrimSpace(respMessage)
        if trimmedResponse == "" </span><span class="cov0" title="0">{
                Error("[GEMINI]: ❌ Empty response after trimming.")
                return "", NewAPIError("Empty response after trimming", nil, map[string]interface{}{
                        "raw_response": respMessage,
                })
        }</span>

        <span class="cov0" title="0">return trimmedResponse, nil</span>
}

// Keep track of the last system instruction for testing
var lastSystemInstruction string

// GetLastSystemInstruction returns the last system instruction used (for testing)
func GetLastSystemInstruction() string <span class="cov0" title="0">{
        return lastSystemInstruction
}</span>

// SanitizeUserInstructions cleans potentially harmful or manipulative instructions
func SanitizeUserInstructions(instructions string) string <span class="cov0" title="0">{
        // Filter out potential prompt injection attempts
        blockedPhrases := []string{
                "ignore all previous instructions",
                "ignore previous instructions",
                "disregard the above",
                "do not follow",
                "override",
                "&lt;script&gt;",
                "&lt;/script&gt;",
                "function(",
                "eval(",
                "exec(",
                "system(",
                "shell",
                "bash",
                "cmd",
                "powershell",
        }

        sanitized := instructions
        actuallyFiltered := false

        // Check each blocked phrase case-insensitively but preserve original case
        for _, phrase := range blockedPhrases </span><span class="cov0" title="0">{
                lowered := strings.ToLower(sanitized)
                phrasePos := strings.Index(lowered, strings.ToLower(phrase))
                if phrasePos != -1 </span><span class="cov0" title="0">{
                        // Replace the actual occurrence with [filtered]
                        before := sanitized[:phrasePos]
                        after := sanitized[phrasePos+len(phrase):]
                        sanitized = before + "[filtered]" + after
                        actuallyFiltered = true
                }</span>
        }

        // Ensure instructions aren't too long
        <span class="cov0" title="0">truncated := false
        if len(sanitized) &gt; 500 </span><span class="cov0" title="0">{
                sanitized = sanitized[:500] + "..."
                truncated = true
        }</span>

        // Only warn if we actually filtered something harmful or truncated
        <span class="cov0" title="0">if actuallyFiltered </span><span class="cov0" title="0">{
                Warning("[GEMINI]: ⚠️ User commit instructions contained potentially harmful content and were sanitized for safety")
        }</span> else<span class="cov0" title="0"> if truncated </span><span class="cov0" title="0">{
                Debug("[GEMINI]: ℹ️ User commit instructions were truncated due to length limit")
        }</span>

        <span class="cov0" title="0">return sanitized</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package utils

import (
        "fmt"
        "log"
        "runtime"
        "strings"
)

// ANSI color codes - Dark Tech palette
const (
        Reset     = "\033[0m"
        Red       = "\033[38;5;196m" // Bright red
        Green     = "\033[38;5;46m"  // Neon green
        Yellow    = "\033[38;5;226m" // Warning yellow
        Blue      = "\033[38;5;33m"  // Electric blue
        Magenta   = "\033[38;5;201m" // Cyber pink
        Cyan      = "\033[38;5;51m"  // Holographic cyan
        Black     = "\033[38;5;236m" // Dark background
        Bold      = "\033[1m"
        Underline = "\033[4m"
        Blink     = "\033[5m" // Use sparingly!
        Dim       = "\033[2m"
        BlackBg   = "\033[48;5;235m" // Dark background
)

var LogLevel string = "info"

func SetLogLevel(level string) <span class="cov0" title="0">{
        LogLevel = level
}</span>

// Debug logs a message at the debug level
func Debug(message string) <span class="cov0" title="0">{
        if LogLevel != "debug" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Printf("\n%s%s[SCAN    ] 🔍 %s %s\n", Cyan, BlackBg, Reset, message)</span>
}

// Info logs a message at the info level
func Info(message string) <span class="cov0" title="0">{
        if LogLevel == "error" </span><span class="cov0" title="0">{
                return // Suppress info messages in quiet mode
        }</span>
        <span class="cov0" title="0">fmt.Printf("\n%s%s[SYS     ] ⚡ %s %s\n", Green, BlackBg, Reset, message)</span>
}

// Success logs a success message
func Success(message string) <span class="cov0" title="0">{
        // Always show success messages, even in quiet mode
        fmt.Printf("\n%s%s[SUCCESS ] 💻 %s %s\n", Green, BlackBg, Reset, message)
}</span>

// Error logs error message
func Error(message string, fileContext ...string) <span class="cov0" title="0">{
        _, file, line, ok := runtime.Caller(1)
        if ok </span><span class="cov0" title="0">{
                shortFile := file
                if parts := strings.Split(file, "/"); len(parts) &gt; 2 </span><span class="cov0" title="0">{
                        shortFile = parts[len(parts)-2] + "/" + parts[len(parts)-1]
                }</span>

                // Add file context if provided
                <span class="cov0" title="0">fileInfo := ""
                if len(fileContext) &gt; 0 &amp;&amp; fileContext[0] != "" </span><span class="cov0" title="0">{
                        fileInfo = fmt.Sprintf(" [File: %s]", fileContext[0])
                }</span>

                <span class="cov0" title="0">log.Printf("\n%s%s[BREACH  ] ⚠️ %s %s%s (at %s:%d)\n", Red, BlackBg, Reset, message, fileInfo, shortFile, line)</span>
        } else<span class="cov0" title="0"> {
                fileInfo := ""
                if len(fileContext) &gt; 0 &amp;&amp; fileContext[0] != "" </span><span class="cov0" title="0">{
                        fileInfo = fmt.Sprintf(" [File: %s]", fileContext[0])
                }</span>
                <span class="cov0" title="0">log.Printf("\n%s%s[BREACH  ] ⚠️ %s %s%s\n", Red, BlackBg, Reset, message, fileInfo)</span>
        }
}

// Warning logs warning message
func Warning(message string) <span class="cov0" title="0">{
        if LogLevel == "error" </span><span class="cov0" title="0">{
                return // Suppress warning messages in quiet mode
        }</span>
        <span class="cov0" title="0">fmt.Printf("\n%s%s[ALERT   ] 🔥 %s %s\n", Yellow, BlackBg, Reset, message)</span>
}

// Print outputs data to the CLI
func Print(data string) <span class="cov0" title="0">{
        fmt.Printf("\n%s%s%s\n", Cyan, data, Reset)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package utils

import (
        "fmt"
        "io"
        "os"
        "strings"
        "sync"
        "time"
)

// ProgressReporter provides an interface for reporting progress of long-running operations
type ProgressReporter struct {
        total         int64
        current       int64
        start         time.Time
        lastUpdate    time.Time
        updateMu      sync.Mutex
        message       string
        finished      bool
        width         int
        writer        io.Writer
        hideInQuiet   bool
        updateFreq    time.Duration
        progressChar  string
        spinnerChars  []string
        spinnerPos    int
        spinnerActive bool
        spinnerTicker *time.Ticker
        spinnerDone   chan struct{}
}

// NewProgressReporter creates a new progress reporter
func NewProgressReporter(total int64, message string) *ProgressReporter <span class="cov0" title="0">{
        return &amp;ProgressReporter{
                total:        total,
                current:      0,
                start:        time.Now(),
                lastUpdate:   time.Now(),
                message:      message,
                finished:     false,
                width:        50,
                writer:       os.Stdout,
                hideInQuiet:  true,
                updateFreq:   200 * time.Millisecond,
                progressChar: "■",
                spinnerChars: []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"},
                spinnerPos:   0,
        }
}</span>

// NewIndeterminateProgressReporter creates a progress reporter for operations
// where the total amount of work is unknown
func NewIndeterminateProgressReporter(message string) *ProgressReporter <span class="cov0" title="0">{
        p := NewProgressReporter(-1, message)
        return p
}</span>

// SetWidth sets the width of the progress bar
func (p *ProgressReporter) SetWidth(width int) *ProgressReporter <span class="cov0" title="0">{
        p.width = width
        return p
}</span>

// SetWriter sets the io.Writer where progress updates are written
func (p *ProgressReporter) SetWriter(writer io.Writer) *ProgressReporter <span class="cov0" title="0">{
        p.writer = writer
        return p
}</span>

// SetHideInQuiet sets whether the progress bar should be hidden in quiet mode
func (p *ProgressReporter) SetHideInQuiet(hide bool) *ProgressReporter <span class="cov0" title="0">{
        p.hideInQuiet = hide
        return p
}</span>

// Start begins the progress reporting
func (p *ProgressReporter) Start() *ProgressReporter <span class="cov0" title="0">{
        p.updateMu.Lock()
        defer p.updateMu.Unlock()

        p.start = time.Now()
        p.lastUpdate = time.Now()
        p.finished = false

        // Start spinner for indeterminate progress
        if p.total &lt; 0 </span><span class="cov0" title="0">{
                p.spinnerActive = true
                p.spinnerDone = make(chan struct{})
                p.spinnerTicker = time.NewTicker(100 * time.Millisecond)

                go func() </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-p.spinnerTicker.C:<span class="cov0" title="0">
                                        p.updateMu.Lock()
                                        if p.spinnerActive </span><span class="cov0" title="0">{
                                                p.spinnerPos = (p.spinnerPos + 1) % len(p.spinnerChars)
                                                p.renderSpinner()
                                        }</span>
                                        <span class="cov0" title="0">p.updateMu.Unlock()</span>
                                case &lt;-p.spinnerDone:<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }()
        } else<span class="cov0" title="0"> {
                // Render the initial progress bar
                p.render()
        }</span>

        <span class="cov0" title="0">return p</span>
}

// Update updates the current progress
func (p *ProgressReporter) Update(current int64) <span class="cov0" title="0">{
        p.updateMu.Lock()
        defer p.updateMu.Unlock()

        if p.finished </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">p.current = current

        // Only update if enough time has passed since last update
        if time.Since(p.lastUpdate) &gt;= p.updateFreq </span><span class="cov0" title="0">{
                if p.total &lt; 0 </span><span class="cov0" title="0">{
                        // Indeterminate progress uses spinner
                        return
                }</span>

                // Render the progress bar
                <span class="cov0" title="0">p.render()
                p.lastUpdate = time.Now()</span>
        }
}

// UpdateMessage updates the message displayed with the progress bar
func (p *ProgressReporter) UpdateMessage(message string) <span class="cov0" title="0">{
        p.updateMu.Lock()
        defer p.updateMu.Unlock()

        if p.finished </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">p.message = message

        if p.total &lt; 0 </span><span class="cov0" title="0">{
                p.renderSpinner()
        }</span> else<span class="cov0" title="0"> {
                p.render()
        }</span>

        <span class="cov0" title="0">p.lastUpdate = time.Now()</span>
}

// Increment increases the current progress by the specified amount
func (p *ProgressReporter) Increment(amount int64) <span class="cov0" title="0">{
        p.Update(p.current + amount)
}</span>

// Done completes the progress reporting
func (p *ProgressReporter) Done() <span class="cov0" title="0">{
        p.updateMu.Lock()
        defer p.updateMu.Unlock()

        if p.finished </span><span class="cov0" title="0">{
                return
        }</span>

        // If this is a spinner, stop it
        <span class="cov0" title="0">if p.total &lt; 0 &amp;&amp; p.spinnerActive </span><span class="cov0" title="0">{
                p.spinnerActive = false
                p.spinnerTicker.Stop()
                close(p.spinnerDone)

                // Clear the spinner line
                fmt.Fprintf(p.writer, "\r%s\r", strings.Repeat(" ", 80))
        }</span> else<span class="cov0" title="0"> if p.total &gt;= 0 </span><span class="cov0" title="0">{
                // Make sure we show 100% completion
                p.current = p.total
                p.render()
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(p.writer)
        p.finished = true</span>
}

// render displays the current progress bar
func (p *ProgressReporter) render() <span class="cov0" title="0">{
        if p.hideInQuiet &amp;&amp; IsQuietMode() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">percent := float64(p.current) / float64(p.total) * 100
        if percent &gt; 100 </span><span class="cov0" title="0">{
                percent = 100
        }</span>

        <span class="cov0" title="0">elapsed := time.Since(p.start)

        // Calculate ETA
        var etaStr string
        if p.current &gt; 0 </span><span class="cov0" title="0">{
                itemsPerSecond := float64(p.current) / elapsed.Seconds()
                if itemsPerSecond &gt; 0 </span><span class="cov0" title="0">{
                        remainingItems := p.total - p.current
                        etaSeconds := float64(remainingItems) / itemsPerSecond
                        eta := time.Duration(etaSeconds) * time.Second
                        if eta &gt; 0 </span><span class="cov0" title="0">{
                                etaStr = fmt.Sprintf(" ETA: %s", formatDuration(eta))
                        }</span>
                }
        }

        // Build progress bar
        <span class="cov0" title="0">width := p.width
        completed := int(float64(width) * float64(p.current) / float64(p.total))

        progressBar := strings.Repeat(p.progressChar, completed) + strings.Repeat("░", width-completed)

        // Format and print the progress line
        fmt.Fprintf(
                p.writer,
                "\r%s [%s] %.1f%% (%d/%d)%s",
                p.message,
                progressBar,
                percent,
                p.current,
                p.total,
                etaStr,
        )</span>
}

// renderSpinner displays the spinner for indeterminate progress
func (p *ProgressReporter) renderSpinner() <span class="cov0" title="0">{
        if p.hideInQuiet &amp;&amp; IsQuietMode() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">spinner := p.spinnerChars[p.spinnerPos]
        elapsed := formatDuration(time.Since(p.start))

        fmt.Fprintf(
                p.writer,
                "\r%s %s [%s]",
                spinner,
                p.message,
                elapsed,
        )</span>
}

// formatDuration formats a duration in a user-friendly way
func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d &lt; time.Minute </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1fs", d.Seconds())
        }</span> else<span class="cov0" title="0"> if d &lt; time.Hour </span><span class="cov0" title="0">{
                minutes := int(d.Minutes())
                seconds := int(d.Seconds()) % 60
                return fmt.Sprintf("%dm%ds", minutes, seconds)
        }</span> else<span class="cov0" title="0"> {
                hours := int(d.Hours())
                minutes := int(d.Minutes()) % 60
                return fmt.Sprintf("%dh%dm", hours, minutes)
        }</span>
}

// Global quiet mode flag
var quietMode bool
var quietModeOnce sync.Once
var quietModeMu sync.RWMutex

// SetQuietMode sets the global quiet mode flag
func SetQuietMode(quiet bool) <span class="cov0" title="0">{
        quietModeOnce.Do(func() </span><span class="cov0" title="0">{
                quietModeMu.Lock()
                quietMode = quiet
                quietModeMu.Unlock()
        }</span>)
}

// IsQuietMode returns whether quiet mode is enabled
func IsQuietMode() bool <span class="cov0" title="0">{
        quietModeMu.RLock()
        defer quietModeMu.RUnlock()
        return quietMode
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package utils

import (
        "bufio"
        "fmt"
        "os"
        "strings"
)

// ConfirmAction asks the user to confirm an action with yes/no prompt
func ConfirmAction(message string, defaultYes bool) bool <span class="cov0" title="0">{
        // Skip confirmation in non-interactive environments
        if os.Getenv("GITCURY_NONINTERACTIVE") == "1" </span><span class="cov0" title="0">{
                return defaultYes
        }</span>

        <span class="cov0" title="0">prompt := message + " "
        if defaultYes </span><span class="cov0" title="0">{
                prompt += "[Y/n]: "
        }</span> else<span class="cov0" title="0"> {
                prompt += "[y/N]: "
        }</span>

        <span class="cov0" title="0">fmt.Print(prompt)

        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                Warning("[CONFIRM]: Error reading input, using default: " + err.Error())
                return defaultYes
        }</span>

        <span class="cov0" title="0">response = strings.TrimSpace(strings.ToLower(response))

        if response == "" </span><span class="cov0" title="0">{
                return defaultYes
        }</span>

        <span class="cov0" title="0">return response == "y" || response == "yes"</span>
}

// ConfirmActionWithDetails asks for confirmation and shows detailed information
func ConfirmActionWithDetails(action string, details []string, defaultYes bool) bool <span class="cov0" title="0">{
        fmt.Println("📝 " + action)

        if len(details) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Details:")
                for _, detail := range details </span><span class="cov0" title="0">{
                        fmt.Println("  • " + detail)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">return ConfirmAction("Do you want to continue?", defaultYes)</span>
}

// PromptForInput asks the user for text input with an optional default value
func PromptForInput(message string, defaultValue string) string <span class="cov0" title="0">{
        // Show default value in prompt if provided
        prompt := message
        if defaultValue != "" </span><span class="cov0" title="0">{
                prompt += fmt.Sprintf(" [default: %s]", defaultValue)
        }</span>
        <span class="cov0" title="0">prompt += ": "

        fmt.Print(prompt)

        reader := bufio.NewReader(os.Stdin)
        input, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                Warning("[PROMPT]: Error reading input, using default: " + err.Error())
                return defaultValue
        }</span>

        <span class="cov0" title="0">input = strings.TrimSpace(input)

        if input == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>

        <span class="cov0" title="0">return input</span>
}

// PromptForSelection asks the user to select from a list of options
func PromptForSelection(message string, options []string, defaultIndex int) (string, int) <span class="cov0" title="0">{
        if len(options) == 0 </span><span class="cov0" title="0">{
                return "", -1
        }</span>

        // Default to first item if default index is invalid
        <span class="cov0" title="0">if defaultIndex &lt; 0 || defaultIndex &gt;= len(options) </span><span class="cov0" title="0">{
                defaultIndex = 0
        }</span>

        <span class="cov0" title="0">fmt.Println(message)
        for i, option := range options </span><span class="cov0" title="0">{
                marker := " "
                if i == defaultIndex </span><span class="cov0" title="0">{
                        marker = "*"
                }</span>
                <span class="cov0" title="0">fmt.Printf("  %s %d) %s\n", marker, i+1, option)</span>
        }

        <span class="cov0" title="0">selectedIndex := -1

        for selectedIndex &lt; 0 || selectedIndex &gt;= len(options) </span><span class="cov0" title="0">{
                input := PromptForInput("Enter number", fmt.Sprintf("%d", defaultIndex+1))

                // Try to parse as number
                var parsedIndex int
                _, err := fmt.Sscanf(input, "%d", &amp;parsedIndex)
                if err != nil || parsedIndex &lt; 1 || parsedIndex &gt; len(options) </span><span class="cov0" title="0">{
                        fmt.Printf("Please enter a number between 1 and %d\n", len(options))
                        continue</span>
                }

                <span class="cov0" title="0">selectedIndex = parsedIndex - 1</span>
        }

        <span class="cov0" title="0">return options[selectedIndex], selectedIndex</span>
}

// ShowProgressiveConfirmation shows a multi-step confirmation dialog
// where each step depends on the previous one
func ShowProgressiveConfirmation(steps []string, actions []func() error) error <span class="cov0" title="0">{
        if len(steps) != len(actions) </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch between steps (%d) and actions (%d)", len(steps), len(actions))
        }</span>

        <span class="cov0" title="0">for i, step := range steps </span><span class="cov0" title="0">{
                if !ConfirmAction(fmt.Sprintf("Step %d/%d: %s", i+1, len(steps), step), true) </span><span class="cov0" title="0">{
                        return fmt.Errorf("action cancelled by user at step %d", i+1)
                }</span>

                <span class="cov0" title="0">Info(fmt.Sprintf("Executing step %d/%d: %s", i+1, len(steps), step))
                if err := actions[i](); err != nil </span><span class="cov0" title="0">{
                        Error(fmt.Sprintf("Step %d failed: %s", i+1, err.Error()))
                        return err
                }</span>

                <span class="cov0" title="0">Success(fmt.Sprintf("Step %d/%d completed successfully", i+1, len(steps)))</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package utils

import (
        "fmt"
        "runtime"
        "sync"
        "time"
)

// ResourceManager monitors and manages system resources for the application
type ResourceManager struct {
        maxMemoryPercent float64
        maxCPUPercent    float64
        checkInterval    time.Duration

        // State
        running      bool
        stopChan     chan struct{}
        resourceLock sync.RWMutex

        // Metrics
        memStats         runtime.MemStats
        lastMemoryUsage  uint64
        lastCPUUsage     float64
        lastChecked      time.Time
        resourceWarnings int
}

// NewResourceManager creates a resource manager with default settings
func NewResourceManager() *ResourceManager <span class="cov0" title="0">{
        return &amp;ResourceManager{
                maxMemoryPercent: 80.0, // Default to 80% max memory usage
                maxCPUPercent:    90.0, // Default to 90% max CPU usage
                checkInterval:    5 * time.Second,
                stopChan:         make(chan struct{}),
                resourceWarnings: 0,
                lastChecked:      time.Now(),
        }
}</span>

// SetMaxMemoryPercent sets the maximum allowed memory usage as a percentage
func (rm *ResourceManager) SetMaxMemoryPercent(percent float64) <span class="cov0" title="0">{
        if percent &lt;= 0 || percent &gt; 100 </span><span class="cov0" title="0">{
                Warning("Invalid memory percent value, using default")
                percent = 80.0
        }</span>
        <span class="cov0" title="0">rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()
        rm.maxMemoryPercent = percent</span>
}

// SetMaxCPUPercent sets the maximum allowed CPU usage as a percentage
func (rm *ResourceManager) SetMaxCPUPercent(percent float64) <span class="cov0" title="0">{
        if percent &lt;= 0 || percent &gt; 100 </span><span class="cov0" title="0">{
                Warning("Invalid CPU percent value, using default")
                percent = 90.0
        }</span>
        <span class="cov0" title="0">rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()
        rm.maxCPUPercent = percent</span>
}

// SetCheckInterval sets how often resources are checked
func (rm *ResourceManager) SetCheckInterval(interval time.Duration) <span class="cov0" title="0">{
        if interval &lt; time.Second </span><span class="cov0" title="0">{
                Warning("Check interval too small, using minimum of 1 second")
                interval = time.Second
        }</span>
        <span class="cov0" title="0">rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()
        rm.checkInterval = interval</span>
}

// Start begins monitoring system resources
func (rm *ResourceManager) Start() <span class="cov0" title="0">{
        rm.resourceLock.Lock()
        if rm.running </span><span class="cov0" title="0">{
                rm.resourceLock.Unlock()
                return
        }</span>
        <span class="cov0" title="0">rm.running = true
        rm.resourceLock.Unlock()

        Debug("[RESOURCE]: Resource monitoring started")

        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(rm.checkInterval)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                rm.checkResources()</span>
                        case &lt;-rm.stopChan:<span class="cov0" title="0">
                                Debug("[RESOURCE]: Resource monitoring stopped")
                                return</span>
                        }
                }
        }()
}

// Stop ends resource monitoring
func (rm *ResourceManager) Stop() <span class="cov0" title="0">{
        rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()

        if !rm.running </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">rm.running = false
        rm.stopChan &lt;- struct{}{}</span>
}

// IsRunning returns whether resource monitoring is active
func (rm *ResourceManager) IsRunning() bool <span class="cov0" title="0">{
        rm.resourceLock.RLock()
        defer rm.resourceLock.RUnlock()
        return rm.running
}</span>

// GetResourceUsage returns the current resource usage metrics
func (rm *ResourceManager) GetResourceUsage() map[string]interface{} <span class="cov0" title="0">{
        rm.resourceLock.RLock()
        defer rm.resourceLock.RUnlock()

        // Force an update of the metrics
        runtime.ReadMemStats(&amp;rm.memStats)

        return map[string]interface{}{
                "memoryUsageMB":    rm.memStats.Alloc / 1024 / 1024,
                "totalMemoryMB":    rm.memStats.Sys / 1024 / 1024,
                "numGoroutines":    runtime.NumGoroutine(),
                "resourceWarnings": rm.resourceWarnings,
                "lastChecked":      rm.lastChecked,
                "maxMemoryPercent": rm.maxMemoryPercent,
                "maxCPUPercent":    rm.maxCPUPercent,
        }
}</span>

// checkResources examines current resource usage and takes action if thresholds are exceeded
func (rm *ResourceManager) checkResources() <span class="cov0" title="0">{
        rm.resourceLock.Lock()
        defer rm.resourceLock.Unlock()

        rm.lastChecked = time.Now()

        // Get current memory stats
        runtime.ReadMemStats(&amp;rm.memStats)

        // Check memory usage
        totalMemory := rm.memStats.Sys
        usedMemory := rm.memStats.Alloc
        memoryPercent := float64(usedMemory) / float64(totalMemory) * 100

        // Check CPU usage (simplified since Go doesn't provide direct CPU usage)
        numGoroutines := runtime.NumGoroutine()

        // Store current values
        rm.lastMemoryUsage = usedMemory

        // Log resource usage in debug mode
        Debug(fmt.Sprintf("[RESOURCE]: Memory: %.2f%% (%d MB / %d MB), Goroutines: %d",
                memoryPercent, usedMemory/1024/1024, totalMemory/1024/1024, numGoroutines))

        // Check if we're exceeding thresholds
        if memoryPercent &gt; rm.maxMemoryPercent </span><span class="cov0" title="0">{
                rm.resourceWarnings++
                Warning(fmt.Sprintf("[RESOURCE.WARNING]: Memory usage is high: %.2f%% (threshold: %.2f%%)",
                        memoryPercent, rm.maxMemoryPercent))

                // Take action - force garbage collection if memory usage is critical
                if memoryPercent &gt; rm.maxMemoryPercent+10 </span><span class="cov0" title="0">{
                        Info("[RESOURCE]: Forcing garbage collection due to high memory usage")
                        runtime.GC()
                }</span>
        }

        // Check if number of goroutines is unusually high (simplistic approach)
        <span class="cov0" title="0">if numGoroutines &gt; 1000 </span><span class="cov0" title="0">{
                rm.resourceWarnings++
                Warning(fmt.Sprintf("[RESOURCE.WARNING]: High number of goroutines: %d", numGoroutines))
        }</span>
}

// GetRecommendedWorkerCount returns the recommended number of worker goroutines
// based on current system load and available CPU cores
func (rm *ResourceManager) GetRecommendedWorkerCount(defaultWorkers int) int <span class="cov0" title="0">{
        rm.resourceLock.RLock()
        defer rm.resourceLock.RUnlock()

        // Get number of CPU cores
        numCPU := runtime.NumCPU()

        // Calculate recommended worker count
        var recommendedWorkers int

        // If we're under resource pressure, reduce worker count
        if rm.resourceWarnings &gt; 5 </span><span class="cov0" title="0">{
                // Under significant resource pressure
                recommendedWorkers = max(1, numCPU/4)
        }</span> else<span class="cov0" title="0"> if rm.resourceWarnings &gt; 0 </span><span class="cov0" title="0">{
                // Under mild resource pressure
                recommendedWorkers = max(1, numCPU/2)
        }</span> else<span class="cov0" title="0"> {
                // No resource pressure, use 75% of available cores
                recommendedWorkers = max(1, (numCPU*3)/4)
        }</span>

        // If defaultWorkers is specified and smaller than our calculation, use that instead
        <span class="cov0" title="0">if defaultWorkers &gt; 0 &amp;&amp; defaultWorkers &lt; recommendedWorkers </span><span class="cov0" title="0">{
                recommendedWorkers = defaultWorkers
        }</span>

        <span class="cov0" title="0">return recommendedWorkers</span>
}

// Default instance
var defaultResourceManager *ResourceManager
var rmOnce sync.Once

// GetResourceManager returns the default resource manager instance
func GetResourceManager() *ResourceManager <span class="cov0" title="0">{
        rmOnce.Do(func() </span><span class="cov0" title="0">{
                defaultResourceManager = NewResourceManager()
        }</span>)
        <span class="cov0" title="0">return defaultResourceManager</span>
}

// Helper function for Go &lt; 1.21
func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package utils

import (
        "context"
        "fmt"
        "runtime/debug"
        "time"
)

// SafeExecute runs a function with panic recovery
func SafeExecute(operation string, fn func() error) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        Debug("[RECOVERY]: Recovered from panic in " + operation)
                        Debug("[RECOVERY]: Stack trace:\n" + string(debug.Stack()))

                        switch x := r.(type) </span>{
                        case string:<span class="cov0" title="0">
                                err = NewSystemError("Panic occurred", fmt.Errorf("%s", x), map[string]interface{}{
                                        "operation": operation,
                                })</span>
                        case error:<span class="cov0" title="0">
                                err = NewSystemError("Panic occurred", x, map[string]interface{}{
                                        "operation": operation,
                                })</span>
                        default:<span class="cov0" title="0">
                                err = NewSystemError("Panic occurred", fmt.Errorf("%v", x), map[string]interface{}{
                                        "operation": operation,
                                })</span>
                        }
                }
        }()

        <span class="cov0" title="0">return fn()</span>
}

// RetryConfig holds the configuration for retry operations
type RetryConfig struct {
        MaxRetries   int
        InitialDelay time.Duration
        MaxDelay     time.Duration
        Factor       float64 // Exponential backoff factor
}

// DefaultRetryConfig returns the default retry configuration
func DefaultRetryConfig() RetryConfig <span class="cov0" title="0">{
        return RetryConfig{
                MaxRetries:   3,
                InitialDelay: 1 * time.Second,
                MaxDelay:     30 * time.Second,
                Factor:       2.0,
        }
}</span>

// WithRetry executes a function with automatic retries using exponential backoff
func WithRetry(ctx context.Context, operation string, config RetryConfig, fn func() error) error <span class="cov0" title="0">{
        var lastErr error
        delay := config.InitialDelay

        for attempt := 0; attempt &lt;= config.MaxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        Debug(fmt.Sprintf("[RETRY]: Attempt %d/%d for operation '%s' after delay of %v",
                                attempt, config.MaxRetries, operation, delay))
                }</span>

                <span class="cov0" title="0">err := SafeExecute(operation, fn)
                if err == nil </span><span class="cov0" title="0">{
                        if attempt &gt; 0 </span><span class="cov0" title="0">{
                                Debug(fmt.Sprintf("[RETRY]: Operation '%s' succeeded after %d attempts",
                                        operation, attempt+1))
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">lastErr = err
                Debug(fmt.Sprintf("[RETRY]: Operation '%s' failed (attempt %d/%d): %v",
                        operation, attempt+1, config.MaxRetries, err))

                // Don't sleep if this was the last attempt
                if attempt == config.MaxRetries </span><span class="cov0" title="0">{
                        break</span>
                }

                // Check if context is cancelled before sleeping
                <span class="cov0" title="0">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return NewSystemError(
                                "Operation cancelled",
                                ctx.Err(),
                                map[string]interface{}{
                                        "operation": operation,
                                        "attempts":  attempt + 1,
                                },
                        )</span>
                case &lt;-time.After(delay):<span class="cov0" title="0">
                        // Calculate next delay with exponential backoff
                        delay = time.Duration(float64(delay) * config.Factor)
                        if delay &gt; config.MaxDelay </span><span class="cov0" title="0">{
                                delay = config.MaxDelay
                        }</span>
                }
        }

        <span class="cov0" title="0">return NewSystemError(
                fmt.Sprintf("Operation failed after %d attempts", config.MaxRetries+1),
                lastErr,
                map[string]interface{}{
                        "operation":  operation,
                        "maxRetries": config.MaxRetries,
                },
        )</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package utils

import (
        "fmt"
        "runtime"
        "sync"
        "time"

        "github.com/spf13/cobra"
)

var (
        statsEnabled      = false
        statsMutex        sync.RWMutex
        commandStartTime  time.Time
        operationProgress = make(map[string]ProgressInfo)
        totalOperations   int
        completedOps      int
        clusteringInfo    *ClusteringMethodInfo // New field for clustering info
)

type ProgressInfo struct {
        Name      string
        StartTime time.Time
        EndTime   *time.Time
        Duration  time.Duration
        Progress  float64
        Status    string
}

type ClusteringMethodInfo struct {
        Method                string             `json:"method"`
        EnabledMethods        []string           `json:"enabledMethods"`
        ConfidenceThresholds  map[string]float64 `json:"confidenceThresholds"`
        SimilarityThresholds  map[string]float64 `json:"similarityThresholds"`
        MaxFilesForSemantic   int                `json:"maxFilesForSemantic"`
        EnableFallbackMethods bool               `json:"enableFallbackMethods"`
        PerformanceMode       string             `json:"performanceMode"`
        MaxProcessingTime     int                `json:"maxProcessingTime"`
        EnableBenchmarking    bool               `json:"enableBenchmarking"`
        AdaptiveOptimization  bool               `json:"adaptiveOptimization"`
}

type CommandStats struct {
        Command        string
        StartTime      time.Time
        EndTime        time.Time
        Duration       time.Duration
        Operations     []ProgressInfo
        TotalOps       int
        CompletedOps   int
        SuccessRate    float64
        MemoryUsed     string
        CPUTime        string
        ClusteringInfo *ClusteringMethodInfo // New field for clustering info
}

// EnableStats turns on statistics tracking
func EnableStats() <span class="cov0" title="0">{
        statsMutex.Lock()
        defer statsMutex.Unlock()
        statsEnabled = true
        commandStartTime = time.Now()
        operationProgress = make(map[string]ProgressInfo)
        totalOperations = 0
        completedOps = 0
        Info("📊 Statistics tracking enabled")
}</span>

// IsStatsEnabled returns whether stats tracking is currently enabled
func IsStatsEnabled() bool <span class="cov0" title="0">{
        statsMutex.RLock()
        defer statsMutex.RUnlock()
        return statsEnabled
}</span>

// StartOperation tracks the start of an operation
func StartOperation(name string) <span class="cov0" title="0">{
        if !IsStatsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">statsMutex.Lock()
        defer statsMutex.Unlock()

        operationProgress[name] = ProgressInfo{
                Name:      name,
                StartTime: time.Now(),
                Progress:  0.0,
                Status:    "running",
        }
        totalOperations++</span>
}

// UpdateProgress updates the progress of an operation
func UpdateProgress(name string, progress float64, status string) <span class="cov0" title="0">{
        if !IsStatsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">statsMutex.Lock()
        defer statsMutex.Unlock()

        if info, exists := operationProgress[name]; exists </span><span class="cov0" title="0">{
                info.Progress = progress
                info.Status = status
                operationProgress[name] = info
        }</span>
}

// CompleteOperation marks an operation as completed
func CompleteOperation(name string) <span class="cov0" title="0">{
        if !IsStatsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">statsMutex.Lock()
        defer statsMutex.Unlock()

        if info, exists := operationProgress[name]; exists </span><span class="cov0" title="0">{
                now := time.Now()
                info.EndTime = &amp;now
                info.Duration = now.Sub(info.StartTime)
                info.Progress = 100.0 // Always set progress to 100% on completion
                info.Status = "completed"
                operationProgress[name] = info
                completedOps++
        }</span>
}

// FailOperation marks an operation as failed
func FailOperation(name string, reason string) <span class="cov0" title="0">{
        if !IsStatsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">statsMutex.Lock()
        defer statsMutex.Unlock()

        if info, exists := operationProgress[name]; exists </span><span class="cov0" title="0">{
                now := time.Now()
                info.EndTime = &amp;now
                info.Duration = now.Sub(info.StartTime)
                info.Status = fmt.Sprintf("failed: %s", reason)
                operationProgress[name] = info
                completedOps++
        }</span>
}

// PrintStats displays comprehensive command statistics
func PrintStats() <span class="cov0" title="0">{
        if !IsStatsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">statsMutex.RLock()
        defer statsMutex.RUnlock()

        endTime := time.Now()
        totalDuration := endTime.Sub(commandStartTime)

        // Calculate success rate
        successCount := 0
        for _, op := range operationProgress </span><span class="cov0" title="0">{
                if op.Status == "completed" </span><span class="cov0" title="0">{
                        successCount++
                }</span>
        }

        <span class="cov0" title="0">successRate := 0.0
        if totalOperations &gt; 0 </span><span class="cov0" title="0">{
                successRate = (float64(successCount) / float64(totalOperations)) * 100
        }</span>

        // Get memory usage
        <span class="cov0" title="0">memUsage := GetMemoryUsage()

        fmt.Printf("\n%s%s╔══════════════════════════════════════════════════════════════════════════════╗%s\n", Green, BlackBg, Reset)
        fmt.Printf("%s%s║                            📊 COMMAND STATISTICS                             ║%s\n", Green, BlackBg, Reset)
        fmt.Printf("%s%s╚══════════════════════════════════════════════════════════════════════════════╝%s\n", Green, BlackBg, Reset)

        fmt.Printf("\n%s⏱️  Total Execution Time:%s %v\n", Cyan, Reset, totalDuration.Round(time.Millisecond))
        fmt.Printf("%s📈 Operations Completed:%s %d/%d (%.1f%% success rate)\n", Cyan, Reset, successCount, totalOperations, successRate)
        fmt.Printf("%s💾 Memory Usage:%s %s\n", Cyan, Reset, memUsage)
        fmt.Printf("%s⚡ Start Time:%s %s\n", Cyan, Reset, commandStartTime.Format("15:04:05"))
        fmt.Printf("%s🏁 End Time:%s %s\n", Cyan, Reset, endTime.Format("15:04:05"))

        // Display clustering configuration if available
        if clusteringInfo != nil </span><span class="cov0" title="0">{
                fmt.Printf("\n%s%s🧠 CLUSTERING CONFIGURATION:%s\n", Yellow, Bold, Reset)
                fmt.Printf("%s🎯 Primary Method:%s %s\n", Cyan, Reset, clusteringInfo.Method)

                if len(clusteringInfo.EnabledMethods) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("%s🔧 Enabled Methods:%s %v\n", Cyan, Reset, clusteringInfo.EnabledMethods)
                }</span>

                <span class="cov0" title="0">fmt.Printf("%s🚀 Performance Mode:%s %s\n", Cyan, Reset, clusteringInfo.PerformanceMode)
                fmt.Printf("%s⏰ Max Processing Time:%s %ds\n", Cyan, Reset, clusteringInfo.MaxProcessingTime)
                fmt.Printf("%s📁 Max Files for Semantic:%s %d\n", Cyan, Reset, clusteringInfo.MaxFilesForSemantic)
                fmt.Printf("%s🔄 Fallback Methods:%s %t\n", Cyan, Reset, clusteringInfo.EnableFallbackMethods)
                fmt.Printf("%s📊 Benchmarking:%s %t\n", Cyan, Reset, clusteringInfo.EnableBenchmarking)
                fmt.Printf("%s🧠 Adaptive Optimization:%s %t\n", Cyan, Reset, clusteringInfo.AdaptiveOptimization)

                // Display confidence thresholds
                if len(clusteringInfo.ConfidenceThresholds) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("\n%s%s🎚️ Confidence Thresholds:%s\n", Yellow, Bold, Reset)
                        for method, threshold := range clusteringInfo.ConfidenceThresholds </span><span class="cov0" title="0">{
                                fmt.Printf("   %s• %s:%s %.2f\n", Cyan, method, Reset, threshold)
                        }</span>
                }

                // Display similarity thresholds
                <span class="cov0" title="0">if len(clusteringInfo.SimilarityThresholds) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("\n%s%s🔍 Similarity Thresholds:%s\n", Yellow, Bold, Reset)
                        for method, threshold := range clusteringInfo.SimilarityThresholds </span><span class="cov0" title="0">{
                                fmt.Printf("   %s• %s:%s %.2f\n", Cyan, method, Reset, threshold)
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(operationProgress) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n%s%s📋 Operation Details:%s\n", Yellow, Bold, Reset)
                for name, info := range operationProgress </span><span class="cov0" title="0">{
                        status := info.Status
                        statusColor := Green
                        if info.Status != "completed" &amp;&amp; info.Status != "running" </span><span class="cov0" title="0">{
                                statusColor = Red
                        }</span> else<span class="cov0" title="0"> if info.Status == "running" </span><span class="cov0" title="0">{
                                statusColor = Yellow
                        }</span>

                        <span class="cov0" title="0">duration := "ongoing"
                        if info.EndTime != nil </span><span class="cov0" title="0">{
                                duration = info.Duration.Round(time.Millisecond).String()
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("   %s• %s:%s %s%s%s (Duration: %s, Progress: %.1f%%)\n",
                                Cyan, name, Reset, statusColor, status, Reset, duration, info.Progress)</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("\n%s%s════════════════════════════════════════════════════════════════════════════════%s\n", Green, BlackBg, Reset)</span>
}

// GetMemoryUsage returns current memory usage as a formatted string
func GetMemoryUsage() string <span class="cov0" title="0">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        // Convert bytes to megabytes for easier reading
        memMB := float64(m.Alloc) / 1024 / 1024
        return fmt.Sprintf("%.1f MB", memMB)
}</span>

// AddStatsPostRunToCommand adds a PostRun function to display stats for a command
func AddStatsPostRunToCommand(cmd *cobra.Command) <span class="cov0" title="0">{
        // Save existing PostRun if there is one
        existingPostRun := cmd.PostRun

        cmd.PostRun = func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                // Call the existing PostRun if there is one
                if existingPostRun != nil </span><span class="cov0" title="0">{
                        existingPostRun(cmd, args)
                }</span>

                // Mark command operation as complete if it was started
                <span class="cov0" title="0">if IsStatsEnabled() </span><span class="cov0" title="0">{
                        commandName := "Command:" + cmd.Name()
                        if _, exists := operationProgress[commandName]; exists </span><span class="cov0" title="0">{
                                MarkOperationComplete(commandName)
                        }</span>

                        // Print stats
                        <span class="cov0" title="0">PrintStats()</span>
                }
        }
}

// UpdateOperationProgress is a helper function to update operation progress
// and ensure consistent progress tracking in the stats system
func UpdateOperationProgress(name string, progress float64) <span class="cov0" title="0">{
        if !IsStatsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        // Update the progress
        <span class="cov0" title="0">UpdateProgress(name, progress, "running")</span>
}

// MarkOperationComplete is a helper function to mark an operation as complete
// with proper progress handling
func MarkOperationComplete(name string) <span class="cov0" title="0">{
        if !IsStatsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        // Ensure progress is set to 100% before completion
        <span class="cov0" title="0">UpdateProgress(name, 100.0, "running")
        CompleteOperation(name)</span>
}

// SetClusteringInfo stores clustering configuration information for stats display
func SetClusteringInfo(method string, enabledMethods []string, confidenceThresholds, similarityThresholds map[string]float64,
        maxFilesForSemantic int, enableFallbackMethods bool, performanceMode string, maxProcessingTime int,
        enableBenchmarking, adaptiveOptimization bool) <span class="cov0" title="0">{
        if !IsStatsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">statsMutex.Lock()
        defer statsMutex.Unlock()

        clusteringInfo = &amp;ClusteringMethodInfo{
                Method:                method,
                EnabledMethods:        enabledMethods,
                ConfidenceThresholds:  confidenceThresholds,
                SimilarityThresholds:  similarityThresholds,
                MaxFilesForSemantic:   maxFilesForSemantic,
                EnableFallbackMethods: enableFallbackMethods,
                PerformanceMode:       performanceMode,
                MaxProcessingTime:     maxProcessingTime,
                EnableBenchmarking:    enableBenchmarking,
                AdaptiveOptimization:  adaptiveOptimization,
        }</span>
}

// GetClusteringInfo returns the stored clustering configuration
func GetClusteringInfo() *ClusteringMethodInfo <span class="cov0" title="0">{
        statsMutex.RLock()
        defer statsMutex.RUnlock()
        return clusteringInfo
}</span>

// CaptureClusteringConfig captures clustering configuration from the config package
// This function should be called when clustering operations begin
func CaptureClusteringConfig() <span class="cov0" title="0">{
        if !IsStatsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        // We'll need to import the config package to get clustering configuration
        // For now, we'll create a basic version that can be enhanced
        <span class="cov0" title="0">statsMutex.Lock()
        defer statsMutex.Unlock()

        // Default clustering info - this will be enhanced when we integrate with config
        clusteringInfo = &amp;ClusteringMethodInfo{
                Method:         "auto",
                EnabledMethods: []string{"directory", "pattern", "cached", "semantic"},
                ConfidenceThresholds: map[string]float64{
                        "directory": 0.8,
                        "pattern":   0.7,
                        "cached":    0.6,
                        "semantic":  0.5,
                },
                SimilarityThresholds: map[string]float64{
                        "directory": 0.7,
                        "pattern":   0.6,
                        "cached":    0.5,
                        "semantic":  0.4,
                },
                MaxFilesForSemantic:   10,
                EnableFallbackMethods: true,
                PerformanceMode:       "balanced",
                MaxProcessingTime:     60,
                EnableBenchmarking:    false,
                AdaptiveOptimization:  true,
        }</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package utils

import (
        "fmt"
)

// CaptureClusteringConfigFromSettings captures clustering configuration info from provided parameters
func CaptureClusteringConfigFromSettings(
        defaultMethod string,
        enabledMethods []string,
        confidenceThresholds map[string]float64,
        similarityThresholds map[string]float64,
        maxFilesForSemantic int,
        enableFallbackMethods bool,
        performanceMode string,
        maxProcessingTime int,
        enableBenchmarking bool,
        adaptiveOptimization bool,
) <span class="cov0" title="0">{
        if !IsStatsEnabled() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">statsMutex.Lock()
        defer statsMutex.Unlock()

        clusteringInfo = &amp;ClusteringMethodInfo{
                Method:                defaultMethod,
                EnabledMethods:        enabledMethods,
                ConfidenceThresholds:  confidenceThresholds,
                SimilarityThresholds:  similarityThresholds,
                MaxFilesForSemantic:   maxFilesForSemantic,
                EnableFallbackMethods: enableFallbackMethods,
                PerformanceMode:       performanceMode,
                MaxProcessingTime:     maxProcessingTime,
                EnableBenchmarking:    enableBenchmarking,
                AdaptiveOptimization:  adaptiveOptimization,
        }

        Debug("[STATS.CLUSTERING]: Captured clustering configuration - Method: " + defaultMethod +
                ", Enabled Methods: " + fmt.Sprintf("%v", enabledMethods) +
                ", Performance Mode: " + performanceMode)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package utils

import (
"strings"
)

// ContainsString checks if a string contains a substring
func ContainsString(s, substr string) bool <span class="cov0" title="0">{
return strings.Contains(s, substr)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package utils

import (
        "context"
        "sync"
        "time"
)

// WorkerPool implements a reusable worker pool with configurable concurrency limit
type WorkerPool struct {
        maxWorkers int
        semaphore  chan struct{}
        wg         sync.WaitGroup
        mu         sync.Mutex
        errors     []error
}

// NewWorkerPool creates a new worker pool with the specified maximum concurrent workers
func NewWorkerPool(maxWorkers int) *WorkerPool <span class="cov0" title="0">{
        if maxWorkers &lt;= 0 </span><span class="cov0" title="0">{
                maxWorkers = 1
        }</span>

        <span class="cov0" title="0">return &amp;WorkerPool{
                maxWorkers: maxWorkers,
                semaphore:  make(chan struct{}, maxWorkers),
                errors:     make([]error, 0),
        }</span>
}

// Submit adds a task to the worker pool with the specified timeout
func (wp *WorkerPool) Submit(taskName string, timeout time.Duration, task func() error) <span class="cov0" title="0">{
        wp.wg.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer wp.wg.Done()

                // Acquire semaphore slot (blocks if max workers is reached)
                wp.semaphore &lt;- struct{}{}
                defer func() </span><span class="cov0" title="0">{ &lt;-wp.semaphore }</span>()

                // Create context with timeout
                <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), timeout)
                defer cancel()

                // Channel for task completion
                done := make(chan error, 1)

                // Run the task in a separate goroutine
                go func() </span><span class="cov0" title="0">{
                        err := SafeExecute(taskName, task)
                        done &lt;- err
                }</span>()

                // Wait for either task completion or timeout
                <span class="cov0" title="0">select </span>{
                case err := &lt;-done:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                wp.addError(err)
                        }</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        wp.addError(NewSystemError(
                                "Task timed out",
                                ctx.Err(),
                                map[string]interface{}{
                                        "taskName": taskName,
                                        "timeout":  timeout.String(),
                                },
                        ))</span>
                }
        }()
}

// Wait blocks until all tasks have completed
func (wp *WorkerPool) Wait() []error <span class="cov0" title="0">{
        wp.wg.Wait()
        return wp.Errors()
}</span>

// Errors returns all errors collected from task execution
func (wp *WorkerPool) Errors() []error <span class="cov0" title="0">{
        wp.mu.Lock()
        defer wp.mu.Unlock()

        // Make a copy to avoid race conditions
        errCopy := make([]error, len(wp.errors))
        copy(errCopy, wp.errors)

        return errCopy
}</span>

// HasErrors returns true if any tasks have reported errors
func (wp *WorkerPool) HasErrors() bool <span class="cov0" title="0">{
        wp.mu.Lock()
        defer wp.mu.Unlock()
        return len(wp.errors) &gt; 0
}</span>

// addError safely adds an error to the error list
func (wp *WorkerPool) addError(err error) <span class="cov0" title="0">{
        wp.mu.Lock()
        defer wp.mu.Unlock()
        wp.errors = append(wp.errors, err)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
