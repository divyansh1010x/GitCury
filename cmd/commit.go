// package cmd

// import (
// 	"GitCury/config"
// 	"GitCury/core"
// 	"GitCury/git"
// 	"GitCury/utils"
// 	"os"
// 	"time"

// 	"github.com/spf13/cobra"
// )

// var (
// 	sealDateTime string
// 	sealAllFlag  bool
// 	folderName   string
// )

// var commitCmd = &cobra.Command{
// 	Use:   "commit",
// 	Short: "Commit changes with autogenerated commit messages",
// 	Long: `
// Commit changes with autogenerated commit messages.

// Aliases:
// • ` + config.Aliases.Commit + `

// Options:
// • --all : Commit all changes with autogenerated messages.
// • --root <folder> : Commit changes in a specific root folder with autogenerated messages.

// Examples:
// • Commit all changes:
// 	gitcury commit --all

// • Commit changes in a folder:
// 	gitcury commit --root my-folder

// [NOTICE]: Ensure the commit messages are generated before committing.
// `,
// 	Run: func(cmd *cobra.Command, args []string) {
// 		// Use our SafeExecute function to add panic recovery
// 		err := utils.SafeExecute("CommitChanges", func() error {
// 			if sealAllFlag {
// 				utils.Info("[" + config.Aliases.Commit + "]: Committing all changes across root folders.")
// 				err := core.CommitAllRoots()
// 				if err != nil {
// 					return utils.NewGitError(
// 						"Failed to commit all changes",
// 						err,
// 						map[string]interface{}{
// 							"operation": "CommitAllRoots",
// 						},
// 					)
// 				}
// 				utils.Success("[" + config.Aliases.Commit + "]: All changes committed successfully.")
// 			} else if folderName != "" {
// 				// Validate the folder exists
// 				if _, err := os.Stat(folderName); os.IsNotExist(err) {
// 					return utils.NewValidationError(
// 						"Root folder does not exist",
// 						err,
// 						map[string]interface{}{
// 							"folderName": folderName,
// 						},
// 					)
// 				}

// 				utils.Info("[" + config.Aliases.Commit + "]: Targeting root folder: " + folderName)
// 				err := core.CommitOneRoot(folderName)
// 				if err != nil {
// 					return utils.NewGitError(
// 						"Failed to commit changes in folder",
// 						err,
// 						map[string]interface{}{
// 							"operation": "CommitOneRoot",
// 							"folder": folderName,
// 						},
// 					)
// 				}
// 				utils.Success("[" + config.Aliases.Commit + "]: Changes in the specified folder committed successfully.")
// 			} else {
// 				return utils.NewValidationError(
// 					"You must specify either --all or --root flag",
// 					nil,
// 					map[string]interface{}{
// 						"availableFlags": []string{"--all", "--root"},
// 					},
// 				)
// 			}
// 			return nil
// 		})

// 		if err != nil {
// 			utils.Error(utils.ToUserFriendlyMessage(err))
// 		}
// 	},
// }

// var withDateCmd = &cobra.Command{
// 	Use:   "with-date",
// 	Short: "Commit changes with a specified timestamp",
// 	Long: `
// Commit changes with a specific date and time.

// Options:
// • --all : Commit all changes with the given timestamp.
// • --root <folder> : Commit changes in a specific folder with the given timestamp.

// Examples:
// • Commit all changes with a timestamp:
// 	gitcury commit with-date --datetime "2025-01-01T12:00:00" --all

// • Commit changes in a folder with a timestamp:
// 	gitcury commit with-date --datetime "2025-01-01T12:00:00" --root my-folder

// [NOTICE]: Ensure the date and time format is 'YYYY-MM-DDTHH:MM:SS'.
// [NOTICE]: The system date and time will not be changed; only the commit date and time will be set.
// [NOTICE]: Use with caution, as this may affect commit history and collaboration.
// `,
// 	Run: func(cmd *cobra.Command, args []string) {
// 		err := utils.SafeExecute("CommitWithDate", func() error {
// 			if sealDateTime == "" {
// 				return utils.NewValidationError(
// 					"Datetime parameter is required",
// 					nil,
// 					map[string]interface{}{
// 						"requiredFormat": "YYYY-MM-DDTHH:MM:SS",
// 						"example": "2025-01-01T12:00:00",
// 					},
// 				)
// 			}

// 			// Validate date-time format
// 			_, err := time.Parse("2006-01-02T15:04:05", sealDateTime)
// 			if err != nil {
// 				return utils.NewValidationError(
// 					"Invalid datetime format",
// 					err,
// 					map[string]interface{}{
// 						"providedValue": sealDateTime,
// 						"requiredFormat": "YYYY-MM-DDTHH:MM:SS",
// 						"example": "2025-01-01T12:00:00",
// 					},
// 				)
// 			}

// 			// Set Git environment variables for the commit
// 			env := append(os.Environ(),
// 				"GIT_AUTHOR_DATE="+sealDateTime,
// 				"GIT_COMMITTER_DATE="+sealDateTime,
// 			)
// 			utils.Info("[" + config.Aliases.Commit + "]: Setting commit date and time to: " + sealDateTime)

// 			// Execute commit logic
// 			if sealAllFlag {
// 				utils.Info("[" + config.Aliases.Commit + "]: Committing all changes with custom timestamp.")
// 				err := core.CommitAllRoots(env)
// 				if err != nil {
// 					return utils.NewGitError(
// 						"Failed to commit all changes with custom timestamp",
// 						err,
// 						map[string]interface{}{
// 							"operation": "CommitAllRoots",
// 							"timestamp": sealDateTime,
// 						},
// 					)
// 				}
// 			} else if folderName != "" {
// 				// Validate the folder exists
// 				if _, err := os.Stat(folderName); os.IsNotExist(err) {
// 					return utils.NewValidationError(
// 						"Root folder does not exist",
// 						err,
// 						map[string]interface{}{
// 							"folderName": folderName,
// 						},
// 					)
// 				}

// 				utils.Info("[" + config.Aliases.Commit + "]: Committing changes in folder with custom timestamp: " + folderName)
// 				err := core.CommitOneRoot(folderName, env)
// 				if err != nil {
// 					return utils.NewGitError(
// 						"Failed to commit changes in folder with custom timestamp",
// 						err,
// 						map[string]interface{}{
// 							"operation": "CommitOneRoot",
// 							"folder": folderName,
// 							"timestamp": sealDateTime,
// 						},
// 					)
// 				}
// 			} else {
// 				return utils.NewValidationError(
// 					"You must specify either --all or --root flag",
// 					nil,
// 					map[string]interface{}{
// 						"availableFlags": []string{"--all", "--root"},
// 					},
// 				)
// 			}

// 			utils.Success("[" + config.Aliases.Commit + "]: Changes committed with the specified timestamp successfully.")
// 			return nil
// 		})

// 		if err != nil {
// 			utils.Error(utils.ToUserFriendlyMessage(err))
// 		}
// 	},
// }

// func init() {
// 	// Add flags for the with-date subcommand
// 	withDateCmd.Flags().StringVarP(&sealDateTime, "datetime", "d", "", "Specify the commit date and time in 'YYYY-MM-DDTHH:MM:SS' format")
// 	withDateCmd.Flags().BoolVarP(&sealAllFlag, "all", "a", false, "Commit all changes with autogenerated messages")
// 	withDateCmd.Flags().StringVarP(&folderName, "root", "r", "", "Commit changes in the specified root folder with autogenerated messages")

// 	// Add the with-date subcommand to the seal command
// 	commitCmd.AddCommand(withDateCmd)

// 	// Add flags to the main seal command
// 	commitCmd.Flags().BoolVarP(&sealAllFlag, "all", "a", false, "Commit all changes with autogenerated messages")
// 	commitCmd.Flags().StringVarP(&folderName, "root", "r", "", "Commit changes in the specified root folder with autogenerated messages")

// 	// Add the seal command to the root command
// 	rootCmd.AddCommand(commitCmd)
// }

package cmd

import (
	"GitCury/config"
	"GitCury/core"
	"GitCury/git"
	"GitCury/output"
	"GitCury/utils"
	"os"
	"time"

	"github.com/spf13/cobra"
)

var (
	sealDateTime string
	sealAllFlag  bool
	folderName   string
)

var commitCmd = &cobra.Command{
	Use:   "commit",
	Short: "Commit changes with autogenerated commit messages",
	Long: `
Commit changes with autogenerated commit messages.

Aliases:
• ` + config.Aliases.Commit + `

Options:
• --all : Commit all changes with autogenerated messages.
• --root <folder> : Commit changes in a specific root folder with autogenerated messages.

Examples:
• Commit all changes:
	gitcury commit --all

• Commit changes in a folder:
	gitcury commit --root my-folder

[NOTICE]: Ensure the commit messages are generated before committing.
`,
	Run: func(cmd *cobra.Command, args []string) {
		// Start stats tracking if enabled
		if utils.IsStatsEnabled() {
			if sealAllFlag {
				utils.StartOperation("CommitAllRoots")
				// Set initial progress
				utils.UpdateOperationProgress("CommitAllRoots", 10.0)
			} else if folderName != "" {
				utils.StartOperation("CommitOneRoot")
				// Set initial progress
				utils.UpdateOperationProgress("CommitOneRoot", 10.0)
			}
		}

		// Use our SafeExecute function to add panic recovery
		err := utils.SafeExecute("CommitChanges", func() error {
			if sealAllFlag {
				utils.Info("[" + config.Aliases.Commit + "]: Committing all changes across root folders.")
				err := core.CommitAllRoots()
				if err != nil {
					if utils.IsStatsEnabled() {
						utils.FailOperation("CommitAllRoots", err.Error())
					}
					return utils.NewGitError(
						"Failed to commit all changes",
						err,
						map[string]interface{}{
							"operation": "CommitAllRoots",
						},
					)
				}
				if utils.IsStatsEnabled() {
					utils.MarkOperationComplete("CommitAllRoots")
				}
				utils.Success("[" + config.Aliases.Commit + "]: All changes committed successfully.")
			} else if folderName != "" {
				// Validate the folder exists
				if _, err := os.Stat(folderName); os.IsNotExist(err) {
					if utils.IsStatsEnabled() {
						utils.FailOperation("CommitOneRoot", "Root folder does not exist: "+folderName)
					}
					return utils.NewValidationError(
						"Root folder does not exist",
						err,
						map[string]interface{}{
							"folderName": folderName,
						},
					)
				}

				utils.Info("[" + config.Aliases.Commit + "]: Targeting root folder: " + folderName)
				err := core.CommitOneRoot(folderName)
				if err != nil {
					if utils.IsStatsEnabled() {
						utils.FailOperation("CommitOneRoot", err.Error())
					}
					return utils.NewGitError(
						"Failed to commit changes in folder",
						err,
						map[string]interface{}{
							"operation": "CommitOneRoot",
							"folder":    folderName,
						},
					)
				}
				if utils.IsStatsEnabled() {
					utils.MarkOperationComplete("CommitOneRoot")
				}
				utils.Success("[" + config.Aliases.Commit + "]: Changes in the specified folder committed successfully.")
			} else {
				if utils.IsStatsEnabled() {
					utils.FailOperation("CommitChanges", "No operation flag specified")
				}
				return utils.NewValidationError(
					"You must specify either --all or --root flag",
					nil,
					map[string]interface{}{
						"availableFlags": []string{"--all", "--root"},
					},
				)
			}
			return nil
		})

		if err != nil {
			utils.Error(utils.ToUserFriendlyMessage(err))
		} else if utils.IsStatsEnabled() {
			utils.PrintStats()
		}
	},
}

var withDateCmd = &cobra.Command{
	Use:   "with-date",
	Short: "Commit changes with a specified timestamp",
	Long: `
Commit changes with a specific date and time.

Options:
• --all : Commit all changes with the given timestamp.
• --root <folder> : Commit changes in a specific folder with the given timestamp.

Examples:
• Commit all changes with a timestamp:
	gitcury commit with-date --datetime "2025-01-01T12:00:00" --all

• Commit changes in a folder with a timestamp:
	gitcury commit with-date --datetime "2025-01-01T12:00:00" --root my-folder

[NOTICE]: Ensure the date and time format is 'YYYY-MM-DDTHH:MM:SS'.
[NOTICE]: The system date and time will not be changed; only the commit date and time will be set.
[NOTICE]: Use with caution, as this may affect commit history and collaboration.
`,
	Run: func(cmd *cobra.Command, args []string) {
		err := utils.SafeExecute("CommitWithDate", func() error {
			if sealDateTime == "" {
				return utils.NewValidationError(
					"Datetime parameter is required",
					nil,
					map[string]interface{}{
						"requiredFormat": "YYYY-MM-DDTHH:MM:SS",
						"example":        "2025-01-01T12:00:00",
					},
				)
			}

			// Validate date-time format
			parsedTime, err := time.Parse("2006-01-02T15:04:05", sealDateTime)
			if err != nil {
				return utils.NewValidationError(
					"Invalid datetime format",
					err,
					map[string]interface{}{
						"providedValue":  sealDateTime,
						"requiredFormat": "YYYY-MM-DDTHH:MM:SS",
						"example":        "2025-01-01T12:00:00",
					},
				)
			}

			// Check if the date is in the future
			now := time.Now()
			if parsedTime.After(now) {
				utils.Warning("[" + config.Aliases.Commit + "]: The specified datetime is in the future. This may cause issues with Git history.")

				// Ask for confirmation before proceeding with future date
				details := []string{
					"You are attempting to create a commit with a future date: " + sealDateTime,
					"Current date and time: " + now.Format(time.RFC3339),
					"This may cause confusion in git history and affect collaboration.",
				}

				if !utils.ConfirmActionWithDetails("Commit with future date?", details, false) {
					return utils.NewUserError(
						"Operation cancelled by user",
						nil,
						map[string]interface{}{
							"providedDate": sealDateTime,
							"currentDate":  now.Format(time.RFC3339),
						},
					)
				}
			}

			// Format date-time for Git environment variables (ISO 8601 format)
			formattedDateTime := parsedTime.Format(time.RFC3339)

			// Set Git environment variables for the commit
			env := append(os.Environ(),
				"GIT_AUTHOR_DATE="+formattedDateTime,
				"GIT_COMMITTER_DATE="+formattedDateTime,
			)
			utils.Info("[" + config.Aliases.Commit + "]: Setting commit date and time to: " + formattedDateTime)

			// Execute commit logic
			if sealAllFlag {
				utils.Info("[" + config.Aliases.Commit + "]: Committing all changes with custom timestamp.")
				err := core.CommitAllRoots(env)
				if err != nil {
					return utils.NewGitError(
						"Failed to commit all changes with custom timestamp",
						err,
						map[string]interface{}{
							"operation": "CommitAllRoots",
							"timestamp": formattedDateTime,
						},
					)
				}
			} else if folderName != "" {
				// Validate the folder exists
				if _, err := os.Stat(folderName); os.IsNotExist(err) {
					return utils.NewValidationError(
						"Root folder does not exist",
						err,
						map[string]interface{}{
							"folderName": folderName,
							"suggestion": "Check the folder path and try again",
						},
					)
				}

				utils.Info("[" + config.Aliases.Commit + "]: Committing changes in folder with custom timestamp: " + folderName)

				// Use git recovery mechanism for safer operations with progress reporting
				err := git.SafeGitOperation(folderName, "CommitWithDate", func() error {
					// Get all files that need to be committed
					folder := output.GetFolder(folderName)
					if len(folder.Files) == 0 {
						return utils.NewValidationError(
							"No files to commit in folder",
							nil,
							map[string]interface{}{
								"folder": folderName,
							},
						)
					}

					// Use enhanced commit with progress reporting
					return git.ProgressCommitBatch(folder, env)
				})

				if err != nil {
					return err
				}
			} else {
				return utils.NewValidationError(
					"You must specify either --all or --root flag",
					nil,
					map[string]interface{}{
						"availableFlags": []string{"--all", "--root"},
						"examples": []string{
							"gitcury commit with-date --datetime \"2025-01-01T12:00:00\" --all",
							"gitcury commit with-date --datetime \"2025-01-01T12:00:00\" --root my-folder",
						},
					},
				)
			}

			utils.Success("[" + config.Aliases.Commit + "]: Changes committed with the specified timestamp successfully.")
			return nil
		})

		if err != nil {
			utils.Error(utils.ToUserFriendlyMessage(err))
			cmd.PrintErrln("Error: " + utils.ToUserFriendlyMessage(err))
		}
	},
}

func init() {
	// Add flags for the with-date subcommand
	withDateCmd.Flags().StringVarP(&sealDateTime, "datetime", "t", "", "Specify the commit date and time in 'YYYY-MM-DDTHH:MM:SS' format")
	withDateCmd.Flags().BoolVarP(&sealAllFlag, "all", "a", false, "Commit all changes with autogenerated messages")
	withDateCmd.Flags().StringVarP(&folderName, "root", "r", "", "Commit changes in the specified root folder with autogenerated messages")

	// Add the with-date subcommand to the seal command
	commitCmd.AddCommand(withDateCmd)

	// Add flags to the main seal command
	commitCmd.Flags().BoolVarP(&sealAllFlag, "all", "a", false, "Commit all changes with autogenerated messages")
	commitCmd.Flags().StringVarP(&folderName, "root", "r", "", "Commit changes in the specified root folder with autogenerated messages")

	// Add the seal command to the root command
	rootCmd.AddCommand(commitCmd)
}
